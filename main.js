/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SyncSnowflake2,
  gitlab: () => gitlab,
  local_changes_logs: () => local_changes_logs,
  pocket: () => pocket,
  req_queue: () => req_queue,
  sync_logs: () => sync_logs
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/gitlab_api.ts
var import_obsidian = require("obsidian");

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2)
    return key;
  return path2.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index) {
    let name = path2[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path2.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path2, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path2) && cookie.push("path=" + path2);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders_default.from(config.headers).normalize();
    let { responseType, withXSRFToken } = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils_default.isFormData(requestData)) {
      if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitional_default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform_default.hasStandardBrowserEnv) {
      withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(fullPath)) {
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.6.2";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// src/gitlab_api.ts
var urlslash = (...text) => {
  const path2 = text.join("/");
  const end = path2.slice(path2.lastIndexOf("/"));
  const start = path2.slice(0, path2.lastIndexOf("/")).replace(/\./gm, "%2E");
  return (start + end).replace(/\//gm, "%2F");
};
function base64ToArrayBuffer(base64) {
  var binaryString = atob(base64);
  var bytes = new Uint8Array(binaryString.length);
  for (var i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}
var exurl = (_url, _params_no = 0) => ({
  base: (url) => exurl(_url + url, _params_no),
  add: (key, value) => exurl(_url + (_params_no == 0 ? "?" : "&") + `${key}=${value}`, _params_no + 1),
  params: (key, value) => exurl(_url.replace(`:${key}`, value), _params_no),
  value: _url
});
var GitLabAPI = class {
  constructor() {
    this.id = () => urlslash(this.options.project, this.options.repository);
    this.header = () => {
      return {
        "PRIVATE-TOKEN": this.options.token,
        "Content-Type": "application/json"
      };
    };
    this.url = {
      commits: () => exurl(`${this.options.api}/projects/${this.id()}/repository/commits`),
      branches: () => exurl(`${this.options.api}/projects/${this.id()}/repository/branches`),
      files: () => exurl(`${this.options.api}/projects/${this.id()}/repository/files`)
    };
  }
  setoptions(options) {
    this.options = options;
  }
  async get_local_file_content(path2) {
    const array_buffer = await app.vault.adapter.readBinary(path2);
    return (0, import_obsidian.arrayBufferToBase64)(array_buffer);
  }
  async save_local_file(remote_path, local_path, create_if_not_exist = false) {
    if (!local_path)
      local_path = remote_path;
    const remote_file = await this.read(remote_path);
    if (!remote_file) {
      if (create_if_not_exist)
        this.create(remote_path);
    } else
      app.vault.adapter.writeBinary(local_path, base64ToArrayBuffer(remote_file.data.content));
  }
  async get_branches() {
    const url = this.url.branches().add("pt", "null");
    const res = [];
    try {
      await this.pagination(1, url, async (res_item) => {
        res.push(...res_item.data.map((item) => item.name));
      });
    } catch (e) {
      new import_obsidian.Notice(`Cannot get branches
${url.value}`);
    }
    return res;
  }
  async create_branch(branch, parent_branch) {
    const url = this.url.branches().add("branch", urlslash(branch)).add("ref", urlslash(parent_branch)).value;
    const res = [];
    try {
      await axios_default.post(url, null, {
        headers: this.header()
      });
    } catch (e) {
      new import_obsidian.Notice(`Error while creating branch
${url}`);
    }
    return res;
  }
  async save_last_commit() {
    const url = this.url.commits().add("with_stats", "true").add("all", "true").add("per_page", "3").value;
    const res = await axios_default.get(url, {
      headers: this.header()
    });
    const last_commit = res.data.pop();
    pocket.set("last_commit_id", last_commit.id);
    pocket.set("last_commit_date", last_commit.committed_date);
  }
  convertToGitlabCommit(data) {
    return {
      ...data,
      created_at: new Date(data.created_at),
      authored_date: new Date(data.authored_date),
      committed_date: new Date(data.committed_date)
    };
  }
  async get_commit(sha) {
    const url = this.url.commits().base("/" + sha);
    try {
      const res = await axios_default.get(url.value, {
        headers: this.header()
      });
      return this.convertToGitlabCommit(res.data);
    } catch (e) {
      new import_obsidian.Notice(`Cannot get commit
${url.value}`);
    }
    return null;
  }
  async get_commits() {
    const url = this.url.commits().add("with_stats", "true").add("all", "true").add("ref_name", this.options.branch).add("since", pocket.get("last_commit_date") || new Date().toISOString());
    const res = [];
    try {
      await this.pagination(1, url, (res_item) => {
        res.push(...res_item.data);
      });
    } catch (e) {
      new import_obsidian.Notice(`Cannot get commits
${url.value}`);
    }
    return res;
  }
  async get_all_commits() {
    const url = this.url.commits().add("with_stats", "true").add("ref_name", this.options.branch).add("all", "true");
    const res = [];
    try {
      await this.pagination(1, url, (res_item) => {
        res.push(...res_item.data);
      });
    } catch (e) {
      new import_obsidian.Notice(`Cannot get commits
${url.value}`);
    }
    return res;
  }
  async get_meta_data_file(path2) {
    const url = this.url.files().base(`/${urlslash(path2)}`).add("ref", this.options.branch);
    try {
      return await axios_default.head(url.value, {
        headers: this.header()
      });
    } catch (e) {
      new import_obsidian.Notice(`Cannot get file header
${url.value}`);
    }
    return null;
  }
  async pagination(start_page, url, callback, per_page = 100) {
    var _a;
    const page_url = url.add("per_page", per_page.toString()).add("page", start_page.toString());
    const res = await axios_default.get(page_url.value, { headers: this.header() });
    if (((_a = res.data) == null ? void 0 : _a.length) == 0)
      return;
    await callback(res);
    await this.pagination(start_page + 1, url, callback, per_page);
  }
  async blame(path2) {
    const url = this.url.files().base(`/${urlslash(path2)}/blame`).add("ref", this.options.branch).value;
    try {
      const res = await axios_default.get(url, {
        headers: this.header()
      });
      return res.data;
    } catch (e) {
    }
  }
  async get_diffs(commit_id) {
    const url = this.url.commits().base(`/${commit_id}/diff`).value;
    let res = null;
    try {
      res = await axios_default.get(url, { headers: this.header() });
    } catch (e) {
      new import_obsidian.Notice(`Cannot get diff from commit ${commit_id}`);
    }
    return res;
  }
  async create(path2, commit = {}, notifications = true, update_if_exist = true) {
    const file_content = await this.get_local_file_content(path2);
    const data = {
      branch: commit.branch || this.options.branch,
      encoding: commit.encoding || "base64",
      author_email: commit.author_email || this.options.email,
      author_name: commit.author_name || this.options.nick,
      commit_message: commit.commit_message || "created file",
      content: file_content
    };
    const file_url = `${this.options.api}/projects/${this.id()}/repository/files/${urlslash(path2)}?ref=${data.branch}`;
    let res = null;
    try {
      res = await axios_default.post(
        file_url,
        data,
        {
          headers: this.header()
        }
      );
      sync_logs.log(`creating file "${path2}"`);
    } catch (e) {
      sync_logs.log(`FAIL: creating file "${path2}"`);
      if (update_if_exist) {
        if (notifications && this.options.notifications)
          new import_obsidian.Notice("Cannot create file\nTrying update file");
      }
      try {
        await this.modify(path2, commit, notifications, false);
      } catch (e2) {
        if (this.options.notifications)
          new import_obsidian.Notice("Cannot update file");
      }
    }
    return res;
  }
  async modify(path2, commit = {}, notifications = true, create_if_not_exist = true) {
    const file_content = await this.get_local_file_content(path2);
    const data = {
      branch: commit.branch || this.options.branch,
      encoding: commit.encoding || "base64",
      author_email: commit.author_email || this.options.email,
      author_name: commit.author_name || this.options.nick,
      commit_message: commit.commit_message || "modified file",
      content: file_content
    };
    const file_url = `${this.options.api}/projects/${this.id()}/repository/files/${urlslash(path2)}?ref=${data.branch}`;
    let res = null;
    try {
      res = await axios_default.put(
        file_url,
        data,
        {
          headers: this.header()
        }
      );
      sync_logs.log(`modifying file "${path2}"`);
    } catch (e) {
      sync_logs.log(`FAIL: modifying file "${path2}"`);
      if (create_if_not_exist) {
        if (notifications && this.options.notifications)
          new import_obsidian.Notice("Cannot update file\nTrying create file");
      }
      try {
        await this.create(path2, commit, notifications, false);
      } catch (e2) {
        if (this.options.notifications)
          new import_obsidian.Notice("Cannot create file");
      }
    }
    return res;
  }
  async delete(path2, commit = {}, notifications = true) {
    const data = {
      branch: commit.branch || this.options.branch,
      author_email: commit.author_email || this.options.email,
      author_name: commit.author_name || this.options.nick,
      commit_message: commit.commit_message || "deleted file"
    };
    const file_url = `${this.options.api}/projects/${this.id()}/repository/files/${urlslash(path2)}?ref=${data.branch}`;
    let res = null;
    try {
      res = await axios_default({
        method: "DELETE",
        url: file_url,
        data,
        headers: this.header()
      });
      sync_logs.log(`deleting file "${path2}"`);
    } catch (e) {
      sync_logs.log(`FAIL: deleting file "${path2}"`);
      if (notifications && this.options.notifications)
        new import_obsidian.Notice("Cannot delete file");
    }
    return res;
  }
  async rename(path2, old_path, commit = {}, notifications = true) {
    try {
      await this.create(path2, commit, notifications);
      await this.delete(old_path, commit, notifications);
      sync_logs.log(`renaming file "${old_path}" -> "${path2}"`);
    } catch (e) {
      sync_logs.log(`FAIL: renaming file "${old_path}" -> "${path2}"`);
    }
  }
  async read(path2, branch = this.options.branch) {
    const file_url = `${this.options.api}/projects/${this.id()}/repository/files/${urlslash(path2)}?ref=${branch}`;
    let res = null;
    try {
      res = await axios_default.get(
        file_url,
        {
          headers: this.header()
        }
      );
      sync_logs.log(`reading file "${path2}"`);
    } catch (e) {
      sync_logs.log(`FAIL: reading file "${path2}"`);
      if (this.options.notifications)
        new import_obsidian.Notice("Cannot read file");
    }
    return res;
  }
  async read_repo_tree(path2 = "", depth = 0, depth_limit = -1, notifications = true) {
    const url = exurl(`${this.options.api}/projects/${this.id()}/repository/tree`).add("path", urlslash(path2)).add("ref", this.options.branch).add("recursive", "true");
    const tree = [];
    const pages = [];
    await this.pagination(1, url, (res) => {
      pages.push(...res.data);
    });
    for (const item of pages) {
      tree.push([item.id, item.path, item.type == "tree"]);
      if (this.options.notifications && notifications && item.type == "tree")
        new import_obsidian.Notice(`Fetching: "${item.path}"`);
    }
    return tree;
  }
  snippet(title, description = "", visibility = "private") {
    const snippet = new GitLabAPISnippet(this);
    snippet.metadata({ title, description, visibility });
    return snippet;
  }
};
var GitLabAPISnippet = class extends GitLabAPI {
  constructor(gitlab2) {
    super();
    this.sync = false;
    this.files = [];
    this.setoptions(gitlab2.options);
  }
  body() {
    return {
      title: this.title,
      description: this.description,
      visibility: this.visibility,
      files: []
    };
  }
  metadata(snippet) {
    this.title = snippet.title;
    this.description = snippet.description;
    this.visibility = snippet.visibility;
  }
  async add_files(...files) {
    for (const file of files) {
      file.action = file.action || "create";
      this.files.push(file);
    }
    if (this.sync) {
      if (this.snippet_id)
        await this.update_snippet({ files });
      else
        await this.create_snippet({ files });
    }
  }
  async update_files(...files) {
    for (const file of files) {
      file.action = file.action || "update";
      if (!!file.previous_path)
        file.action = "move";
      for (let index in this.files) {
        const item = this.files[index];
        if (file.file_path == item.file_path || file.previous_path == item.file_path)
          this.files[index] = file;
      }
    }
    if (this.sync)
      await this.update_snippet({ files });
  }
  async remove_files(...files) {
    for (const file of files) {
      file.action = "delete";
      if (!file.file_path)
        continue;
      file.content = "";
      file.previous_path = "";
      for (let index = 0; index < this.files.length; index++) {
        const item = this.files[index];
        if (file.file_path == item.file_path || file.previous_path == item.file_path)
          this.files.splice(index, 1);
      }
    }
    if (this.sync)
      await this.update_snippet({ files });
  }
  async from_id(id) {
    const snippet = await axios_default.get(
      `${this.options.api}/projects/${this.id()}/snippets/${id}`,
      { headers: this.header() }
    );
    console.log(snippet);
    if (snippet && snippet.data) {
      this.snippet_id = id;
      this.title = snippet.data.title;
    }
    return snippet.data;
  }
  async create_snippet(body = {}) {
    const create = await axios_default.post(
      `${this.options.api}/projects/${this.id()}/snippets`,
      { ...this.body(), ...body },
      { headers: this.header() }
    );
    this.snippet_id = create.data.id;
  }
  async update_snippet(body = {}) {
    if (!this.snippet_id)
      return;
    await axios_default.put(
      `${this.options.api}/projects/${this.id()}/snippets/${this.snippet_id}`,
      { ...this.body(), ...body },
      { headers: this.header() }
    );
  }
  async delete_snippet() {
    if (!this.snippet_id)
      return;
    return await axios_default.delete(
      `${this.options.api}/projects/${this.id()}/snippets/${this.snippet_id}`,
      { headers: this.header() }
    );
  }
  async get_file(path2) {
    if (!this.snippet_id)
      return;
    const res = await axios_default.get(
      `${this.options.api}/projects/${this.id()}/snippets/${this.snippet_id}/files/main/${urlslash(path2)}/raw`,
      { headers: this.header() }
    );
    const content = res.data;
    for (let file of this.files) {
      if (file.file_path == path2 || file.previous_path == path2)
        file.content = content;
    }
    return content;
  }
  async get_snippet() {
    if (!this.snippet_id)
      return;
    return await axios_default.get(
      `${this.options.api}/projects/${this.id()}/snippets/${this.snippet_id}/raw`,
      { headers: this.header() }
    );
  }
};

// src/storage.ts
var path = __toESM(require("path"));

// src/static.ts
var DEFAULT_SETTINGS = {
  token: "*****",
  username: "",
  repo_name: "",
  project_name: "",
  email: "",
  auto: false,
  fetch: false,
  branch: "master",
  notif: true
};
var INTERVAL_AFTER_CHANGES = 15;
var LOGGER_FILE = "logger.log";
var HISTORY_FILE = "history.log";
var POCKET_TOKEN_KEY = "gitlabtoken";
var HISTORY_VIEW = "history";
var GITLAB_API_URL = "https://gitlab.com/api/v4";
var PLUGIN_NAME = "obsidian-snowflake";

// src/storage.ts
var Pocket = class {
  constructor(settings) {
    this.prefix = "snowflake_obsidian";
    this.prefix = (settings == null ? void 0 : settings.prefix) || this.prefix;
  }
  get(key) {
    return localStorage.getItem(this.prefix + key);
  }
  set(key, value) {
    localStorage.setItem(this.prefix + key, `${value}`);
  }
  clear(key) {
    localStorage.removeItem(this.prefix + key);
  }
  clear_all() {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key == null ? void 0 : key.startsWith(this.prefix))
        localStorage.removeItem(key);
    }
  }
};
var FileMetaData = class {
  constructor(filename, config_dir = ".obsidian") {
    this.path = "";
    this.config_dir = ".obsidian";
    this.ext_path = () => `${this.config_dir}/plugins/${PLUGIN_NAME}`;
    this.lines_limit = 500;
    this.current_lines_pointer = 0;
    this.filename = filename;
    this.config_dir = config_dir;
    if (typeof process === "object")
      this.path = path.join(this.ext_path(), this.filename);
    else
      this.path = [this.ext_path(), this.filename].join("/");
  }
  set_main_path() {
    if (typeof process === "object")
      this.path = path.join(this.ext_path(), this.filename);
    else
      this.path = [this.ext_path(), this.filename].join("/");
  }
  set_limit(limit) {
    this.lines_limit = limit;
  }
  set_callback(callback) {
    this.callback = callback;
  }
  set_config_dir(config_dir) {
    this.config_dir = config_dir;
  }
  create() {
    try {
      app.vault.adapter.write(this.path, "");
    } catch (e) {
      console.log("Error: Write File");
    }
  }
  async set(value) {
    try {
      await app.vault.adapter.write(this.path, value);
    } catch (e) {
      console.log("Error: Write File Sync");
    }
  }
  async add(value) {
    try {
      await app.vault.adapter.append(this.path, value);
    } catch (e) {
      console.log("Error: Append File Sync");
    }
  }
  async get() {
    try {
      return await app.vault.adapter.read(this.path);
    } catch (err) {
      console.log("Error: Read File Sync - " + err.message);
      return "";
    }
  }
  /**
     *  returns `count` of lines from `start` value.
     * `start` could be also less then `0`, then `count` will be get by the end of the file
     * 
     * @param start 
     * @param count 
     * @returns 
  */
  async get_lines_by_index(start, count) {
    const file = await this.get();
    const lines = file.toString().split("\n");
    const len = lines.length;
    if (start > len)
      return [];
    if (!count)
      count = len;
    if (start < 0)
      start = len + start;
    if (start < 0)
      start = 0;
    if (start + count >= len)
      count = len;
    else
      count = start + count;
    this.current_lines_pointer = len;
    return lines.slice(start, count).filter((item) => !!item);
  }
  async get_lines_from_to_phrase(phrase, count = 1, contain_phrase = false, reverse = true) {
    const file = await this.get();
    const lines = file.toString().split("\n").reverse();
    const len = lines.length;
    const lines_to_return = [];
    for (let line of lines) {
      if (line.contains(phrase)) {
        if (contain_phrase)
          lines_to_return.push(line);
        count--;
      } else {
        lines_to_return.push(line);
      }
      if (count == 0)
        break;
    }
    this.current_lines_pointer = len;
    return lines_to_return.filter((item) => !!item);
  }
};
var Logger = class extends FileMetaData {
  constructor(filename, config_dir = ".obsidian") {
    super(filename, config_dir);
  }
  async check_limit() {
    if (this.current_lines_pointer > 0.9 * this.lines_limit) {
      const start = 0.1 * this.lines_limit;
      await this.set((await this.get_lines_by_index(-start)).join("\n"));
      this.current_lines_pointer = start;
    }
  }
  async log(message) {
    const date = new Date();
    const fullmessage = `
[${date.toLocaleString().replace(", ", "|")}]>	${message}`;
    await this.add(fullmessage);
    if (this.callback)
      this.callback(fullmessage);
    this.current_lines_pointer++;
    await this.check_limit();
  }
};
var History = class extends FileMetaData {
  constructor(filename, config_dir = ".obsidian") {
    super(filename, config_dir);
    this.lines_limit = 2e3;
    this.current_lines_pointer = 0;
  }
  async check_limit() {
    if (this.current_lines_pointer > 0.9 * this.lines_limit) {
      const start = 0.3 * this.lines_limit;
      await this.set((await this.get_lines_by_index(-start)).join("\n"));
      this.current_lines_pointer = start;
    }
  }
  parser(line) {
    const [time, action, path2, old_path] = line.split("	");
    return {
      time,
      action,
      path: path2,
      old_path
    };
  }
  async clear() {
    await this.set("");
    this.current_lines_pointer = 0;
  }
  async logs_include_repeats(_action, _path) {
    const last_changes = await this.get_lines_by_index(-200);
    for (const item of last_changes.reverse()) {
      const { action, path: path2 } = this.parser(item);
      if (action.startsWith("LOCAL CHANGES"))
        return false;
      if (action == "MODIFY" && _action == action && path2 == _path)
        return true;
    }
    return false;
  }
  async add_action(action, path2, old_path) {
    const date = new Date();
    if (await this.logs_include_repeats(action, path2))
      return;
    const fullmessage = `
[${date.toLocaleString()}]	${action}	${path2}	${old_path || "null"}`;
    await this.add(fullmessage);
    if (this.callback)
      this.callback(fullmessage);
    this.current_lines_pointer++;
    await this.check_limit();
  }
};

// src/async_queue.ts
var Queue = class {
  constructor() {
    this.actions = [];
  }
  append(action) {
    this.actions.push(action);
    if (this.actions.length == 1)
      this.action_handle();
  }
  async action_handle() {
    if (this.actions.length != 0) {
      const action = this.actions[0];
      if (action)
        await action();
      this.actions.shift();
      this.action_handle();
    }
  }
};

// src/settings.ts
var import_obsidian2 = require("obsidian");
var SnowflakeSettings = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const set = () => new import_obsidian2.Setting(containerEl);
    set().setName("Token").setDesc("Here is gitlab token").addText((text) => {
      var _a;
      return text.setPlaceholder("Enter your secret").setValue("*".repeat(((_a = pocket.get("gitlabtoken")) == null ? void 0 : _a.length) || 0)).onChange(async (value) => {
        pocket.set("gitlabtoken", value);
        await this.plugin.saveSettings();
      });
    });
    set().setName("Email").setDesc("Here is email - git commit").addText((text) => text.setPlaceholder("Enter your email").setValue(this.plugin.settings.email).onChange(async (value) => {
      this.plugin.settings.email = value;
      await this.plugin.saveSettings();
    }));
    set().setName("Username").setDesc("Here is gitlab username - git commit").addText((text) => text.setPlaceholder("Enter your username").setValue(this.plugin.settings.username).onChange(async (value) => {
      this.plugin.settings.username = value;
      await this.plugin.saveSettings();
    }));
    set().setName("Project").setDesc("Here is gitlab project name").addText((text) => text.setPlaceholder("Enter project name").setValue(this.plugin.settings.project_name).onChange(async (value) => {
      this.plugin.settings.project_name = value;
      await this.plugin.saveSettings();
    }));
    set().setName("Name").setDesc("Here is gitlab repository name").addText((text) => text.setPlaceholder("Enter repository name").setValue(this.plugin.settings.repo_name).onChange(async (value) => {
      this.plugin.settings.repo_name = value;
      await this.plugin.saveSettings();
    }));
    set().setName("Main branch").setDesc("Here is gitlab main branch name").addText((text) => text.setPlaceholder("Enter your branch name").setValue(this.plugin.settings.branch).onChange(async (value) => {
      this.plugin.settings.branch = value;
      await this.plugin.saveSettings();
    }));
    set().setName("Sync Auto").setDesc("Set on if you want to sync repository automatically").addToggle((cb) => cb.setValue(this.plugin.settings.auto).onChange(async (value) => {
      this.plugin.settings.auto = value;
      await this.plugin.saveSettings();
      new import_obsidian2.Notice(`Auto Mode: ${value ? "on" : "off"}`);
    }));
    set().setName("Fetch on start").setDesc("Set on if you want to sync repository on start").addToggle((cb) => cb.setValue(this.plugin.settings.fetch).onChange(async (value) => {
      this.plugin.settings.fetch = value;
      await this.plugin.saveSettings();
      new import_obsidian2.Notice(`Auto Fetch: ${value ? "on" : "off"}`);
    }));
    set().setName("Notifications").setDesc("Set on if you want notifications").addToggle((cb) => cb.setValue(this.plugin.settings.notif).onChange(async (value) => {
      this.plugin.settings.notif = value;
      await this.plugin.saveSettings();
      new import_obsidian2.Notice(`Notifications: ${value ? "on" : "off"}`);
    }));
    set().setName("Reload Settings").setDesc("Click to reload current settings").addButton((cb) => cb.setButtonText("Reload").setIcon("refresh-cw").onClick(() => {
      this.plugin.loadSettings();
      new import_obsidian2.Notice("Settings updated");
    }));
  }
};

// views/history_view.ts
var import_obsidian3 = require("obsidian");
var HistoryLeaf = class extends import_obsidian3.ItemView {
  constructor(leaf) {
    super(leaf);
    this.icon = "scroll";
  }
  getViewType() {
    return HISTORY_VIEW;
  }
  getDisplayText() {
    return "Snowflake History";
  }
  async reload_logs(element, type) {
    const logs = await type.get_lines_by_index(-300);
    element.empty();
    logs.reverse().forEach((item) => {
      element.createEl("code", {
        text: item.replace(/\t/gm, " | ")
      });
    });
  }
  create_button(parent, name, callback) {
    const button = parent.createEl("button", {
      text: name
    });
    button.style.margin = "10px";
    button.addEventListener("click", () => {
      callback();
    });
  }
  async render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("h2", { text: "Snowflake History" });
    container.createEl("h3", { text: "Snowflake Local Changes" });
    this.local_logs = container.createEl("div");
    container.createEl("h3", { text: "Snowflake Sync Logs" });
    this.sync_logs = container.createEl("div");
    [this.local_logs, this.sync_logs].forEach((item) => {
      item.style.fontSize = "10px";
      item.style.whiteSpace = "nowrap";
      item.style.maxHeight = "500px";
      item.style.overflowY = "auto";
      item.style.display = "flex";
      item.style.flexDirection = "column-reverse";
    });
  }
  async update() {
    await this.reload_logs(this.local_logs, local_changes_logs);
    await this.reload_logs(this.sync_logs, sync_logs);
  }
  async onOpen() {
    await this.render();
    await this.reload_logs(this.local_logs, local_changes_logs);
    await this.reload_logs(this.sync_logs, sync_logs);
  }
};

// views/views.ts
var activate_history_view = async () => {
  const { workspace } = app;
  let leaf = null;
  const leaves = workspace.getLeavesOfType(HISTORY_VIEW);
  if (leaves.length > 0) {
    leaf = leaves[0];
  } else {
    leaf = workspace.getRightLeaf(false);
    await leaf.setViewState({ type: HISTORY_VIEW, active: false });
  }
  sync_logs.set_callback(() => {
    if (leaf)
      leaf.view.update();
  });
  local_changes_logs.set_callback(() => {
    if (leaf)
      leaf.view.update();
  });
};

// src/commands/show_panels.ts
var logs_panel = {
  id: "open_logs_panel",
  name: "Open Snowflake Logs",
  callback: async () => {
    activate_history_view();
  }
};

// src/modal/selection.ts
var import_obsidian4 = require("obsidian");
var CommandSelection = class extends import_obsidian4.SuggestModal {
  constructor(config) {
    super(app);
    this.config = { ...config };
    this.setPlaceholder(this.config.placeholder || "");
  }
  open() {
    super.open();
    if (this.config.initialValue != void 0) {
      this.inputEl.value = this.config.initialValue;
      this.inputEl.dispatchEvent(new Event("input"));
    }
    return new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  selectSuggestion(value, evt) {
    if (this.resolve) {
      let res;
      if (this.config.allowEmpty && value === " ")
        res = "";
      else if (value === "...")
        res = void 0;
      else
        res = value;
      this.resolve(res);
    }
    super.selectSuggestion(value, evt);
  }
  onClose() {
    if (this.resolve)
      this.resolve(void 0);
  }
  getSuggestions(query) {
    if (this.config.onlySelection) {
      return this.config.options || [];
    } else if (this.config.allowEmpty) {
      return [query.length > 0 ? query : " ", ...this.config.options || []];
    } else {
      return [query.length > 0 ? query : "...", ...this.config.options || []];
    }
  }
  renderSuggestion(value, el) {
    el.setText(value);
  }
  onChooseSuggestion(item, evt) {
  }
};

// src/commands/repository_controller.ts
var import_obsidian5 = require("obsidian");

// src/utils.ts
var base64ToArrayBuffer2 = (base64) => {
  var binaryString = atob(base64);
  var bytes = new Uint8Array(binaryString.length);
  for (var i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
};
var callback_time_buffer = (handler = null) => ({
  run_task_interval: (callback, timeout) => {
    const new_task_interval = setTimeout(callback, timeout);
    return callback_time_buffer(new_task_interval);
  },
  break_interval_and_push_task: (callback, timeout) => {
    if (handler)
      clearInterval(handler);
    return callback_time_buffer().run_task_interval(callback, timeout);
  }
});

// src/commands/repository_controller.ts
var command__send_all = async () => {
  const nc = new import_obsidian5.Notice("Sending...", 0);
  const status = [0, 0];
  const read_folder = async (dir) => {
    if (dir.contains(".git") || dir.contains("node_modules"))
      return;
    const content = await app.vault.adapter.list(dir);
    for (const path2 of content.files) {
      nc.setMessage(path2);
      status[0] += 1;
      await gitlab.create(path2, {}, false);
    }
    for (const path2 of content.folders) {
      nc.setMessage(path2);
      status[1] += 1;
      await read_folder(path2);
    }
  };
  await read_folder("/");
  await gitlab.save_last_commit();
  nc.setMessage(`Done for ${status[0]} files in ${status[1]} folders`);
  setTimeout(() => nc.hide(), 1e3 * 5);
};
var command__send_changes = async () => {
  const logged_local_changes_from_file = await local_changes_logs.get_lines_from_to_phrase("LOCAL CHANGES");
  const files_states = /* @__PURE__ */ new Map();
  let logged_local_changes_parsed = [];
  logged_local_changes_from_file.reverse().forEach(
    (item) => {
      const parsed_object = local_changes_logs.parser(item);
      if (!!parsed_object.old_path)
        files_states.delete(parsed_object.old_path);
      if (files_states.has(parsed_object.path) && parsed_object.action == "DELETE")
        files_states.delete(parsed_object.path);
      if (files_states.has(parsed_object.path) && parsed_object.action == "MODIFY") {
        files_states.set(parsed_object.path, { ...parsed_object, action: "CREATE" });
        return;
      }
      files_states.set(parsed_object.path, parsed_object);
      logged_local_changes_parsed = Array.from(files_states.entries());
    }
  );
  logged_local_changes_parsed.forEach((item) => {
    const parsed = item[1];
    if (parsed.action == "CREATE")
      req_queue.append(async () => {
        try {
          await gitlab.create(
            parsed.path,
            { commit_message: `creating file "${parsed.path}" - ${parsed.time}` },
            false
          );
          sync_logs.log(`creating file "${parsed.path}"`);
        } catch (e) {
          sync_logs.log(`FAIL: creating file "${parsed.path}"`);
        }
      });
    if (parsed.action == "MODIFY")
      req_queue.append(async () => {
        try {
          await gitlab.modify(
            parsed.path,
            { commit_message: `modifying file "${parsed.path}" - ${parsed.time}` },
            false
          );
          sync_logs.log(`modifying file "${parsed.path}"`);
        } catch (e) {
          sync_logs.log(`FAIL: modifying file "${parsed.path}"`);
        }
      });
    if (parsed.action == "DELETE")
      req_queue.append(async () => {
        try {
          await gitlab.delete(
            parsed.path,
            { commit_message: `deleting file "${parsed.path}" - ${parsed.time}` },
            false
          );
          sync_logs.log(`deleting file "${parsed.path}"`);
        } catch (e) {
          sync_logs.log(`FAIL: deleting file "${parsed.path}"`);
        }
      });
    if (parsed.action == "RENAME")
      req_queue.append(async () => {
        try {
          await gitlab.create(
            parsed.path,
            { commit_message: `renaming[c] file "${parsed.old_path}" -> "${parsed.path}" - ${parsed.time}` },
            false
          );
          await gitlab.delete(
            parsed.old_path,
            { commit_message: `renaming[d] file "${parsed.old_path}" -> "${parsed.path}" - ${parsed.time}` },
            false
          );
          sync_logs.log(`renaming file "${parsed.old_path}" -> "${parsed.path}"`);
        } catch (e) {
          sync_logs.log(`FAIL: renaming file "${parsed.old_path}" -> "${parsed.path}"`);
        }
      });
  });
  await gitlab.save_last_commit();
  local_changes_logs.add_action("LOCAL CHANGES PUSHED", `${logged_local_changes_parsed.length} changes`);
  local_changes_logs.callback();
};
var command__get_all_repo = async () => {
  const include_config = await new CommandSelection({
    placeholder: "Includes .obsidian?",
    options: ["YES", "NO"]
  }).open();
  const choose_pathtree = async (start_path = "") => {
    const tree2 = await gitlab.read_repo_tree(start_path, 0, 0, false);
    const folders = tree2.filter((item) => item[2]).map((item) => item[1]);
    if (folders.length == 0)
      return start_path;
    const repo_path = await new CommandSelection({
      placeholder: "Repo dir path - leave empty for whole repo or .. to back",
      options: folders
    }).open();
    if (!repo_path)
      return start_path;
    if (repo_path == "..")
      return choose_pathtree("");
    return choose_pathtree(repo_path);
  };
  const path2 = await choose_pathtree("");
  const tree = await gitlab.read_repo_tree(path2);
  tree.forEach((item) => {
    if (item[2])
      app.vault.adapter.mkdir(item[1]);
  });
  const file_status = new import_obsidian5.Notice("File: ", 0);
  for (const file of tree) {
    if (include_config == "YES" && file[1].startsWith(".obsidian"))
      continue;
    if (file[2])
      continue;
    const res = await gitlab.read(file[1]);
    if (res == null)
      continue;
    file_status.setMessage("File: " + file[1]);
    app.vault.adapter.writeBinary(file[1], base64ToArrayBuffer2(res.data.content));
  }
  await gitlab.save_last_commit();
  file_status.hide();
  new import_obsidian5.Notice("Done");
};
var command__fetch_changes = async () => {
  const nc = new import_obsidian5.Notice("Fetching...", 0);
  const res = await gitlab.get_commits();
  const last_commit = res[res.length - 1];
  if (!last_commit)
    return await gitlab.save_last_commit();
  if (last_commit.id == pocket.get("last_commit_id"))
    return nc.setMessage("Everything is up to date");
  let content_remote_changes = 0;
  req_queue.append(async () => {
    for (const commit of res) {
      const res2 = await gitlab.get_diffs(commit.id);
      res2 == null ? void 0 : res2.data.forEach(async (item) => {
        content_remote_changes++;
        req_queue.append(async () => {
          try {
            if (item.new_file || !item.renamed_file && !item.new_file && !item.deleted_file)
              await gitlab.save_local_file(item.new_path);
            if (item.renamed_file)
              await app.vault.adapter.rename(item.old_path, item.new_path);
            if (item.deleted_file)
              await app.vault.adapter.remove(item.new_path);
          } catch (e) {
            console.log("fetching errors");
          }
        });
      });
    }
  });
  await gitlab.save_last_commit();
  req_queue.append(() => local_changes_logs.add_action("LOCAL CHANGES PULLED", `${content_remote_changes} changes`));
  nc.setMessage("Everything is up to date\nLast commit: " + pocket.get("last_commit_id"));
};
var get_all_repository = {
  id: "get_all_repository",
  name: "Download all repository",
  callback: async () => {
    command__get_all_repo();
  }
};
var fetch_changes = {
  id: "fetch_changes",
  name: "Fetch remote changes",
  callback: async () => {
    command__fetch_changes();
  }
};
var send_all_gitlab = {
  id: "send_all_gitlab",
  name: "Send all local files",
  callback: async () => {
    command__send_all();
  }
};
var send_changes_gitlab = {
  id: "send_changes_gitlab",
  name: "Send local changes",
  callback: async () => {
    command__send_changes();
  }
};

// src/commands/barrel.ts
var commands = [
  logs_panel,
  get_all_repository,
  send_all_gitlab,
  send_changes_gitlab,
  fetch_changes
];
var barrel_default = commands;

// src/context_menu/file-menu.ts
var import_obsidian6 = require("obsidian");
var file_menu_send_file = (menu, file) => {
  menu.addItem((item) => {
    item.setTitle("Gitlab: Send File").setIcon("send").onClick(async () => {
      const nc = new import_obsidian6.Notice("Sending...", 0);
      req_queue.append(async () => {
        if (file.children) {
          const read_folder = async (dir) => {
            const content = await app.vault.adapter.list(dir);
            for (const path2 of content.files) {
              nc.setMessage(path2);
              await gitlab.create(path2);
            }
            for (const path2 of content.folders) {
              nc.setMessage(path2);
              await read_folder(path2);
            }
          };
          await read_folder(file.path);
        } else {
          await gitlab.create(file.path);
        }
        nc.setMessage("Done");
      });
      setTimeout(() => nc.hide(), 1e3 * 5);
    });
  });
};
var file_menu_load_file = (menu, file) => {
  menu.addItem((item) => {
    item.setTitle("Gitlab: Load File").setIcon("file-down").onClick(async () => {
      const nc = new import_obsidian6.Notice("Loading...", 0);
      req_queue.append(async () => {
        if (file.children) {
          const tree = await gitlab.read_repo_tree(file.path);
          tree.forEach((item2) => {
            if (item2[2])
              app.vault.adapter.mkdir(item2[1]);
          });
          for (const file2 of tree) {
            if (file2[2])
              continue;
            const res = await gitlab.read(file2[1]);
            if (res == null)
              continue;
            app.vault.adapter.writeBinary(file2[1], base64ToArrayBuffer2(res.data.content));
          }
        } else {
          const res = await gitlab.read(file.path);
          if (res == null)
            return;
          app.vault.adapter.writeBinary(file.path, base64ToArrayBuffer2(res.data.content));
        }
        nc.setMessage("Done");
      });
      setTimeout(() => nc.hide(), 1e3 * 7);
    });
  });
};
var file_menu_delete_file = (menu, file) => {
  menu.addItem((item) => {
    item.setTitle("Gitlab: Delete File").setIcon("trash-2").onClick(async () => {
      const nc = new import_obsidian6.Notice("Deleting...", 0);
      req_queue.append(async () => {
        if (file.children) {
          const read_folder = async (dir) => {
            const content = await app.vault.adapter.list(dir);
            for (const path2 of content.files) {
              nc.setMessage(path2);
              await gitlab.delete(path2);
            }
            for (const path2 of content.folders) {
              nc.setMessage(path2);
              await read_folder(path2);
            }
          };
          await read_folder(file.path);
        } else {
          await gitlab.delete(file.path);
        }
        nc.setMessage("Done");
      });
      setTimeout(() => nc.hide(), 1e3 * 5);
    });
  });
};

// main.ts
var gitlab = new GitLabAPI();
var pocket = new Pocket();
var req_queue = new Queue();
var sync_logs = new Logger(LOGGER_FILE);
var local_changes_logs = new History(HISTORY_FILE);
var SyncSnowflake2 = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.gitlab_settings = () => {
      return {
        api: GITLAB_API_URL,
        token: pocket.get(POCKET_TOKEN_KEY) || "",
        project: this.settings.project_name,
        repository: this.settings.repo_name,
        email: this.settings.email,
        nick: this.settings.username,
        branch: this.settings.branch,
        notifications: this.settings.notif
      };
    };
  }
  async onload() {
    sync_logs.set_config_dir(this.app.vault.configDir);
    local_changes_logs.set_config_dir(this.app.vault.configDir);
    await this.loadSettings();
    const status_bar = this.addStatusBarItem();
    this.registerView(
      HISTORY_VIEW,
      (leaf) => new HistoryLeaf(leaf)
    );
    for (const command of barrel_default) {
      this.addCommand(command);
    }
    this.addRibbonIcon("send", "Send local changes", async (evt) => {
      command__send_changes();
    }).addClass("my-plugin-ribbon-class");
    this.addRibbonIcon("download-cloud", "Fetch", async (evt) => {
      command__fetch_changes();
    }).addClass("my-plugin-ribbon-class");
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        file_menu_send_file(menu, file);
        file_menu_load_file(menu, file);
        file_menu_delete_file(menu, file);
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-open", async (file) => {
        if (!this.settings.auto)
          return;
        if (!(file == null ? void 0 : file.path))
          return;
        req_queue.append(async () => {
          status_bar.setText("Syncing...");
          await gitlab.save_local_file(file.path, file.path, true);
          status_bar.setText("Sync done");
        });
      })
    );
    let callback_buffer = callback_time_buffer();
    setTimeout(() => {
      this.registerEvent(
        this.app.vault.on("create", async (file) => {
          await local_changes_logs.add_action("CREATE", file.path);
          if (this.settings.auto)
            callback_buffer = callback_buffer.break_interval_and_push_task(
              command__send_changes,
              INTERVAL_AFTER_CHANGES * 1e3
            );
        })
      );
      this.registerEvent(
        this.app.vault.on("modify", async (file) => {
          await local_changes_logs.add_action("MODIFY", file.path);
          if (this.settings.auto)
            callback_buffer = callback_buffer.break_interval_and_push_task(
              command__send_changes,
              INTERVAL_AFTER_CHANGES * 1e3
            );
        })
      );
      this.registerEvent(
        this.app.vault.on("delete", async (file) => {
          await local_changes_logs.add_action("DELETE", file.path);
          if (this.settings.auto)
            callback_buffer = callback_buffer.break_interval_and_push_task(
              command__send_changes,
              INTERVAL_AFTER_CHANGES * 1e3
            );
        })
      );
      this.registerEvent(
        this.app.vault.on("rename", async (file, old_path) => {
          await local_changes_logs.add_action("RENAME", file.path, old_path);
          this.app.vault.adapter.files[file.name].rtime = Date.now();
          this.app.vault.adapter.files[file.name].old_path = old_path;
          if (this.settings.auto)
            callback_buffer = callback_buffer.break_interval_and_push_task(
              command__send_changes,
              INTERVAL_AFTER_CHANGES * 1e3
            );
        })
      );
    }, 1e3 * 3);
    setTimeout(() => {
      activate_history_view();
      if (this.settings.fetch)
        command__fetch_changes();
    }, 1e3);
    this.addSettingTab(new SnowflakeSettings(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    pocket.prefix = `snowflake_obsidian_${this.settings.project_name + this.settings.repo_name}`;
    const git_lab_options = this.gitlab_settings();
    gitlab.setoptions(git_lab_options);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    pocket.prefix = `snowflake_obsidian_${this.settings.project_name + this.settings.repo_name}`;
    const git_lab_options = this.gitlab_settings();
    gitlab.setoptions(git_lab_options);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvZ2l0bGFiX2FwaS50cyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvc0Vycm9yLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9udWxsLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy90b0Zvcm1EYXRhLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvY2xhc3Nlcy9VUkxTZWFyY2hQYXJhbXMuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9icm93c2VyL2NsYXNzZXMvRm9ybURhdGEuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9icm93c2VyL2NsYXNzZXMvQmxvYi5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9jb21tb24vdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdG9VUkxFbmNvZGVkRm9ybS5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvc0hlYWRlcnMuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZVByb3RvY29sLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcGVlZG9tZXRlci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvZW52L2RhdGEuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9IdHRwU3RhdHVzQ29kZS5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsICJzcmMvc3RvcmFnZS50cyIsICJzcmMvc3RhdGljLnRzIiwgInNyYy9hc3luY19xdWV1ZS50cyIsICJzcmMvc2V0dGluZ3MudHMiLCAidmlld3MvaGlzdG9yeV92aWV3LnRzIiwgInZpZXdzL3ZpZXdzLnRzIiwgInNyYy9jb21tYW5kcy9zaG93X3BhbmVscy50cyIsICJzcmMvbW9kYWwvc2VsZWN0aW9uLnRzIiwgInNyYy9jb21tYW5kcy9yZXBvc2l0b3J5X2NvbnRyb2xsZXIudHMiLCAic3JjL3V0aWxzLnRzIiwgInNyYy9jb21tYW5kcy9iYXJyZWwudHMiLCAic3JjL2NvbnRleHRfbWVudS9maWxlLW1lbnUudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IE5vdGljZSwgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nXG5pbXBvcnQgeyBHaXRMYWJBUEksIEdpdExhYk9wdGlvbnMgfSBmcm9tICdzcmMvZ2l0bGFiX2FwaSdcbmltcG9ydCB7IEhpc3RvcnksIExvZ2dlciwgUG9ja2V0IH0gZnJvbSAnc3JjL3N0b3JhZ2UnXG5pbXBvcnQgeyBRdWV1ZSB9IGZyb20gJ3NyYy9hc3luY19xdWV1ZSdcbmltcG9ydCB7IFNldHRpbmdzVmlld3BvaW50IH0gZnJvbSAnZCdcbmltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MsIEdJVExBQl9BUElfVVJMLCBISVNUT1JZX0ZJTEUsIEhJU1RPUllfVklFVywgSU5URVJWQUxfQUZURVJfQ0hBTkdFUywgTE9HR0VSX0ZJTEUsIFBPQ0tFVF9UT0tFTl9LRVkgfSBmcm9tICdzcmMvc3RhdGljJ1xuaW1wb3J0IHsgU25vd2ZsYWtlU2V0dGluZ3MgfSBmcm9tICdzcmMvc2V0dGluZ3MnXG5cbmltcG9ydCB7IEhpc3RvcnlMZWFmIH0gZnJvbSAndmlld3MvaGlzdG9yeV92aWV3J1xuaW1wb3J0IGNvbW1hbmRzIGZyb20gJ3NyYy9jb21tYW5kcy9iYXJyZWwnXG5pbXBvcnQgeyBhY3RpdmF0ZV9oaXN0b3J5X3ZpZXcgfSBmcm9tICd2aWV3cy92aWV3cydcbmltcG9ydCB7IGZpbGVfbWVudV9kZWxldGVfZmlsZSwgZmlsZV9tZW51X2xvYWRfZmlsZSwgZmlsZV9tZW51X3NlbmRfZmlsZSB9IGZyb20gJ3NyYy9jb250ZXh0X21lbnUvZmlsZS1tZW51J1xuaW1wb3J0IHsgY29tbWFuZF9fZmV0Y2hfY2hhbmdlcywgY29tbWFuZF9fc2VuZF9jaGFuZ2VzLCBzZW5kX2NoYW5nZXNfZ2l0bGFiIH0gZnJvbSAnc3JjL2NvbW1hbmRzL3JlcG9zaXRvcnlfY29udHJvbGxlcidcbmltcG9ydCB7IGNhbGxiYWNrX3RpbWVfYnVmZmVyIH0gZnJvbSAnc3JjL3V0aWxzJ1xuXG5cbmV4cG9ydCBjb25zdCBnaXRsYWIgPSBuZXcgR2l0TGFiQVBJKClcbmV4cG9ydCBjb25zdCBwb2NrZXQgPSBuZXcgUG9ja2V0KClcbmV4cG9ydCBjb25zdCByZXFfcXVldWUgPSBuZXcgUXVldWUoKVxuXG5leHBvcnQgY29uc3Qgc3luY19sb2dzID0gbmV3IExvZ2dlcihMT0dHRVJfRklMRSlcbmV4cG9ydCBjb25zdCBsb2NhbF9jaGFuZ2VzX2xvZ3MgPSBuZXcgSGlzdG9yeShISVNUT1JZX0ZJTEUpXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5bmNTbm93Zmxha2UgZXh0ZW5kcyBQbHVnaW4ge1xuXHRzZXR0aW5nczogU2V0dGluZ3NWaWV3cG9pbnRcblx0Z2l0bGFiX3NldHRpbmdzID0gKCk6IEdpdExhYk9wdGlvbnMgPT4ge1xuXHRcdHJldHVybiB7XG5cdFx0XHRhcGk6IEdJVExBQl9BUElfVVJMLFxuXHRcdFx0dG9rZW46IHBvY2tldC5nZXQoUE9DS0VUX1RPS0VOX0tFWSkgfHwgJycsXG5cdFx0XHRwcm9qZWN0OiB0aGlzLnNldHRpbmdzLnByb2plY3RfbmFtZSxcblx0XHRcdHJlcG9zaXRvcnk6IHRoaXMuc2V0dGluZ3MucmVwb19uYW1lLFxuXHRcdFx0ZW1haWw6IHRoaXMuc2V0dGluZ3MuZW1haWwsXG5cdFx0XHRuaWNrOiB0aGlzLnNldHRpbmdzLnVzZXJuYW1lLFxuXHRcdFx0YnJhbmNoOiB0aGlzLnNldHRpbmdzLmJyYW5jaCxcblx0XHRcdG5vdGlmaWNhdGlvbnM6IHRoaXMuc2V0dGluZ3Mubm90aWZcblx0XHR9XG5cdH1cblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cdFx0c3luY19sb2dzLnNldF9jb25maWdfZGlyKHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0Rpcilcblx0XHRsb2NhbF9jaGFuZ2VzX2xvZ3Muc2V0X2NvbmZpZ19kaXIodGhpcy5hcHAudmF1bHQuY29uZmlnRGlyKVxuXG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKVxuXHRcdGNvbnN0IHN0YXR1c19iYXIgPSB0aGlzLmFkZFN0YXR1c0Jhckl0ZW0oKVxuXG5cdFx0dGhpcy5yZWdpc3RlclZpZXcoXG5cdFx0XHRISVNUT1JZX1ZJRVcsXG5cdFx0XHQobGVhZikgPT4gbmV3IEhpc3RvcnlMZWFmKGxlYWYpXG5cdFx0KVxuXG5cdFx0Zm9yIChjb25zdCBjb21tYW5kIG9mIGNvbW1hbmRzKSB7XG5cdFx0XHR0aGlzLmFkZENvbW1hbmQoY29tbWFuZClcblx0XHR9XG5cblx0XHR0aGlzLmFkZFJpYmJvbkljb24oJ3NlbmQnLCAnU2VuZCBsb2NhbCBjaGFuZ2VzJywgYXN5bmMgKGV2dDogTW91c2VFdmVudCkgPT4ge1xuXHRcdFx0Y29tbWFuZF9fc2VuZF9jaGFuZ2VzKClcblx0XHR9KS5hZGRDbGFzcygnbXktcGx1Z2luLXJpYmJvbi1jbGFzcycpXG5cblx0XHR0aGlzLmFkZFJpYmJvbkljb24oJ2Rvd25sb2FkLWNsb3VkJywgJ0ZldGNoJywgYXN5bmMgKGV2dDogTW91c2VFdmVudCkgPT4ge1xuXHRcdFx0Y29tbWFuZF9fZmV0Y2hfY2hhbmdlcygpXG5cdFx0fSkuYWRkQ2xhc3MoJ215LXBsdWdpbi1yaWJib24tY2xhc3MnKVxuXG5cblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQoXG5cdFx0XHR0aGlzLmFwcC53b3Jrc3BhY2Uub24oXCJmaWxlLW1lbnVcIiwgKG1lbnUsIGZpbGUpID0+IHtcblx0XHRcdFx0ZmlsZV9tZW51X3NlbmRfZmlsZShtZW51LCBmaWxlKVxuXHRcdFx0XHRmaWxlX21lbnVfbG9hZF9maWxlKG1lbnUsIGZpbGUpXG5cdFx0XHRcdGZpbGVfbWVudV9kZWxldGVfZmlsZShtZW51LCBmaWxlKVxuXHRcdFx0fSlcblx0XHQpXG5cblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQoXG5cdFx0XHR0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2ZpbGUtb3BlbicsIGFzeW5jIChmaWxlKSA9PiB7XG5cdFx0XHRcdGlmICghdGhpcy5zZXR0aW5ncy5hdXRvKSByZXR1cm5cblx0XHRcdFx0aWYgKCFmaWxlPy5wYXRoKSByZXR1cm5cblx0XHRcdFx0cmVxX3F1ZXVlLmFwcGVuZChhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0c3RhdHVzX2Jhci5zZXRUZXh0KCdTeW5jaW5nLi4uJylcblx0XHRcdFx0XHRhd2FpdCBnaXRsYWIuc2F2ZV9sb2NhbF9maWxlKGZpbGUucGF0aCwgZmlsZS5wYXRoLCB0cnVlKVxuXHRcdFx0XHRcdHN0YXR1c19iYXIuc2V0VGV4dCgnU3luYyBkb25lJylcblx0XHRcdFx0fSlcblx0XHRcdH0pXG5cdFx0KVxuXG5cdFx0bGV0IGNhbGxiYWNrX2J1ZmZlciA9IGNhbGxiYWNrX3RpbWVfYnVmZmVyKClcblxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0XHR0aGlzLmFwcC52YXVsdC5vbignY3JlYXRlJywgYXN5bmMgKGZpbGUpID0+IHtcblx0XHRcdFx0XHRhd2FpdCBsb2NhbF9jaGFuZ2VzX2xvZ3MuYWRkX2FjdGlvbignQ1JFQVRFJywgZmlsZS5wYXRoKVxuXHRcdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmF1dG8pXG5cdFx0XHRcdFx0XHRjYWxsYmFja19idWZmZXIgPSBjYWxsYmFja19idWZmZXIuYnJlYWtfaW50ZXJ2YWxfYW5kX3B1c2hfdGFzayhcblx0XHRcdFx0XHRcdFx0Y29tbWFuZF9fc2VuZF9jaGFuZ2VzLFxuXHRcdFx0XHRcdFx0XHRJTlRFUlZBTF9BRlRFUl9DSEFOR0VTICogMTAwMFxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHR9KVxuXHRcdFx0KVxuXHRcdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0XHR0aGlzLmFwcC52YXVsdC5vbignbW9kaWZ5JywgYXN5bmMgKGZpbGUpID0+IHtcblx0XHRcdFx0XHRhd2FpdCBsb2NhbF9jaGFuZ2VzX2xvZ3MuYWRkX2FjdGlvbignTU9ESUZZJywgZmlsZS5wYXRoKVxuXHRcdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmF1dG8pXG5cdFx0XHRcdFx0XHRjYWxsYmFja19idWZmZXIgPSBjYWxsYmFja19idWZmZXIuYnJlYWtfaW50ZXJ2YWxfYW5kX3B1c2hfdGFzayhcblx0XHRcdFx0XHRcdFx0Y29tbWFuZF9fc2VuZF9jaGFuZ2VzLFxuXHRcdFx0XHRcdFx0XHRJTlRFUlZBTF9BRlRFUl9DSEFOR0VTICogMTAwMFxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHR9KVxuXHRcdFx0KVxuXHRcdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0XHR0aGlzLmFwcC52YXVsdC5vbignZGVsZXRlJywgYXN5bmMgKGZpbGUpID0+IHtcblx0XHRcdFx0XHRhd2FpdCBsb2NhbF9jaGFuZ2VzX2xvZ3MuYWRkX2FjdGlvbignREVMRVRFJywgZmlsZS5wYXRoKVxuXHRcdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmF1dG8pXG5cdFx0XHRcdFx0XHRjYWxsYmFja19idWZmZXIgPSBjYWxsYmFja19idWZmZXIuYnJlYWtfaW50ZXJ2YWxfYW5kX3B1c2hfdGFzayhcblx0XHRcdFx0XHRcdFx0Y29tbWFuZF9fc2VuZF9jaGFuZ2VzLFxuXHRcdFx0XHRcdFx0XHRJTlRFUlZBTF9BRlRFUl9DSEFOR0VTICogMTAwMFxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHR9KVxuXHRcdFx0KVxuXHRcdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0XHR0aGlzLmFwcC52YXVsdC5vbigncmVuYW1lJywgYXN5bmMgKGZpbGUsIG9sZF9wYXRoKSA9PiB7XG5cdFx0XHRcdFx0YXdhaXQgbG9jYWxfY2hhbmdlc19sb2dzLmFkZF9hY3Rpb24oJ1JFTkFNRScsIGZpbGUucGF0aCwgb2xkX3BhdGgpXG5cdFx0XHRcdFx0dGhpcy5hcHAudmF1bHQuYWRhcHRlci5maWxlc1tmaWxlLm5hbWVdLnJ0aW1lID0gRGF0ZS5ub3coKVxuXHRcdFx0XHRcdHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZmlsZXNbZmlsZS5uYW1lXS5vbGRfcGF0aCA9IG9sZF9wYXRoXG5cdFx0XHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuYXV0bylcblx0XHRcdFx0XHRcdGNhbGxiYWNrX2J1ZmZlciA9IGNhbGxiYWNrX2J1ZmZlci5icmVha19pbnRlcnZhbF9hbmRfcHVzaF90YXNrKFxuXHRcdFx0XHRcdFx0XHRjb21tYW5kX19zZW5kX2NoYW5nZXMsXG5cdFx0XHRcdFx0XHRcdElOVEVSVkFMX0FGVEVSX0NIQU5HRVMgKiAxMDAwXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdH0pXG5cdFx0XHQpXG5cdFx0fSwgMTAwMCAqIDMpXG5cblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdGFjdGl2YXRlX2hpc3RvcnlfdmlldygpXG5cblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmZldGNoKVxuXHRcdFx0XHRjb21tYW5kX19mZXRjaF9jaGFuZ2VzKClcblx0XHR9LCAxMDAwKVxuXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTbm93Zmxha2VTZXR0aW5ncyh0aGlzLmFwcCwgdGhpcykpXG5cdH1cblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpXG5cdFx0cG9ja2V0LnByZWZpeCA9IGBzbm93Zmxha2Vfb2JzaWRpYW5fJHt0aGlzLnNldHRpbmdzLnByb2plY3RfbmFtZSArIHRoaXMuc2V0dGluZ3MucmVwb19uYW1lfWBcblx0XHRjb25zdCBnaXRfbGFiX29wdGlvbnMgPSB0aGlzLmdpdGxhYl9zZXR0aW5ncygpXG5cdFx0Z2l0bGFiLnNldG9wdGlvbnMoZ2l0X2xhYl9vcHRpb25zKVxuXHR9XG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpXG5cdFx0cG9ja2V0LnByZWZpeCA9IGBzbm93Zmxha2Vfb2JzaWRpYW5fJHt0aGlzLnNldHRpbmdzLnByb2plY3RfbmFtZSArIHRoaXMuc2V0dGluZ3MucmVwb19uYW1lfWBcblx0XHRjb25zdCBnaXRfbGFiX29wdGlvbnMgPSB0aGlzLmdpdGxhYl9zZXR0aW5ncygpXG5cdFx0Z2l0bGFiLnNldG9wdGlvbnMoZ2l0X2xhYl9vcHRpb25zKVxuXHR9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBOb3RpY2UsIFRGaWxlLCBhcnJheUJ1ZmZlclRvQmFzZTY0IH0gZnJvbSAnb2JzaWRpYW4nXHJcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcydcclxuaW1wb3J0IHsgcG9ja2V0LCBzeW5jX2xvZ3MgfSBmcm9tICdtYWluJ1xyXG5cclxuZXhwb3J0IHR5cGUgR2l0TGFiU25pcHBldEZpbGVBY3Rpb24gPSAnY3JlYXRlJyB8ICd1cGRhdGUnIHwgJ2RlbGV0ZScgfCAnbW92ZSdcclxuZXhwb3J0IHR5cGUgR2l0TGFiT3B0aW9ucyA9IHtcclxuICBhcGk6IHN0cmluZ1xyXG4gIHRva2VuOiBzdHJpbmcsXHJcbiAgcHJvamVjdDogc3RyaW5nLFxyXG4gIHJlcG9zaXRvcnk6IHN0cmluZyxcclxuICBlbWFpbDogc3RyaW5nLFxyXG4gIG5pY2s6IHN0cmluZyxcclxuICBicmFuY2g6IHN0cmluZyxcclxuICBub3RpZmljYXRpb25zOiBib29sZWFuXHJcbn1cclxuZXhwb3J0IHR5cGUgR2l0TGFiQ29tbWl0T3B0aW9ucyA9IHtcclxuICBicmFuY2g/OiBzdHJpbmcsXHJcbiAgZW5jb2Rpbmc/OiBzdHJpbmcsXHJcbiAgYXV0aG9yX2VtYWlsPzogc3RyaW5nLFxyXG4gIGF1dGhvcl9uYW1lPzogc3RyaW5nLFxyXG4gIGNvbW1pdF9tZXNzYWdlPzogc3RyaW5nXHJcbn1cclxuZXhwb3J0IHR5cGUgR2l0TGFiU25pcHBldEZpbGUgPSB7XHJcbiAgYWN0aW9uOiBHaXRMYWJTbmlwcGV0RmlsZUFjdGlvblxyXG4gIGZpbGVfcGF0aDogc3RyaW5nXHJcbiAgY29udGVudDogc3RyaW5nXHJcbiAgcHJldmlvdXNfcGF0aD86IHN0cmluZ1xyXG59XHJcbmV4cG9ydCB0eXBlIEdpdExhYlNuaXBwZXRGaWxlT3B0aW9uYWwgPSB7XHJcbiAgYWN0aW9uPzogR2l0TGFiU25pcHBldEZpbGVBY3Rpb25cclxuICBmaWxlX3BhdGg/OiBzdHJpbmdcclxuICBjb250ZW50Pzogc3RyaW5nXHJcbiAgcHJldmlvdXNfcGF0aD86IHN0cmluZ1xyXG59XHJcbmV4cG9ydCB0eXBlIEdpdExhYlNuaXBwZXREb2MgPSB7XHJcbiAgdGl0bGU6IHN0cmluZ1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcclxuICB2aXNpYmlsaXR5OiBzdHJpbmdcclxuICBmaWxlczogR2l0TGFiU25pcHBldEZpbGVbXVxyXG59XHJcbmV4cG9ydCB0eXBlIEdpdExhYlNuaXBwZXREb2NPcHRpb25hbCA9IHtcclxuICB0aXRsZT86IHN0cmluZ1xyXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nXHJcbiAgdmlzaWJpbGl0eT86IHN0cmluZ1xyXG4gIGZpbGVzPzogR2l0TGFiU25pcHBldEZpbGVbXVxyXG59XHJcblxyXG5leHBvcnQgdHlwZSBHaXRsYWJDb21taXQgPSB7XHJcbiAgaWQ6IHN0cmluZyxcclxuICBzaG9ydF9pZDogc3RyaW5nLFxyXG4gIGNyZWF0ZWRfYXQ6IERhdGUsXHJcbiAgcGFyZW50X2lkczogc3RyaW5nLFxyXG4gIHRpdGxlOiBzdHJpbmcsXHJcbiAgbWVzc2FnZTogc3RyaW5nLFxyXG4gIGF1dGhvcl9uYW1lOiBzdHJpbmcsXHJcbiAgYXV0aG9yX2VtYWlsOiBzdHJpbmcsXHJcbiAgYXV0aG9yZWRfZGF0ZTogRGF0ZSxcclxuICBjb21taXR0ZXJfbmFtZTogc3RyaW5nLFxyXG4gIGNvbW1pdHRlcl9lbWFpbDogc3RyaW5nLFxyXG4gIGNvbW1pdHRlZF9kYXRlOiBEYXRlLFxyXG4gIHRyYWlsZXJzOiBhbnksXHJcbiAgZXh0ZW5kZWRfdHJhaWxlcnM6IGFueSxcclxuICB3ZWJfdXJsOiBzdHJpbmcsXHJcbiAgc3RhdHM6IHtcclxuICAgIGFkZGl0aW9uczogbnVtYmVyLFxyXG4gICAgZGVsZXRpb25zOiBudW1iZXIsXHJcbiAgICB0b3RhbDogbnVtYmVyXHJcbiAgfSxcclxuICBzdGF0dXM6IGFueSxcclxuICBwcm9qZWN0X2lkOiBudW1iZXIsXHJcbiAgbGFzdF9waXBlbGluZTogYW55XHJcbn1cclxuXHJcbmNvbnN0IHVybHNsYXNoID0gKC4uLnRleHQ6IHN0cmluZ1tdKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBwYXRoID0gdGV4dC5qb2luKCcvJylcclxuICBjb25zdCBlbmQgPSBwYXRoLnNsaWNlKHBhdGgubGFzdEluZGV4T2YoJy8nKSlcclxuICBjb25zdCBzdGFydCA9IHBhdGguc2xpY2UoMCwgcGF0aC5sYXN0SW5kZXhPZignLycpKS5yZXBsYWNlKC9cXC4vZ20sICclMkUnKVxyXG4gIHJldHVybiAoc3RhcnQgKyBlbmQpLnJlcGxhY2UoL1xcLy9nbSwgJyUyRicpXHJcbn1cclxuZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihiYXNlNjQ6IHN0cmluZykge1xyXG4gIHZhciBiaW5hcnlTdHJpbmcgPSBhdG9iKGJhc2U2NCk7XHJcbiAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcclxuICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgfVxyXG4gIHJldHVybiBieXRlcy5idWZmZXI7XHJcbn1cclxuXHJcblxyXG5jb25zdCBleHVybCA9IChfdXJsOiBzdHJpbmcsIF9wYXJhbXNfbm86IG51bWJlciA9IDApID0+ICh7XHJcbiAgYmFzZTogKHVybDogc3RyaW5nKSA9PiBleHVybChfdXJsICsgdXJsLCBfcGFyYW1zX25vKSxcclxuICBhZGQ6IChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4gZXh1cmwoX3VybCArIChfcGFyYW1zX25vID09IDAgPyAnPycgOiAnJicpICsgYCR7a2V5fT0ke3ZhbHVlfWAsIF9wYXJhbXNfbm8gKyAxKSxcclxuICBwYXJhbXM6IChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4gZXh1cmwoX3VybC5yZXBsYWNlKGA6JHtrZXl9YCwgdmFsdWUpLCBfcGFyYW1zX25vKSxcclxuICB2YWx1ZTogX3VybFxyXG59KVxyXG5cclxudHlwZSBFeFVybCA9IFJldHVyblR5cGU8dHlwZW9mIGV4dXJsPlxyXG5cclxuZXhwb3J0IGNsYXNzIEdpdExhYkFQSSB7XHJcbiAgb3B0aW9uczogR2l0TGFiT3B0aW9uc1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gIH1cclxuICBzZXRvcHRpb25zKG9wdGlvbnM6IEdpdExhYk9wdGlvbnMpIHtcclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcclxuICB9XHJcbiAgaWQgPSAoKSA9PiB1cmxzbGFzaCh0aGlzLm9wdGlvbnMucHJvamVjdCwgdGhpcy5vcHRpb25zLnJlcG9zaXRvcnkpXHJcbiAgaGVhZGVyID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgJ1BSSVZBVEUtVE9LRU4nOiB0aGlzLm9wdGlvbnMudG9rZW4sXHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgIH1cclxuICB9XHJcbiAgdXJsID0ge1xyXG4gICAgY29tbWl0czogKCkgPT4gZXh1cmwoYCR7dGhpcy5vcHRpb25zLmFwaX0vcHJvamVjdHMvJHt0aGlzLmlkKCl9L3JlcG9zaXRvcnkvY29tbWl0c2ApLFxyXG4gICAgYnJhbmNoZXM6ICgpID0+IGV4dXJsKGAke3RoaXMub3B0aW9ucy5hcGl9L3Byb2plY3RzLyR7dGhpcy5pZCgpfS9yZXBvc2l0b3J5L2JyYW5jaGVzYCksXHJcbiAgICBmaWxlczogKCkgPT4gZXh1cmwoYCR7dGhpcy5vcHRpb25zLmFwaX0vcHJvamVjdHMvJHt0aGlzLmlkKCl9L3JlcG9zaXRvcnkvZmlsZXNgKVxyXG4gIH1cclxuICBhc3luYyBnZXRfbG9jYWxfZmlsZV9jb250ZW50KHBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICBjb25zdCBhcnJheV9idWZmZXIgPSBhd2FpdCBhcHAudmF1bHQuYWRhcHRlci5yZWFkQmluYXJ5KHBhdGgpXHJcbiAgICByZXR1cm4gYXJyYXlCdWZmZXJUb0Jhc2U2NChhcnJheV9idWZmZXIpXHJcbiAgfVxyXG4gIGFzeW5jIHNhdmVfbG9jYWxfZmlsZShyZW1vdGVfcGF0aDogc3RyaW5nLCBsb2NhbF9wYXRoPzogc3RyaW5nLCBjcmVhdGVfaWZfbm90X2V4aXN0OiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmICghbG9jYWxfcGF0aCkgbG9jYWxfcGF0aCA9IHJlbW90ZV9wYXRoXHJcbiAgICBjb25zdCByZW1vdGVfZmlsZSA9IGF3YWl0IHRoaXMucmVhZChyZW1vdGVfcGF0aClcclxuICAgIGlmICghcmVtb3RlX2ZpbGUpIHtcclxuICAgICAgaWYgKGNyZWF0ZV9pZl9ub3RfZXhpc3QpXHJcbiAgICAgICAgdGhpcy5jcmVhdGUocmVtb3RlX3BhdGgpXHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICAgIGFwcC52YXVsdC5hZGFwdGVyLndyaXRlQmluYXJ5KGxvY2FsX3BhdGgsIGJhc2U2NFRvQXJyYXlCdWZmZXIocmVtb3RlX2ZpbGUuZGF0YS5jb250ZW50KSlcclxuICB9XHJcbiAgYXN5bmMgZ2V0X2JyYW5jaGVzKCkge1xyXG4gICAgY29uc3QgdXJsID0gdGhpcy51cmwuYnJhbmNoZXMoKVxyXG4gICAgICAuYWRkKCdwdCcsICdudWxsJylcclxuXHJcbiAgICBjb25zdCByZXM6IGFueVtdID0gW11cclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucGFnaW5hdGlvbigxLCB1cmwsIGFzeW5jIChyZXNfaXRlbSkgPT4ge1xyXG4gICAgICAgIHJlcy5wdXNoKC4uLnJlc19pdGVtLmRhdGEubWFwKChpdGVtOiBhbnkpID0+IGl0ZW0ubmFtZSkpXHJcbiAgICAgIH0pXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoYENhbm5vdCBnZXQgYnJhbmNoZXNcXG4ke3VybC52YWx1ZX1gKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH1cclxuICBhc3luYyBjcmVhdGVfYnJhbmNoKGJyYW5jaDogc3RyaW5nLCBwYXJlbnRfYnJhbmNoOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHVybCA9IHRoaXMudXJsLmJyYW5jaGVzKClcclxuICAgICAgLmFkZCgnYnJhbmNoJywgdXJsc2xhc2goYnJhbmNoKSlcclxuICAgICAgLmFkZCgncmVmJywgdXJsc2xhc2gocGFyZW50X2JyYW5jaCkpXHJcbiAgICAgIC52YWx1ZVxyXG5cclxuICAgIGNvbnN0IHJlczogYW55W10gPSBbXVxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgYXhpb3MucG9zdCh1cmwsIG51bGwsIHtcclxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcigpXHJcbiAgICAgIH0pXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoYEVycm9yIHdoaWxlIGNyZWF0aW5nIGJyYW5jaFxcbiR7dXJsfWApXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfVxyXG4gIGFzeW5jIHNhdmVfbGFzdF9jb21taXQoKSB7XHJcbiAgICBjb25zdCB1cmwgPSB0aGlzLnVybC5jb21taXRzKClcclxuICAgICAgLmFkZCgnd2l0aF9zdGF0cycsICd0cnVlJylcclxuICAgICAgLmFkZCgnYWxsJywgJ3RydWUnKVxyXG4gICAgICAuYWRkKCdwZXJfcGFnZScsICczJylcclxuICAgICAgLnZhbHVlXHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBheGlvcy5nZXQodXJsLCB7XHJcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyKClcclxuICAgIH0pXHJcbiAgICBjb25zdCBsYXN0X2NvbW1pdCA9IHJlcy5kYXRhLnBvcCgpXHJcbiAgICBwb2NrZXQuc2V0KCdsYXN0X2NvbW1pdF9pZCcsIGxhc3RfY29tbWl0LmlkKVxyXG4gICAgcG9ja2V0LnNldCgnbGFzdF9jb21taXRfZGF0ZScsIGxhc3RfY29tbWl0LmNvbW1pdHRlZF9kYXRlKVxyXG4gIH1cclxuICBjb252ZXJ0VG9HaXRsYWJDb21taXQoZGF0YTogYW55KTogR2l0bGFiQ29tbWl0IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC4uLmRhdGEsXHJcbiAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKGRhdGEuY3JlYXRlZF9hdCksXHJcbiAgICAgIGF1dGhvcmVkX2RhdGU6IG5ldyBEYXRlKGRhdGEuYXV0aG9yZWRfZGF0ZSksXHJcbiAgICAgIGNvbW1pdHRlZF9kYXRlOiBuZXcgRGF0ZShkYXRhLmNvbW1pdHRlZF9kYXRlKSxcclxuICAgIH07XHJcbiAgfVxyXG4gIGFzeW5jIGdldF9jb21taXQoc2hhOiBzdHJpbmcpOiBQcm9taXNlPEdpdGxhYkNvbW1pdCB8IG51bGw+IHtcclxuICAgIGNvbnN0IHVybCA9IHRoaXMudXJsLmNvbW1pdHMoKVxyXG4gICAgICAuYmFzZSgnLycgKyBzaGEpXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBheGlvcy5nZXQodXJsLnZhbHVlLCB7XHJcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXIoKSxcclxuICAgICAgfSlcclxuICAgICAgcmV0dXJuIHRoaXMuY29udmVydFRvR2l0bGFiQ29tbWl0KHJlcy5kYXRhKVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBuZXcgTm90aWNlKGBDYW5ub3QgZ2V0IGNvbW1pdFxcbiR7dXJsLnZhbHVlfWApXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxuICBhc3luYyBnZXRfY29tbWl0cygpIHtcclxuICAgIGNvbnN0IHVybCA9IHRoaXMudXJsLmNvbW1pdHMoKVxyXG4gICAgICAuYWRkKCd3aXRoX3N0YXRzJywgJ3RydWUnKVxyXG4gICAgICAuYWRkKCdhbGwnLCAndHJ1ZScpXHJcbiAgICAgIC5hZGQoJ3JlZl9uYW1lJywgdGhpcy5vcHRpb25zLmJyYW5jaClcclxuICAgICAgLmFkZCgnc2luY2UnLCBwb2NrZXQuZ2V0KCdsYXN0X2NvbW1pdF9kYXRlJykgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpKVxyXG5cclxuXHJcbiAgICBjb25zdCByZXM6IGFueVtdID0gW11cclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucGFnaW5hdGlvbigxLCB1cmwsIChyZXNfaXRlbSkgPT4ge1xyXG4gICAgICAgIHJlcy5wdXNoKC4uLnJlc19pdGVtLmRhdGEpXHJcbiAgICAgIH0pXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoYENhbm5vdCBnZXQgY29tbWl0c1xcbiR7dXJsLnZhbHVlfWApXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfVxyXG4gIGFzeW5jIGdldF9hbGxfY29tbWl0cygpIHtcclxuICAgIGNvbnN0IHVybCA9IHRoaXMudXJsLmNvbW1pdHMoKVxyXG4gICAgICAuYWRkKCd3aXRoX3N0YXRzJywgJ3RydWUnKVxyXG4gICAgICAuYWRkKCdyZWZfbmFtZScsIHRoaXMub3B0aW9ucy5icmFuY2gpXHJcbiAgICAgIC5hZGQoJ2FsbCcsICd0cnVlJylcclxuXHJcbiAgICBjb25zdCByZXM6IGFueVtdID0gW11cclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucGFnaW5hdGlvbigxLCB1cmwsIChyZXNfaXRlbSkgPT4ge1xyXG4gICAgICAgIHJlcy5wdXNoKC4uLnJlc19pdGVtLmRhdGEpXHJcbiAgICAgIH0pXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoYENhbm5vdCBnZXQgY29tbWl0c1xcbiR7dXJsLnZhbHVlfWApXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfVxyXG4gIGFzeW5jIGdldF9tZXRhX2RhdGFfZmlsZShwYXRoOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHVybCA9IHRoaXMudXJsLmZpbGVzKCkuYmFzZShgLyR7dXJsc2xhc2gocGF0aCl9YClcclxuICAgICAgLmFkZCgncmVmJywgdGhpcy5vcHRpb25zLmJyYW5jaClcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gYXdhaXQgYXhpb3MuaGVhZCh1cmwudmFsdWUsIHtcclxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcigpLFxyXG4gICAgICB9KVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBuZXcgTm90aWNlKGBDYW5ub3QgZ2V0IGZpbGUgaGVhZGVyXFxuJHt1cmwudmFsdWV9YClcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsXHJcbiAgfVxyXG4gIGFzeW5jIHBhZ2luYXRpb24oc3RhcnRfcGFnZTogbnVtYmVyLCB1cmw6IEV4VXJsLCBjYWxsYmFjazogKHJlczogYW55KSA9PiB2b2lkLCBwZXJfcGFnZTogbnVtYmVyID0gMTAwKSB7XHJcbiAgICBjb25zdCBwYWdlX3VybCA9IHVybC5hZGQoJ3Blcl9wYWdlJywgcGVyX3BhZ2UudG9TdHJpbmcoKSkuYWRkKCdwYWdlJywgc3RhcnRfcGFnZS50b1N0cmluZygpKVxyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXhpb3MuZ2V0KHBhZ2VfdXJsLnZhbHVlLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVyKCkgfSlcclxuICAgIGlmIChyZXMuZGF0YT8ubGVuZ3RoID09IDApIHJldHVyblxyXG4gICAgYXdhaXQgY2FsbGJhY2socmVzKVxyXG4gICAgYXdhaXQgdGhpcy5wYWdpbmF0aW9uKHN0YXJ0X3BhZ2UgKyAxLCB1cmwsIGNhbGxiYWNrLCBwZXJfcGFnZSlcclxuICB9XHJcbiAgYXN5bmMgYmxhbWUocGF0aDpzdHJpbmcpe1xyXG4gICAgY29uc3QgdXJsID0gdGhpcy51cmwuZmlsZXMoKVxyXG4gICAgLmJhc2UoYC8ke3VybHNsYXNoKHBhdGgpfS9ibGFtZWApXHJcbiAgICAuYWRkKCdyZWYnLCB0aGlzLm9wdGlvbnMuYnJhbmNoKVxyXG4gICAgLnZhbHVlXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBheGlvcy5nZXQodXJsLCB7XHJcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXIoKSxcclxuICAgICAgfSlcclxuICAgICAgcmV0dXJuIHJlcy5kYXRhXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGFzeW5jIGdldF9kaWZmcyhjb21taXRfaWQ6IHN0cmluZykge1xyXG4gICAgY29uc3QgdXJsID0gdGhpcy51cmwuY29tbWl0cygpXHJcbiAgICAgIC5iYXNlKGAvJHtjb21taXRfaWR9L2RpZmZgKVxyXG4gICAgICAudmFsdWVcclxuICAgIGxldCByZXMgPSBudWxsXHJcbiAgICB0cnkge1xyXG4gICAgICByZXMgPSBhd2FpdCBheGlvcy5nZXQodXJsLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVyKCkgfSlcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgbmV3IE5vdGljZShgQ2Fubm90IGdldCBkaWZmIGZyb20gY29tbWl0ICR7Y29tbWl0X2lkfWApXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfVxyXG4gIGFzeW5jIGNyZWF0ZShwYXRoOiBzdHJpbmcsIGNvbW1pdDogR2l0TGFiQ29tbWl0T3B0aW9ucyA9IHt9LCBub3RpZmljYXRpb25zOiBib29sZWFuID0gdHJ1ZSwgdXBkYXRlX2lmX2V4aXN0OiBib29sZWFuID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgZmlsZV9jb250ZW50ID0gYXdhaXQgdGhpcy5nZXRfbG9jYWxfZmlsZV9jb250ZW50KHBhdGgpXHJcblxyXG4gICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgYnJhbmNoOiBjb21taXQuYnJhbmNoIHx8IHRoaXMub3B0aW9ucy5icmFuY2gsXHJcbiAgICAgIGVuY29kaW5nOiBjb21taXQuZW5jb2RpbmcgfHwgJ2Jhc2U2NCcsXHJcbiAgICAgIGF1dGhvcl9lbWFpbDogY29tbWl0LmF1dGhvcl9lbWFpbCB8fCB0aGlzLm9wdGlvbnMuZW1haWwsXHJcbiAgICAgIGF1dGhvcl9uYW1lOiBjb21taXQuYXV0aG9yX25hbWUgfHwgdGhpcy5vcHRpb25zLm5pY2ssXHJcbiAgICAgIGNvbW1pdF9tZXNzYWdlOiBjb21taXQuY29tbWl0X21lc3NhZ2UgfHwgJ2NyZWF0ZWQgZmlsZScsXHJcbiAgICAgIGNvbnRlbnQ6IGZpbGVfY29udGVudCxcclxuICAgIH1cclxuICAgIGNvbnN0IGZpbGVfdXJsID0gYCR7dGhpcy5vcHRpb25zLmFwaX0vcHJvamVjdHMvJHt0aGlzLmlkKCl9L3JlcG9zaXRvcnkvZmlsZXMvJHt1cmxzbGFzaChwYXRoKX0/cmVmPSR7ZGF0YS5icmFuY2h9YFxyXG4gICAgbGV0IHJlcyA9IG51bGxcclxuICAgIHRyeSB7XHJcbiAgICAgIHJlcyA9IGF3YWl0IGF4aW9zLnBvc3QoXHJcbiAgICAgICAgZmlsZV91cmwsXHJcbiAgICAgICAgZGF0YSwge1xyXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyKCksXHJcbiAgICAgIH0pXHJcbiAgICAgIHN5bmNfbG9ncy5sb2coYGNyZWF0aW5nIGZpbGUgXCIke3BhdGh9XCJgKVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBzeW5jX2xvZ3MubG9nKGBGQUlMOiBjcmVhdGluZyBmaWxlIFwiJHtwYXRofVwiYClcclxuICAgICAgaWYgKHVwZGF0ZV9pZl9leGlzdClcclxuICAgICAgICBpZiAobm90aWZpY2F0aW9ucyAmJiB0aGlzLm9wdGlvbnMubm90aWZpY2F0aW9ucylcclxuICAgICAgICAgIG5ldyBOb3RpY2UoJ0Nhbm5vdCBjcmVhdGUgZmlsZVxcblRyeWluZyB1cGRhdGUgZmlsZScpXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5tb2RpZnkocGF0aCwgY29tbWl0LCBub3RpZmljYXRpb25zLCBmYWxzZSlcclxuICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub3RpZmljYXRpb25zKVxyXG4gICAgICAgICAgbmV3IE5vdGljZSgnQ2Fubm90IHVwZGF0ZSBmaWxlJylcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH1cclxuICBhc3luYyBtb2RpZnkocGF0aDogc3RyaW5nLCBjb21taXQ6IEdpdExhYkNvbW1pdE9wdGlvbnMgPSB7fSwgbm90aWZpY2F0aW9uczogYm9vbGVhbiA9IHRydWUsIGNyZWF0ZV9pZl9ub3RfZXhpc3Q6IGJvb2xlYW4gPSB0cnVlKSB7XHJcbiAgICBjb25zdCBmaWxlX2NvbnRlbnQgPSBhd2FpdCB0aGlzLmdldF9sb2NhbF9maWxlX2NvbnRlbnQocGF0aClcclxuICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgIGJyYW5jaDogY29tbWl0LmJyYW5jaCB8fCB0aGlzLm9wdGlvbnMuYnJhbmNoLFxyXG4gICAgICBlbmNvZGluZzogY29tbWl0LmVuY29kaW5nIHx8ICdiYXNlNjQnLFxyXG4gICAgICBhdXRob3JfZW1haWw6IGNvbW1pdC5hdXRob3JfZW1haWwgfHwgdGhpcy5vcHRpb25zLmVtYWlsLFxyXG4gICAgICBhdXRob3JfbmFtZTogY29tbWl0LmF1dGhvcl9uYW1lIHx8IHRoaXMub3B0aW9ucy5uaWNrLFxyXG4gICAgICBjb21taXRfbWVzc2FnZTogY29tbWl0LmNvbW1pdF9tZXNzYWdlIHx8ICdtb2RpZmllZCBmaWxlJyxcclxuICAgICAgY29udGVudDogZmlsZV9jb250ZW50LFxyXG4gICAgfVxyXG4gICAgY29uc3QgZmlsZV91cmwgPSBgJHt0aGlzLm9wdGlvbnMuYXBpfS9wcm9qZWN0cy8ke3RoaXMuaWQoKX0vcmVwb3NpdG9yeS9maWxlcy8ke3VybHNsYXNoKHBhdGgpfT9yZWY9JHtkYXRhLmJyYW5jaH1gXHJcbiAgICBsZXQgcmVzID0gbnVsbFxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHJlcyA9IGF3YWl0IGF4aW9zLnB1dChcclxuICAgICAgICBmaWxlX3VybCxcclxuICAgICAgICBkYXRhLCB7XHJcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXIoKSxcclxuICAgICAgfSlcclxuICAgICAgc3luY19sb2dzLmxvZyhgbW9kaWZ5aW5nIGZpbGUgXCIke3BhdGh9XCJgKVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBzeW5jX2xvZ3MubG9nKGBGQUlMOiBtb2RpZnlpbmcgZmlsZSBcIiR7cGF0aH1cImApXHJcbiAgICAgIGlmIChjcmVhdGVfaWZfbm90X2V4aXN0KVxyXG4gICAgICAgIGlmIChub3RpZmljYXRpb25zICYmIHRoaXMub3B0aW9ucy5ub3RpZmljYXRpb25zKVxyXG4gICAgICAgICAgbmV3IE5vdGljZSgnQ2Fubm90IHVwZGF0ZSBmaWxlXFxuVHJ5aW5nIGNyZWF0ZSBmaWxlJylcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZShwYXRoLCBjb21taXQsIG5vdGlmaWNhdGlvbnMsIGZhbHNlKVxyXG4gICAgICB9IGNhdGNoIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vdGlmaWNhdGlvbnMpXHJcbiAgICAgICAgICBuZXcgTm90aWNlKCdDYW5ub3QgY3JlYXRlIGZpbGUnKVxyXG4gICAgICB9XHJcblxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH1cclxuICBhc3luYyBkZWxldGUocGF0aDogc3RyaW5nLCBjb21taXQ6IEdpdExhYkNvbW1pdE9wdGlvbnMgPSB7fSwgbm90aWZpY2F0aW9uczogYm9vbGVhbiA9IHRydWUpIHtcclxuICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgIGJyYW5jaDogY29tbWl0LmJyYW5jaCB8fCB0aGlzLm9wdGlvbnMuYnJhbmNoLFxyXG4gICAgICBhdXRob3JfZW1haWw6IGNvbW1pdC5hdXRob3JfZW1haWwgfHwgdGhpcy5vcHRpb25zLmVtYWlsLFxyXG4gICAgICBhdXRob3JfbmFtZTogY29tbWl0LmF1dGhvcl9uYW1lIHx8IHRoaXMub3B0aW9ucy5uaWNrLFxyXG4gICAgICBjb21taXRfbWVzc2FnZTogY29tbWl0LmNvbW1pdF9tZXNzYWdlIHx8ICdkZWxldGVkIGZpbGUnLFxyXG4gICAgfVxyXG4gICAgY29uc3QgZmlsZV91cmwgPSBgJHt0aGlzLm9wdGlvbnMuYXBpfS9wcm9qZWN0cy8ke3RoaXMuaWQoKX0vcmVwb3NpdG9yeS9maWxlcy8ke3VybHNsYXNoKHBhdGgpfT9yZWY9JHtkYXRhLmJyYW5jaH1gXHJcbiAgICBsZXQgcmVzID0gbnVsbFxyXG4gICAgdHJ5IHtcclxuICAgICAgcmVzID0gYXdhaXQgYXhpb3Moe1xyXG4gICAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICAgICAgdXJsOiBmaWxlX3VybCxcclxuICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyKClcclxuICAgICAgfSlcclxuICAgICAgc3luY19sb2dzLmxvZyhgZGVsZXRpbmcgZmlsZSBcIiR7cGF0aH1cImApXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHN5bmNfbG9ncy5sb2coYEZBSUw6IGRlbGV0aW5nIGZpbGUgXCIke3BhdGh9XCJgKVxyXG4gICAgICBpZiAobm90aWZpY2F0aW9ucyAmJiB0aGlzLm9wdGlvbnMubm90aWZpY2F0aW9ucylcclxuICAgICAgICBuZXcgTm90aWNlKCdDYW5ub3QgZGVsZXRlIGZpbGUnKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH1cclxuICBhc3luYyByZW5hbWUocGF0aDogc3RyaW5nLCBvbGRfcGF0aDogc3RyaW5nLCBjb21taXQ6IEdpdExhYkNvbW1pdE9wdGlvbnMgPSB7fSwgbm90aWZpY2F0aW9uczogYm9vbGVhbiA9IHRydWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuY3JlYXRlKHBhdGgsIGNvbW1pdCwgbm90aWZpY2F0aW9ucylcclxuICAgICAgYXdhaXQgdGhpcy5kZWxldGUob2xkX3BhdGgsIGNvbW1pdCwgbm90aWZpY2F0aW9ucylcclxuICAgICAgc3luY19sb2dzLmxvZyhgcmVuYW1pbmcgZmlsZSBcIiR7b2xkX3BhdGh9XCIgLT4gXCIke3BhdGh9XCJgKVxyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHN5bmNfbG9ncy5sb2coYEZBSUw6IHJlbmFtaW5nIGZpbGUgXCIke29sZF9wYXRofVwiIC0+IFwiJHtwYXRofVwiYClcclxuICAgIH1cclxuICB9XHJcbiAgYXN5bmMgcmVhZChwYXRoOiBzdHJpbmcsIGJyYW5jaDogc3RyaW5nID0gdGhpcy5vcHRpb25zLmJyYW5jaCkge1xyXG4gICAgY29uc3QgZmlsZV91cmwgPSBgJHt0aGlzLm9wdGlvbnMuYXBpfS9wcm9qZWN0cy8ke3RoaXMuaWQoKX0vcmVwb3NpdG9yeS9maWxlcy8ke3VybHNsYXNoKHBhdGgpfT9yZWY9JHticmFuY2h9YFxyXG4gICAgbGV0IHJlcyA9IG51bGxcclxuICAgIHRyeSB7XHJcbiAgICAgIHJlcyA9IGF3YWl0IGF4aW9zLmdldChcclxuICAgICAgICBmaWxlX3VybCwge1xyXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyKCksXHJcbiAgICAgIH0pXHJcbiAgICAgIHN5bmNfbG9ncy5sb2coYHJlYWRpbmcgZmlsZSBcIiR7cGF0aH1cImApXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHN5bmNfbG9ncy5sb2coYEZBSUw6IHJlYWRpbmcgZmlsZSBcIiR7cGF0aH1cImApXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubm90aWZpY2F0aW9ucylcclxuICAgICAgICBuZXcgTm90aWNlKCdDYW5ub3QgcmVhZCBmaWxlJylcclxuICAgIH1cclxuICAgIHJldHVybiByZXNcclxuICB9XHJcbiAgYXN5bmMgcmVhZF9yZXBvX3RyZWUocGF0aDogc3RyaW5nID0gJycsIGRlcHRoOiBudW1iZXIgPSAwLCBkZXB0aF9saW1pdDogbnVtYmVyID0gLTEsIG5vdGlmaWNhdGlvbnM6IGJvb2xlYW4gPSB0cnVlKSB7XHJcbiAgICBjb25zdCB1cmwgPSBleHVybChgJHt0aGlzLm9wdGlvbnMuYXBpfS9wcm9qZWN0cy8ke3RoaXMuaWQoKX0vcmVwb3NpdG9yeS90cmVlYClcclxuICAgICAgLmFkZCgncGF0aCcsIHVybHNsYXNoKHBhdGgpKVxyXG4gICAgICAuYWRkKCdyZWYnLCB0aGlzLm9wdGlvbnMuYnJhbmNoKVxyXG4gICAgICAuYWRkKCdyZWN1cnNpdmUnLCAndHJ1ZScpXHJcblxyXG4gICAgY29uc3QgdHJlZTogc3RyaW5nW11bXSA9IFtdXHJcbiAgICBjb25zdCBwYWdlczogYW55W10gPSBbXVxyXG4gICAgYXdhaXQgdGhpcy5wYWdpbmF0aW9uKDEsIHVybCwgKHJlcykgPT4ge1xyXG4gICAgICBwYWdlcy5wdXNoKC4uLnJlcy5kYXRhKVxyXG4gICAgfSlcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBwYWdlcykge1xyXG4gICAgICB0cmVlLnB1c2goW2l0ZW0uaWQsIGl0ZW0ucGF0aCwgaXRlbS50eXBlID09ICd0cmVlJ10pXHJcblxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm5vdGlmaWNhdGlvbnMgJiYgbm90aWZpY2F0aW9ucyAmJiBpdGVtLnR5cGUgPT0gJ3RyZWUnKVxyXG4gICAgICAgIG5ldyBOb3RpY2UoYEZldGNoaW5nOiBcIiR7aXRlbS5wYXRofVwiYClcclxuICAgIH1cclxuICAgIHJldHVybiB0cmVlXHJcbiAgfVxyXG4gIHNuaXBwZXQodGl0bGU6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZyA9ICcnLCB2aXNpYmlsaXR5OiBzdHJpbmcgPSAncHJpdmF0ZScpIHtcclxuICAgIGNvbnN0IHNuaXBwZXQgPSBuZXcgR2l0TGFiQVBJU25pcHBldCh0aGlzKVxyXG4gICAgc25pcHBldC5tZXRhZGF0YSh7IHRpdGxlLCBkZXNjcmlwdGlvbiwgdmlzaWJpbGl0eSB9KVxyXG4gICAgcmV0dXJuIHNuaXBwZXRcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBHaXRMYWJBUElTbmlwcGV0IGV4dGVuZHMgR2l0TGFiQVBJIHtcclxuICBzbmlwcGV0X2lkOiBzdHJpbmdcclxuICB0aXRsZTogc3RyaW5nXHJcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xyXG4gIHZpc2liaWxpdHk6IHN0cmluZ1xyXG4gIHN5bmM6IGJvb2xlYW4gPSBmYWxzZVxyXG4gIGZpbGVzOiBHaXRMYWJTbmlwcGV0RmlsZVtdID0gW11cclxuICBjb25zdHJ1Y3RvcihnaXRsYWI6IEdpdExhYkFQSSkge1xyXG4gICAgc3VwZXIoKVxyXG4gICAgdGhpcy5zZXRvcHRpb25zKGdpdGxhYi5vcHRpb25zKVxyXG4gIH1cclxuICBib2R5KCk6IEdpdExhYlNuaXBwZXREb2Mge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxyXG4gICAgICB2aXNpYmlsaXR5OiB0aGlzLnZpc2liaWxpdHksXHJcbiAgICAgIGZpbGVzOiBbXSxcclxuICAgIH1cclxuICB9XHJcbiAgbWV0YWRhdGEoc25pcHBldDogYW55KSB7XHJcbiAgICB0aGlzLnRpdGxlID0gc25pcHBldC50aXRsZVxyXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IHNuaXBwZXQuZGVzY3JpcHRpb25cclxuICAgIHRoaXMudmlzaWJpbGl0eSA9IHNuaXBwZXQudmlzaWJpbGl0eVxyXG4gIH1cclxuICBhc3luYyBhZGRfZmlsZXMoLi4uZmlsZXM6IEdpdExhYlNuaXBwZXRGaWxlW10pIHtcclxuICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xyXG4gICAgICBmaWxlLmFjdGlvbiA9IGZpbGUuYWN0aW9uIHx8IFwiY3JlYXRlXCJcclxuICAgICAgdGhpcy5maWxlcy5wdXNoKGZpbGUpXHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5zeW5jKSB7XHJcbiAgICAgIGlmICh0aGlzLnNuaXBwZXRfaWQpXHJcbiAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVfc25pcHBldCh7IGZpbGVzOiBmaWxlcyB9KVxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVfc25pcHBldCh7IGZpbGVzOiBmaWxlcyB9KVxyXG4gICAgfVxyXG4gIH1cclxuICBhc3luYyB1cGRhdGVfZmlsZXMoLi4uZmlsZXM6IEdpdExhYlNuaXBwZXRGaWxlW10pIHtcclxuICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xyXG4gICAgICBmaWxlLmFjdGlvbiA9IGZpbGUuYWN0aW9uIHx8IFwidXBkYXRlXCJcclxuICAgICAgaWYgKCEhZmlsZS5wcmV2aW91c19wYXRoKVxyXG4gICAgICAgIGZpbGUuYWN0aW9uID0gJ21vdmUnXHJcblxyXG4gICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLmZpbGVzKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuZmlsZXNbaW5kZXhdXHJcbiAgICAgICAgaWYgKGZpbGUuZmlsZV9wYXRoID09IGl0ZW0uZmlsZV9wYXRoIHx8IGZpbGUucHJldmlvdXNfcGF0aCA9PSBpdGVtLmZpbGVfcGF0aClcclxuICAgICAgICAgIHRoaXMuZmlsZXNbaW5kZXhdID0gZmlsZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5zeW5jKVxyXG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZV9zbmlwcGV0KHsgZmlsZXM6IGZpbGVzIH0pXHJcbiAgfVxyXG4gIGFzeW5jIHJlbW92ZV9maWxlcyguLi5maWxlczogR2l0TGFiU25pcHBldEZpbGVPcHRpb25hbFtdKSB7XHJcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcclxuICAgICAgZmlsZS5hY3Rpb24gPSAnZGVsZXRlJ1xyXG4gICAgICBpZiAoIWZpbGUuZmlsZV9wYXRoKSBjb250aW51ZVxyXG4gICAgICBmaWxlLmNvbnRlbnQgPSAnJ1xyXG4gICAgICBmaWxlLnByZXZpb3VzX3BhdGggPSAnJ1xyXG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5maWxlcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5maWxlc1tpbmRleF1cclxuICAgICAgICBpZiAoZmlsZS5maWxlX3BhdGggPT0gaXRlbS5maWxlX3BhdGggfHwgZmlsZS5wcmV2aW91c19wYXRoID09IGl0ZW0uZmlsZV9wYXRoKVxyXG4gICAgICAgICAgdGhpcy5maWxlcy5zcGxpY2UoaW5kZXgsIDEpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLnN5bmMpXHJcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlX3NuaXBwZXQoeyBmaWxlczogZmlsZXMgYXMgR2l0TGFiU25pcHBldEZpbGVbXSB9KVxyXG4gIH1cclxuICBhc3luYyBmcm9tX2lkKGlkOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHNuaXBwZXQgPSBhd2FpdCBheGlvcy5nZXQoXHJcbiAgICAgIGAke3RoaXMub3B0aW9ucy5hcGl9L3Byb2plY3RzLyR7dGhpcy5pZCgpfS9zbmlwcGV0cy8ke2lkfWAsXHJcbiAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXIoKSB9KVxyXG4gICAgY29uc29sZS5sb2coc25pcHBldClcclxuICAgIGlmIChzbmlwcGV0ICYmIHNuaXBwZXQuZGF0YSkge1xyXG4gICAgICB0aGlzLnNuaXBwZXRfaWQgPSBpZFxyXG4gICAgICB0aGlzLnRpdGxlID0gc25pcHBldC5kYXRhLnRpdGxlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gc25pcHBldC5kYXRhXHJcbiAgfVxyXG4gIGFzeW5jIGNyZWF0ZV9zbmlwcGV0KGJvZHk6IEdpdExhYlNuaXBwZXREb2NPcHRpb25hbCA9IHt9KSB7XHJcbiAgICBjb25zdCBjcmVhdGUgPSBhd2FpdCBheGlvcy5wb3N0KFxyXG4gICAgICBgJHt0aGlzLm9wdGlvbnMuYXBpfS9wcm9qZWN0cy8ke3RoaXMuaWQoKX0vc25pcHBldHNgLFxyXG4gICAgICB7IC4uLnRoaXMuYm9keSgpLCAuLi5ib2R5IH0sXHJcbiAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXIoKSB9KVxyXG4gICAgdGhpcy5zbmlwcGV0X2lkID0gY3JlYXRlLmRhdGEuaWRcclxuICB9XHJcbiAgYXN5bmMgdXBkYXRlX3NuaXBwZXQoYm9keTogR2l0TGFiU25pcHBldERvY09wdGlvbmFsID0ge30pIHtcclxuICAgIGlmICghdGhpcy5zbmlwcGV0X2lkKSByZXR1cm5cclxuICAgIGF3YWl0IGF4aW9zLnB1dChcclxuICAgICAgYCR7dGhpcy5vcHRpb25zLmFwaX0vcHJvamVjdHMvJHt0aGlzLmlkKCl9L3NuaXBwZXRzLyR7dGhpcy5zbmlwcGV0X2lkfWAsXHJcbiAgICAgIHsgLi4udGhpcy5ib2R5KCksIC4uLmJvZHkgfSxcclxuICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcigpIH0pXHJcbiAgfVxyXG4gIGFzeW5jIGRlbGV0ZV9zbmlwcGV0KCkge1xyXG4gICAgaWYgKCF0aGlzLnNuaXBwZXRfaWQpIHJldHVyblxyXG4gICAgcmV0dXJuIGF3YWl0IGF4aW9zLmRlbGV0ZShcclxuICAgICAgYCR7dGhpcy5vcHRpb25zLmFwaX0vcHJvamVjdHMvJHt0aGlzLmlkKCl9L3NuaXBwZXRzLyR7dGhpcy5zbmlwcGV0X2lkfWAsXHJcbiAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXIoKSB9KVxyXG4gIH1cclxuICBhc3luYyBnZXRfZmlsZShwYXRoOiBzdHJpbmcpIHtcclxuICAgIGlmICghdGhpcy5zbmlwcGV0X2lkKSByZXR1cm5cclxuICAgIC8vIFRPRE8gbWFpbiAtIDpyZWYgLT4gZGVmYXVsdCBnaXRsYWIgYnJhbmNoIGZvciBhbGwgc25pcHBldFxyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXhpb3MuZ2V0KFxyXG4gICAgICBgJHt0aGlzLm9wdGlvbnMuYXBpfS9wcm9qZWN0cy8ke3RoaXMuaWQoKX0vc25pcHBldHMvJHt0aGlzLnNuaXBwZXRfaWR9L2ZpbGVzL21haW4vJHt1cmxzbGFzaChwYXRoKX0vcmF3YCxcclxuICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcigpIH0pXHJcblxyXG4gICAgY29uc3QgY29udGVudCA9IHJlcy5kYXRhXHJcblxyXG4gICAgZm9yIChsZXQgZmlsZSBvZiB0aGlzLmZpbGVzKSB7XHJcbiAgICAgIGlmIChmaWxlLmZpbGVfcGF0aCA9PSBwYXRoIHx8IGZpbGUucHJldmlvdXNfcGF0aCA9PSBwYXRoKVxyXG4gICAgICAgIGZpbGUuY29udGVudCA9IGNvbnRlbnRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29udGVudFxyXG4gIH1cclxuICBhc3luYyBnZXRfc25pcHBldCgpIHtcclxuICAgIGlmICghdGhpcy5zbmlwcGV0X2lkKSByZXR1cm5cclxuICAgIHJldHVybiBhd2FpdCBheGlvcy5nZXQoXHJcbiAgICAgIGAke3RoaXMub3B0aW9ucy5hcGl9L3Byb2plY3RzLyR7dGhpcy5pZCgpfS9zbmlwcGV0cy8ke3RoaXMuc25pcHBldF9pZH0vcmF3YCxcclxuICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcigpIH0pXHJcbiAgfVxyXG59IiwgIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBiaW5kIGZyb20gJy4vaGVscGVycy9iaW5kLmpzJztcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxuY29uc3Qge3RvU3RyaW5nfSA9IE9iamVjdC5wcm90b3R5cGU7XG5jb25zdCB7Z2V0UHJvdG90eXBlT2Z9ID0gT2JqZWN0O1xuXG5jb25zdCBraW5kT2YgPSAoY2FjaGUgPT4gdGhpbmcgPT4ge1xuICAgIGNvbnN0IHN0ciA9IHRvU3RyaW5nLmNhbGwodGhpbmcpO1xuICAgIHJldHVybiBjYWNoZVtzdHJdIHx8IChjYWNoZVtzdHJdID0gc3RyLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpKTtcbn0pKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG5jb25zdCBraW5kT2ZUZXN0ID0gKHR5cGUpID0+IHtcbiAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuICh0aGluZykgPT4ga2luZE9mKHRoaW5nKSA9PT0gdHlwZVxufVxuXG5jb25zdCB0eXBlT2ZUZXN0ID0gdHlwZSA9PiB0aGluZyA9PiB0eXBlb2YgdGhpbmcgPT09IHR5cGU7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCB7aXNBcnJheX0gPSBBcnJheTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VuZGVmaW5lZCA9IHR5cGVPZlRlc3QoJ3VuZGVmaW5lZCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIGlzRnVuY3Rpb24odmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKSAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0FycmF5QnVmZmVyID0ga2luZE9mVGVzdCgnQXJyYXlCdWZmZXInKTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIGxldCByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNTdHJpbmcgPSB0eXBlT2ZUZXN0KCdzdHJpbmcnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Z1bmN0aW9uID0gdHlwZU9mVGVzdCgnZnVuY3Rpb24nKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc051bWJlciA9IHR5cGVPZlRlc3QoJ251bWJlcicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJvb2xlYW5cbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJvb2xlYW4sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Jvb2xlYW4gPSB0aGluZyA9PiB0aGluZyA9PT0gdHJ1ZSB8fCB0aGluZyA9PT0gZmFsc2U7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHtcbiAgaWYgKGtpbmRPZih2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNEYXRlID0ga2luZE9mVGVzdCgnRGF0ZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlID0ga2luZE9mVGVzdCgnRmlsZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNCbG9iID0ga2luZE9mVGVzdCgnQmxvYicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZUxpc3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRmlsZUxpc3QgPSBraW5kT2ZUZXN0KCdGaWxlTGlzdCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzU3RyZWFtID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGb3JtRGF0YSA9ICh0aGluZykgPT4ge1xuICBsZXQga2luZDtcbiAgcmV0dXJuIHRoaW5nICYmIChcbiAgICAodHlwZW9mIEZvcm1EYXRhID09PSAnZnVuY3Rpb24nICYmIHRoaW5nIGluc3RhbmNlb2YgRm9ybURhdGEpIHx8IChcbiAgICAgIGlzRnVuY3Rpb24odGhpbmcuYXBwZW5kKSAmJiAoXG4gICAgICAgIChraW5kID0ga2luZE9mKHRoaW5nKSkgPT09ICdmb3JtZGF0YScgfHxcbiAgICAgICAgLy8gZGV0ZWN0IGZvcm0tZGF0YSBpbnN0YW5jZVxuICAgICAgICAoa2luZCA9PT0gJ29iamVjdCcgJiYgaXNGdW5jdGlvbih0aGluZy50b1N0cmluZykgJiYgdGhpbmcudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgRm9ybURhdGFdJylcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzVVJMU2VhcmNoUGFyYW1zID0ga2luZE9mVGVzdCgnVVJMU2VhcmNoUGFyYW1zJyk7XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmNvbnN0IHRyaW0gPSAoc3RyKSA9PiBzdHIudHJpbSA/XG4gIHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXMgPSBmYWxzZV1cbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbiwge2FsbE93bktleXMgPSBmYWxzZX0gPSB7fSkge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBpO1xuICBsZXQgbDtcblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAoaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgY29uc3Qga2V5cyA9IGFsbE93bktleXMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopIDogT2JqZWN0LmtleXMob2JqKTtcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kS2V5KG9iaiwga2V5KSB7XG4gIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IF9rZXk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgX2tleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSA9PT0gX2tleS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gX2tleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IF9nbG9iYWwgPSAoKCkgPT4ge1xuICAvKmVzbGludCBuby11bmRlZjowKi9cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcbn0pKCk7XG5cbmNvbnN0IGlzQ29udGV4dERlZmluZWQgPSAoY29udGV4dCkgPT4gIWlzVW5kZWZpbmVkKGNvbnRleHQpICYmIGNvbnRleHQgIT09IF9nbG9iYWw7XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgY29uc3Qge2Nhc2VsZXNzfSA9IGlzQ29udGV4dERlZmluZWQodGhpcykgJiYgdGhpcyB8fCB7fTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGFzc2lnblZhbHVlID0gKHZhbCwga2V5KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gY2FzZWxlc3MgJiYgZmluZEtleShyZXN1bHQsIGtleSkgfHwga2V5O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFt0YXJnZXRLZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2UocmVzdWx0W3RhcmdldEtleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGFyZ3VtZW50c1tpXSAmJiBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxPd25LZXlzXVxuICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5jb25zdCBleHRlbmQgPSAoYSwgYiwgdGhpc0FyZywge2FsbE93bktleXN9PSB7fSkgPT4ge1xuICBmb3JFYWNoKGIsICh2YWwsIGtleSkgPT4ge1xuICAgIGlmICh0aGlzQXJnICYmIGlzRnVuY3Rpb24odmFsKSkge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9LCB7YWxsT3duS2V5c30pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuY29uc3Qgc3RyaXBCT00gPSAoY29udGVudCkgPT4ge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3BzXVxuICogQHBhcmFtIHtvYmplY3R9IFtkZXNjcmlwdG9yc11cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgaW5oZXJpdHMgPSAoY29uc3RydWN0b3IsIHN1cGVyQ29uc3RydWN0b3IsIHByb3BzLCBkZXNjcmlwdG9ycykgPT4ge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCBkZXNjcmlwdG9ycyk7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdzdXBlcicsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgfSk7XG4gIHByb3BzICYmIE9iamVjdC5hc3NpZ24oY29uc3RydWN0b3IucHJvdG90eXBlLCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBvYmplY3Qgd2l0aCBkZWVwIHByb3RvdHlwZSBjaGFpbiB0byBhIGZsYXQgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlT2JqIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGVzdE9ial1cbiAqIEBwYXJhbSB7RnVuY3Rpb258Qm9vbGVhbn0gW2ZpbHRlcl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wRmlsdGVyXVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmNvbnN0IHRvRmxhdE9iamVjdCA9IChzb3VyY2VPYmosIGRlc3RPYmosIGZpbHRlciwgcHJvcEZpbHRlcikgPT4ge1xuICBsZXQgcHJvcHM7XG4gIGxldCBpO1xuICBsZXQgcHJvcDtcbiAgY29uc3QgbWVyZ2VkID0ge307XG5cbiAgZGVzdE9iaiA9IGRlc3RPYmogfHwge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICBpZiAoc291cmNlT2JqID09IG51bGwpIHJldHVybiBkZXN0T2JqO1xuXG4gIGRvIHtcbiAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZU9iaik7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKCghcHJvcEZpbHRlciB8fCBwcm9wRmlsdGVyKHByb3AsIHNvdXJjZU9iaiwgZGVzdE9iaikpICYmICFtZXJnZWRbcHJvcF0pIHtcbiAgICAgICAgZGVzdE9ialtwcm9wXSA9IHNvdXJjZU9ialtwcm9wXTtcbiAgICAgICAgbWVyZ2VkW3Byb3BdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlT2JqID0gZmlsdGVyICE9PSBmYWxzZSAmJiBnZXRQcm90b3R5cGVPZihzb3VyY2VPYmopO1xuICB9IHdoaWxlIChzb3VyY2VPYmogJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHNvdXJjZU9iaiwgZGVzdE9iaikpICYmIHNvdXJjZU9iaiAhPT0gT2JqZWN0LnByb3RvdHlwZSk7XG5cbiAgcmV0dXJuIGRlc3RPYmo7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGVuZHMgd2l0aCB0aGUgY2hhcmFjdGVycyBvZiBhIHNwZWNpZmllZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uPSAwXVxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBlbmRzV2l0aCA9IChzdHIsIHNlYXJjaFN0cmluZywgcG9zaXRpb24pID0+IHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID4gc3RyLmxlbmd0aCkge1xuICAgIHBvc2l0aW9uID0gc3RyLmxlbmd0aDtcbiAgfVxuICBwb3NpdGlvbiAtPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICBjb25zdCBsYXN0SW5kZXggPSBzdHIuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgbmV3IGFycmF5IGZyb20gYXJyYXkgbGlrZSBvYmplY3Qgb3IgbnVsbCBpZiBmYWlsZWRcbiAqXG4gKiBAcGFyYW0geyp9IFt0aGluZ11cbiAqXG4gKiBAcmV0dXJucyB7P0FycmF5fVxuICovXG5jb25zdCB0b0FycmF5ID0gKHRoaW5nKSA9PiB7XG4gIGlmICghdGhpbmcpIHJldHVybiBudWxsO1xuICBpZiAoaXNBcnJheSh0aGluZykpIHJldHVybiB0aGluZztcbiAgbGV0IGkgPSB0aGluZy5sZW5ndGg7XG4gIGlmICghaXNOdW1iZXIoaSkpIHJldHVybiBudWxsO1xuICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgYXJyW2ldID0gdGhpbmdbaV07XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBDaGVja2luZyBpZiB0aGUgVWludDhBcnJheSBleGlzdHMgYW5kIGlmIGl0IGRvZXMsIGl0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGVcbiAqIHRoaW5nIHBhc3NlZCBpbiBpcyBhbiBpbnN0YW5jZSBvZiBVaW50OEFycmF5XG4gKlxuICogQHBhcmFtIHtUeXBlZEFycmF5fVxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbmNvbnN0IGlzVHlwZWRBcnJheSA9IChUeXBlZEFycmF5ID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIHRoaW5nID0+IHtcbiAgICByZXR1cm4gVHlwZWRBcnJheSAmJiB0aGluZyBpbnN0YW5jZW9mIFR5cGVkQXJyYXk7XG4gIH07XG59KSh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSkpO1xuXG4vKipcbiAqIEZvciBlYWNoIGVudHJ5IGluIHRoZSBvYmplY3QsIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGtleSBhbmQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggZW50cnkuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGZvckVhY2hFbnRyeSA9IChvYmosIGZuKSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRvciA9IG9iaiAmJiBvYmpbU3ltYm9sLml0ZXJhdG9yXTtcblxuICBjb25zdCBpdGVyYXRvciA9IGdlbmVyYXRvci5jYWxsKG9iaik7XG5cbiAgbGV0IHJlc3VsdDtcblxuICB3aGlsZSAoKHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKSkgJiYgIXJlc3VsdC5kb25lKSB7XG4gICAgY29uc3QgcGFpciA9IHJlc3VsdC52YWx1ZTtcbiAgICBmbi5jYWxsKG9iaiwgcGFpclswXSwgcGFpclsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmQgYSBzdHJpbmcsIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdFeHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFnYWluc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBzZWFyY2guXG4gKlxuICogQHJldHVybnMge0FycmF5PGJvb2xlYW4+fVxuICovXG5jb25zdCBtYXRjaEFsbCA9IChyZWdFeHAsIHN0cikgPT4ge1xuICBsZXQgbWF0Y2hlcztcbiAgY29uc3QgYXJyID0gW107XG5cbiAgd2hpbGUgKChtYXRjaGVzID0gcmVnRXhwLmV4ZWMoc3RyKSkgIT09IG51bGwpIHtcbiAgICBhcnIucHVzaChtYXRjaGVzKTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbi8qIENoZWNraW5nIGlmIHRoZSBraW5kT2ZUZXN0IGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB3aGVuIHBhc3NlZCBhbiBIVE1MRm9ybUVsZW1lbnQuICovXG5jb25zdCBpc0hUTUxGb3JtID0ga2luZE9mVGVzdCgnSFRNTEZvcm1FbGVtZW50Jyk7XG5cbmNvbnN0IHRvQ2FtZWxDYXNlID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX1xcc10oW2EtelxcZF0pKFxcdyopL2csXG4gICAgZnVuY3Rpb24gcmVwbGFjZXIobSwgcDEsIHAyKSB7XG4gICAgICByZXR1cm4gcDEudG9VcHBlckNhc2UoKSArIHAyO1xuICAgIH1cbiAgKTtcbn07XG5cbi8qIENyZWF0aW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNoZWNrIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS4gKi9cbmNvbnN0IGhhc093blByb3BlcnR5ID0gKCh7aGFzT3duUHJvcGVydHl9KSA9PiAob2JqLCBwcm9wKSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpKE9iamVjdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNSZWdFeHAgPSBraW5kT2ZUZXN0KCdSZWdFeHAnKTtcblxuY29uc3QgcmVkdWNlRGVzY3JpcHRvcnMgPSAob2JqLCByZWR1Y2VyKSA9PiB7XG4gIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKTtcbiAgY29uc3QgcmVkdWNlZERlc2NyaXB0b3JzID0ge307XG5cbiAgZm9yRWFjaChkZXNjcmlwdG9ycywgKGRlc2NyaXB0b3IsIG5hbWUpID0+IHtcbiAgICBsZXQgcmV0O1xuICAgIGlmICgocmV0ID0gcmVkdWNlcihkZXNjcmlwdG9yLCBuYW1lLCBvYmopKSAhPT0gZmFsc2UpIHtcbiAgICAgIHJlZHVjZWREZXNjcmlwdG9yc1tuYW1lXSA9IHJldCB8fCBkZXNjcmlwdG9yO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCByZWR1Y2VkRGVzY3JpcHRvcnMpO1xufVxuXG4vKipcbiAqIE1ha2VzIGFsbCBtZXRob2RzIHJlYWQtb25seVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5cbmNvbnN0IGZyZWV6ZU1ldGhvZHMgPSAob2JqKSA9PiB7XG4gIHJlZHVjZURlc2NyaXB0b3JzKG9iaiwgKGRlc2NyaXB0b3IsIG5hbWUpID0+IHtcbiAgICAvLyBza2lwIHJlc3RyaWN0ZWQgcHJvcHMgaW4gc3RyaWN0IG1vZGVcbiAgICBpZiAoaXNGdW5jdGlvbihvYmopICYmIFsnYXJndW1lbnRzJywgJ2NhbGxlcicsICdjYWxsZWUnXS5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gb2JqW25hbWVdO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoJ3dyaXRhYmxlJyBpbiBkZXNjcmlwdG9yKSB7XG4gICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFkZXNjcmlwdG9yLnNldCkge1xuICAgICAgZGVzY3JpcHRvci5zZXQgPSAoKSA9PiB7XG4gICAgICAgIHRocm93IEVycm9yKCdDYW4gbm90IHJld3JpdGUgcmVhZC1vbmx5IG1ldGhvZCBcXCcnICsgbmFtZSArICdcXCcnKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgdG9PYmplY3RTZXQgPSAoYXJyYXlPclN0cmluZywgZGVsaW1pdGVyKSA9PiB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuXG4gIGNvbnN0IGRlZmluZSA9IChhcnIpID0+IHtcbiAgICBhcnIuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICBvYmpbdmFsdWVdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGlzQXJyYXkoYXJyYXlPclN0cmluZykgPyBkZWZpbmUoYXJyYXlPclN0cmluZykgOiBkZWZpbmUoU3RyaW5nKGFycmF5T3JTdHJpbmcpLnNwbGl0KGRlbGltaXRlcikpO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5jb25zdCB0b0Zpbml0ZU51bWJlciA9ICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuXG5jb25zdCBBTFBIQSA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eidcblxuY29uc3QgRElHSVQgPSAnMDEyMzQ1Njc4OSc7XG5cbmNvbnN0IEFMUEhBQkVUID0ge1xuICBESUdJVCxcbiAgQUxQSEEsXG4gIEFMUEhBX0RJR0lUOiBBTFBIQSArIEFMUEhBLnRvVXBwZXJDYXNlKCkgKyBESUdJVFxufVxuXG5jb25zdCBnZW5lcmF0ZVN0cmluZyA9IChzaXplID0gMTYsIGFscGhhYmV0ID0gQUxQSEFCRVQuQUxQSEFfRElHSVQpID0+IHtcbiAgbGV0IHN0ciA9ICcnO1xuICBjb25zdCB7bGVuZ3RofSA9IGFscGhhYmV0O1xuICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgc3RyICs9IGFscGhhYmV0W01hdGgucmFuZG9tKCkgKiBsZW5ndGh8MF1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogSWYgdGhlIHRoaW5nIGlzIGEgRm9ybURhdGEgb2JqZWN0LCByZXR1cm4gdHJ1ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHRoaW5nIC0gVGhlIHRoaW5nIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1NwZWNDb21wbGlhbnRGb3JtKHRoaW5nKSB7XG4gIHJldHVybiAhISh0aGluZyAmJiBpc0Z1bmN0aW9uKHRoaW5nLmFwcGVuZCkgJiYgdGhpbmdbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0Zvcm1EYXRhJyAmJiB0aGluZ1tTeW1ib2wuaXRlcmF0b3JdKTtcbn1cblxuY29uc3QgdG9KU09OT2JqZWN0ID0gKG9iaikgPT4ge1xuICBjb25zdCBzdGFjayA9IG5ldyBBcnJheSgxMCk7XG5cbiAgY29uc3QgdmlzaXQgPSAoc291cmNlLCBpKSA9PiB7XG5cbiAgICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgaWYgKHN0YWNrLmluZGV4T2Yoc291cmNlKSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYoISgndG9KU09OJyBpbiBzb3VyY2UpKSB7XG4gICAgICAgIHN0YWNrW2ldID0gc291cmNlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBpc0FycmF5KHNvdXJjZSkgPyBbXSA6IHt9O1xuXG4gICAgICAgIGZvckVhY2goc291cmNlLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlZHVjZWRWYWx1ZSA9IHZpc2l0KHZhbHVlLCBpICsgMSk7XG4gICAgICAgICAgIWlzVW5kZWZpbmVkKHJlZHVjZWRWYWx1ZSkgJiYgKHRhcmdldFtrZXldID0gcmVkdWNlZFZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RhY2tbaV0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgcmV0dXJuIHZpc2l0KG9iaiwgMCk7XG59XG5cbmNvbnN0IGlzQXN5bmNGbiA9IGtpbmRPZlRlc3QoJ0FzeW5jRnVuY3Rpb24nKTtcblxuY29uc3QgaXNUaGVuYWJsZSA9ICh0aGluZykgPT5cbiAgdGhpbmcgJiYgKGlzT2JqZWN0KHRoaW5nKSB8fCBpc0Z1bmN0aW9uKHRoaW5nKSkgJiYgaXNGdW5jdGlvbih0aGluZy50aGVuKSAmJiBpc0Z1bmN0aW9uKHRoaW5nLmNhdGNoKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nLFxuICBpc051bWJlcixcbiAgaXNCb29sZWFuLFxuICBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQsXG4gIGlzRGF0ZSxcbiAgaXNGaWxlLFxuICBpc0Jsb2IsXG4gIGlzUmVnRXhwLFxuICBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzVHlwZWRBcnJheSxcbiAgaXNGaWxlTGlzdCxcbiAgZm9yRWFjaCxcbiAgbWVyZ2UsXG4gIGV4dGVuZCxcbiAgdHJpbSxcbiAgc3RyaXBCT00sXG4gIGluaGVyaXRzLFxuICB0b0ZsYXRPYmplY3QsXG4gIGtpbmRPZixcbiAga2luZE9mVGVzdCxcbiAgZW5kc1dpdGgsXG4gIHRvQXJyYXksXG4gIGZvckVhY2hFbnRyeSxcbiAgbWF0Y2hBbGwsXG4gIGlzSFRNTEZvcm0sXG4gIGhhc093blByb3BlcnR5LFxuICBoYXNPd25Qcm9wOiBoYXNPd25Qcm9wZXJ0eSwgLy8gYW4gYWxpYXMgdG8gYXZvaWQgRVNMaW50IG5vLXByb3RvdHlwZS1idWlsdGlucyBkZXRlY3Rpb25cbiAgcmVkdWNlRGVzY3JpcHRvcnMsXG4gIGZyZWV6ZU1ldGhvZHMsXG4gIHRvT2JqZWN0U2V0LFxuICB0b0NhbWVsQ2FzZSxcbiAgbm9vcCxcbiAgdG9GaW5pdGVOdW1iZXIsXG4gIGZpbmRLZXksXG4gIGdsb2JhbDogX2dsb2JhbCxcbiAgaXNDb250ZXh0RGVmaW5lZCxcbiAgQUxQSEFCRVQsXG4gIGdlbmVyYXRlU3RyaW5nLFxuICBpc1NwZWNDb21wbGlhbnRGb3JtLFxuICB0b0pTT05PYmplY3QsXG4gIGlzQXN5bmNGbixcbiAgaXNUaGVuYWJsZVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBBeGlvc0Vycm9yKG1lc3NhZ2UsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbiAgfVxuXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMubmFtZSA9ICdBeGlvc0Vycm9yJztcbiAgY29kZSAmJiAodGhpcy5jb2RlID0gY29kZSk7XG4gIGNvbmZpZyAmJiAodGhpcy5jb25maWcgPSBjb25maWcpO1xuICByZXF1ZXN0ICYmICh0aGlzLnJlcXVlc3QgPSByZXF1ZXN0KTtcbiAgcmVzcG9uc2UgJiYgKHRoaXMucmVzcG9uc2UgPSByZXNwb25zZSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKEF4aW9zRXJyb3IsIEVycm9yLCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHV0aWxzLnRvSlNPTk9iamVjdCh0aGlzLmNvbmZpZyksXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBzdGF0dXM6IHRoaXMucmVzcG9uc2UgJiYgdGhpcy5yZXNwb25zZS5zdGF0dXMgPyB0aGlzLnJlc3BvbnNlLnN0YXR1cyA6IG51bGxcbiAgICB9O1xuICB9XG59KTtcblxuY29uc3QgcHJvdG90eXBlID0gQXhpb3NFcnJvci5wcm90b3R5cGU7XG5jb25zdCBkZXNjcmlwdG9ycyA9IHt9O1xuXG5bXG4gICdFUlJfQkFEX09QVElPTl9WQUxVRScsXG4gICdFUlJfQkFEX09QVElPTicsXG4gICdFQ09OTkFCT1JURUQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VSUl9ORVRXT1JLJyxcbiAgJ0VSUl9GUl9UT09fTUFOWV9SRURJUkVDVFMnLFxuICAnRVJSX0RFUFJFQ0FURUQnLFxuICAnRVJSX0JBRF9SRVNQT05TRScsXG4gICdFUlJfQkFEX1JFUVVFU1QnLFxuICAnRVJSX0NBTkNFTEVEJyxcbiAgJ0VSUl9OT1RfU1VQUE9SVCcsXG4gICdFUlJfSU5WQUxJRF9VUkwnXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXS5mb3JFYWNoKGNvZGUgPT4ge1xuICBkZXNjcmlwdG9yc1tjb2RlXSA9IHt2YWx1ZTogY29kZX07XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQXhpb3NFcnJvciwgZGVzY3JpcHRvcnMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ2lzQXhpb3NFcnJvcicsIHt2YWx1ZTogdHJ1ZX0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuQXhpb3NFcnJvci5mcm9tID0gKGVycm9yLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlLCBjdXN0b21Qcm9wcykgPT4ge1xuICBjb25zdCBheGlvc0Vycm9yID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuXG4gIHV0aWxzLnRvRmxhdE9iamVjdChlcnJvciwgYXhpb3NFcnJvciwgZnVuY3Rpb24gZmlsdGVyKG9iaikge1xuICAgIHJldHVybiBvYmogIT09IEVycm9yLnByb3RvdHlwZTtcbiAgfSwgcHJvcCA9PiB7XG4gICAgcmV0dXJuIHByb3AgIT09ICdpc0F4aW9zRXJyb3InO1xuICB9KTtcblxuICBBeGlvc0Vycm9yLmNhbGwoYXhpb3NFcnJvciwgZXJyb3IubWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSk7XG5cbiAgYXhpb3NFcnJvci5jYXVzZSA9IGVycm9yO1xuXG4gIGF4aW9zRXJyb3IubmFtZSA9IGVycm9yLm5hbWU7XG5cbiAgY3VzdG9tUHJvcHMgJiYgT2JqZWN0LmFzc2lnbihheGlvc0Vycm9yLCBjdXN0b21Qcm9wcyk7XG5cbiAgcmV0dXJuIGF4aW9zRXJyb3I7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvc0Vycm9yO1xuIiwgIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzdHJpY3RcbmV4cG9ydCBkZWZhdWx0IG51bGw7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbi8vIHRlbXBvcmFyeSBob3RmaXggdG8gYXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlcyB1bnRpbCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBpcyByZWZhY3RvcmVkXG5pbXBvcnQgUGxhdGZvcm1Gb3JtRGF0YSBmcm9tICcuLi9wbGF0Zm9ybS9ub2RlL2NsYXNzZXMvRm9ybURhdGEuanMnO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHRoaW5nIGlzIGEgYXJyYXkgb3IganMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGluZyAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgdmlzaXRlZC5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWaXNpdGFibGUodGhpbmcpIHtcbiAgcmV0dXJuIHV0aWxzLmlzUGxhaW5PYmplY3QodGhpbmcpIHx8IHV0aWxzLmlzQXJyYXkodGhpbmcpO1xufVxuXG4vKipcbiAqIEl0IHJlbW92ZXMgdGhlIGJyYWNrZXRzIGZyb20gdGhlIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBwYXJhbWV0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGtleSB3aXRob3V0IHRoZSBicmFja2V0cy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQnJhY2tldHMoa2V5KSB7XG4gIHJldHVybiB1dGlscy5lbmRzV2l0aChrZXksICdbXScpID8ga2V5LnNsaWNlKDAsIC0yKSA6IGtleTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhdGgsIGEga2V5LCBhbmQgYSBib29sZWFuLCBhbmQgcmV0dXJucyBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZG90cyAtIElmIHRydWUsIHRoZSBrZXkgd2lsbCBiZSByZW5kZXJlZCB3aXRoIGRvdHMgaW5zdGVhZCBvZiBicmFja2V0cy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpIHtcbiAgaWYgKCFwYXRoKSByZXR1cm4ga2V5O1xuICByZXR1cm4gcGF0aC5jb25jYXQoa2V5KS5tYXAoZnVuY3Rpb24gZWFjaCh0b2tlbiwgaSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHRva2VuID0gcmVtb3ZlQnJhY2tldHModG9rZW4pO1xuICAgIHJldHVybiAhZG90cyAmJiBpID8gJ1snICsgdG9rZW4gKyAnXScgOiB0b2tlbjtcbiAgfSkuam9pbihkb3RzID8gJy4nIDogJycpO1xufVxuXG4vKipcbiAqIElmIHRoZSBhcnJheSBpcyBhbiBhcnJheSBhbmQgbm9uZSBvZiBpdHMgZWxlbWVudHMgYXJlIHZpc2l0YWJsZSwgdGhlbiBpdCdzIGEgZmxhdCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGFyciAtIFRoZSBhcnJheSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZsYXRBcnJheShhcnIpIHtcbiAgcmV0dXJuIHV0aWxzLmlzQXJyYXkoYXJyKSAmJiAhYXJyLnNvbWUoaXNWaXNpdGFibGUpO1xufVxuXG5jb25zdCBwcmVkaWNhdGVzID0gdXRpbHMudG9GbGF0T2JqZWN0KHV0aWxzLCB7fSwgbnVsbCwgZnVuY3Rpb24gZmlsdGVyKHByb3ApIHtcbiAgcmV0dXJuIC9eaXNbQS1aXS8udGVzdChwcm9wKTtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSBkYXRhIG9iamVjdCB0byBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7P09iamVjdH0gW2Zvcm1EYXRhXVxuICogQHBhcmFtIHs/T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnZpc2l0b3JdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1ldGFUb2tlbnMgPSB0cnVlXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb3RzID0gZmFsc2VdXG4gKiBAcGFyYW0gez9Cb29sZWFufSBbb3B0aW9ucy5pbmRleGVzID0gZmFsc2VdXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqKi9cblxuLyoqXG4gKiBJdCBjb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIEZvcm1EYXRhIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PGFueSwgYW55Pn0gb2JqIC0gVGhlIG9iamVjdCB0byBjb252ZXJ0IHRvIGZvcm0gZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtRGF0YSAtIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gYXBwZW5kIHRvLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRpb25zXG4gKlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gdG9Gb3JtRGF0YShvYmosIGZvcm1EYXRhLCBvcHRpb25zKSB7XG4gIGlmICghdXRpbHMuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGZvcm1EYXRhID0gZm9ybURhdGEgfHwgbmV3IChQbGF0Zm9ybUZvcm1EYXRhIHx8IEZvcm1EYXRhKSgpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBvcHRpb25zID0gdXRpbHMudG9GbGF0T2JqZWN0KG9wdGlvbnMsIHtcbiAgICBtZXRhVG9rZW5zOiB0cnVlLFxuICAgIGRvdHM6IGZhbHNlLFxuICAgIGluZGV4ZXM6IGZhbHNlXG4gIH0sIGZhbHNlLCBmdW5jdGlvbiBkZWZpbmVkKG9wdGlvbiwgc291cmNlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgcmV0dXJuICF1dGlscy5pc1VuZGVmaW5lZChzb3VyY2Vbb3B0aW9uXSk7XG4gIH0pO1xuXG4gIGNvbnN0IG1ldGFUb2tlbnMgPSBvcHRpb25zLm1ldGFUb2tlbnM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICBjb25zdCB2aXNpdG9yID0gb3B0aW9ucy52aXNpdG9yIHx8IGRlZmF1bHRWaXNpdG9yO1xuICBjb25zdCBkb3RzID0gb3B0aW9ucy5kb3RzO1xuICBjb25zdCBpbmRleGVzID0gb3B0aW9ucy5pbmRleGVzO1xuICBjb25zdCBfQmxvYiA9IG9wdGlvbnMuQmxvYiB8fCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgQmxvYjtcbiAgY29uc3QgdXNlQmxvYiA9IF9CbG9iICYmIHV0aWxzLmlzU3BlY0NvbXBsaWFudEZvcm0oZm9ybURhdGEpO1xuXG4gIGlmICghdXRpbHMuaXNGdW5jdGlvbih2aXNpdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Zpc2l0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAnJztcblxuICAgIGlmICh1dGlscy5pc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoIXVzZUJsb2IgJiYgdXRpbHMuaXNCbG9iKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ0Jsb2IgaXMgbm90IHN1cHBvcnRlZC4gVXNlIGEgQnVmZmVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIodmFsdWUpIHx8IHV0aWxzLmlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB1c2VCbG9iICYmIHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nID8gbmV3IEJsb2IoW3ZhbHVlXSkgOiBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmlzaXRvci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleVxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZ3xOdW1iZXI+fSBwYXRoXG4gICAqIEB0aGlzIHtGb3JtRGF0YX1cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybiB0cnVlIHRvIHZpc2l0IHRoZSBlYWNoIHByb3Agb2YgdGhlIHZhbHVlIHJlY3Vyc2l2ZWx5XG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0VmlzaXRvcih2YWx1ZSwga2V5LCBwYXRoKSB7XG4gICAgbGV0IGFyciA9IHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICYmICFwYXRoICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh1dGlscy5lbmRzV2l0aChrZXksICd7fScpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBrZXkgPSBtZXRhVG9rZW5zID8ga2V5IDoga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKHV0aWxzLmlzQXJyYXkodmFsdWUpICYmIGlzRmxhdEFycmF5KHZhbHVlKSkgfHxcbiAgICAgICAgKCh1dGlscy5pc0ZpbGVMaXN0KHZhbHVlKSB8fCB1dGlscy5lbmRzV2l0aChrZXksICdbXScpKSAmJiAoYXJyID0gdXRpbHMudG9BcnJheSh2YWx1ZSkpXG4gICAgICAgICkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGtleSA9IHJlbW92ZUJyYWNrZXRzKGtleSk7XG5cbiAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gZWFjaChlbCwgaW5kZXgpIHtcbiAgICAgICAgICAhKHV0aWxzLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgZm9ybURhdGEuYXBwZW5kKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBpbmRleGVzID09PSB0cnVlID8gcmVuZGVyS2V5KFtrZXldLCBpbmRleCwgZG90cykgOiAoaW5kZXhlcyA9PT0gbnVsbCA/IGtleSA6IGtleSArICdbXScpLFxuICAgICAgICAgICAgY29udmVydFZhbHVlKGVsKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzVmlzaXRhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9ybURhdGEuYXBwZW5kKHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpLCBjb252ZXJ0VmFsdWUodmFsdWUpKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHN0YWNrID0gW107XG5cbiAgY29uc3QgZXhwb3NlZEhlbHBlcnMgPSBPYmplY3QuYXNzaWduKHByZWRpY2F0ZXMsIHtcbiAgICBkZWZhdWx0VmlzaXRvcixcbiAgICBjb252ZXJ0VmFsdWUsXG4gICAgaXNWaXNpdGFibGVcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYnVpbGQodmFsdWUsIHBhdGgpIHtcbiAgICBpZiAodXRpbHMuaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XG5cbiAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkIGluICcgKyBwYXRoLmpvaW4oJy4nKSk7XG4gICAgfVxuXG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XG5cbiAgICB1dGlscy5mb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiBlYWNoKGVsLCBrZXkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9ICEodXRpbHMuaXNVbmRlZmluZWQoZWwpIHx8IGVsID09PSBudWxsKSAmJiB2aXNpdG9yLmNhbGwoXG4gICAgICAgIGZvcm1EYXRhLCBlbCwgdXRpbHMuaXNTdHJpbmcoa2V5KSA/IGtleS50cmltKCkgOiBrZXksIHBhdGgsIGV4cG9zZWRIZWxwZXJzXG4gICAgICApO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgIGJ1aWxkKGVsLCBwYXRoID8gcGF0aC5jb25jYXQoa2V5KSA6IFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgYnVpbGQob2JqKTtcblxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvRm9ybURhdGE7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL3RvRm9ybURhdGEuanMnO1xuXG4vKipcbiAqIEl0IGVuY29kZXMgYSBzdHJpbmcgYnkgcmVwbGFjaW5nIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBpbiB0aGUgdW5yZXNlcnZlZCBzZXQgd2l0aFxuICogdGhlaXIgcGVyY2VudC1lbmNvZGVkIGVxdWl2YWxlbnRzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHN0cikge1xuICBjb25zdCBjaGFyTWFwID0ge1xuICAgICchJzogJyUyMScsXG4gICAgXCInXCI6ICclMjcnLFxuICAgICcoJzogJyUyOCcsXG4gICAgJyknOiAnJTI5JyxcbiAgICAnfic6ICclN0UnLFxuICAgICclMjAnOiAnKycsXG4gICAgJyUwMCc6ICdcXHgwMCdcbiAgfTtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpfl18JTIwfCUwMC9nLCBmdW5jdGlvbiByZXBsYWNlcihtYXRjaCkge1xuICAgIHJldHVybiBjaGFyTWFwW21hdGNoXTtcbiAgfSk7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBwYXJhbXMgb2JqZWN0IGFuZCBjb252ZXJ0cyBpdCB0byBhIEZvcm1EYXRhIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgdG8gYmUgY29udmVydGVkIHRvIGEgRm9ybURhdGEgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB0byB0aGUgQXhpb3MgY29uc3RydWN0b3IuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIEF4aW9zVVJMU2VhcmNoUGFyYW1zKHBhcmFtcywgb3B0aW9ucykge1xuICB0aGlzLl9wYWlycyA9IFtdO1xuXG4gIHBhcmFtcyAmJiB0b0Zvcm1EYXRhKHBhcmFtcywgdGhpcywgb3B0aW9ucyk7XG59XG5cbmNvbnN0IHByb3RvdHlwZSA9IEF4aW9zVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuICB0aGlzLl9wYWlycy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xufTtcblxucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoZW5jb2Rlcikge1xuICBjb25zdCBfZW5jb2RlID0gZW5jb2RlciA/IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVuY29kZXIuY2FsbCh0aGlzLCB2YWx1ZSwgZW5jb2RlKTtcbiAgfSA6IGVuY29kZTtcblxuICByZXR1cm4gdGhpcy5fcGFpcnMubWFwKGZ1bmN0aW9uIGVhY2gocGFpcikge1xuICAgIHJldHVybiBfZW5jb2RlKHBhaXJbMF0pICsgJz0nICsgX2VuY29kZShwYWlyWzFdKTtcbiAgfSwgJycpLmpvaW4oJyYnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zVVJMU2VhcmNoUGFyYW1zO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBmcm9tICcuLi9oZWxwZXJzL0F4aW9zVVJMU2VhcmNoUGFyYW1zLmpzJztcblxuLyoqXG4gKiBJdCByZXBsYWNlcyBhbGwgaW5zdGFuY2VzIG9mIHRoZSBjaGFyYWN0ZXJzIGA6YCwgYCRgLCBgLGAsIGArYCwgYFtgLCBhbmQgYF1gIHdpdGggdGhlaXJcbiAqIFVSSSBlbmNvZGVkIGNvdW50ZXJwYXJ0c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWwgVGhlIHZhbHVlIHRvIGJlIGVuY29kZWQuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVuY29kZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcGFyYW0gez9vYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgb3B0aW9ucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIFxuICBjb25zdCBfZW5jb2RlID0gb3B0aW9ucyAmJiBvcHRpb25zLmVuY29kZSB8fCBlbmNvZGU7XG5cbiAgY29uc3Qgc2VyaWFsaXplRm4gPSBvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplO1xuXG4gIGxldCBzZXJpYWxpemVkUGFyYW1zO1xuXG4gIGlmIChzZXJpYWxpemVGbikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBzZXJpYWxpemVGbihwYXJhbXMsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSB1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpID9cbiAgICAgIHBhcmFtcy50b1N0cmluZygpIDpcbiAgICAgIG5ldyBBeGlvc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpLnRvU3RyaW5nKF9lbmNvZGUpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICBjb25zdCBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuXG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbmNsYXNzIEludGVyY2VwdG9yTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICAgKi9cbiAgdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgICAgZnVsZmlsbGVkLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBpbnRlcmNlcHRvciB3YXMgcmVtb3ZlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAgICovXG4gIGVqZWN0KGlkKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBpbnRlcmNlcHRvcnMgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVycykge1xuICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICAgKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb3JFYWNoKGZuKSB7XG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgICBmbihoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxuICBmb3JjZWRKU09OUGFyc2luZzogdHJ1ZSxcbiAgY2xhcmlmeVRpbWVvdXRFcnJvcjogZmFsc2Vcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXhpb3NVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi4vLi4vLi4vaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyc7XG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyA/IFVSTFNlYXJjaFBhcmFtcyA6IEF4aW9zVVJMU2VhcmNoUGFyYW1zO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyA/IEZvcm1EYXRhIDogbnVsbDtcbiIsICIndXNlIHN0cmljdCdcblxuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnID8gQmxvYiA6IG51bGxcbiIsICJpbXBvcnQgVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4vY2xhc3Nlcy9VUkxTZWFyY2hQYXJhbXMuanMnXG5pbXBvcnQgRm9ybURhdGEgZnJvbSAnLi9jbGFzc2VzL0Zvcm1EYXRhLmpzJ1xuaW1wb3J0IEJsb2IgZnJvbSAnLi9jbGFzc2VzL0Jsb2IuanMnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNCcm93c2VyOiB0cnVlLFxuICBjbGFzc2VzOiB7XG4gICAgVVJMU2VhcmNoUGFyYW1zLFxuICAgIEZvcm1EYXRhLFxuICAgIEJsb2JcbiAgfSxcbiAgcHJvdG9jb2xzOiBbJ2h0dHAnLCAnaHR0cHMnLCAnZmlsZScsICdibG9iJywgJ3VybCcsICdkYXRhJ11cbn07XG4iLCAiY29uc3QgaGFzQnJvd3NlckVudiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJFbnYgPSAoXG4gIChwcm9kdWN0KSA9PiB7XG4gICAgcmV0dXJuIGhhc0Jyb3dzZXJFbnYgJiYgWydSZWFjdE5hdGl2ZScsICdOYXRpdmVTY3JpcHQnLCAnTlMnXS5pbmRleE9mKHByb2R1Y3QpIDwgMFxuICB9KSh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIHdlYldvcmtlciBlbnZpcm9ubWVudFxuICpcbiAqIEFsdGhvdWdoIHRoZSBgaXNTdGFuZGFyZEJyb3dzZXJFbnZgIG1ldGhvZCBpbmRpY2F0ZXMgdGhhdFxuICogYGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyYCwgdGhlIFdlYldvcmtlciB3aWxsIHN0aWxsIGJlXG4gKiBmaWx0ZXJlZCBvdXQgZHVlIHRvIGl0cyBqdWRnbWVudCBzdGFuZGFyZFxuICogYHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdgLlxuICogVGhpcyBsZWFkcyB0byBhIHByb2JsZW0gd2hlbiBheGlvcyBwb3N0IGBGb3JtRGF0YWAgaW4gd2ViV29ya2VyXG4gKi9cbmNvbnN0IGhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudiA9ICgoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSAmJlxuICAgIHR5cGVvZiBzZWxmLmltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbidcbiAgKTtcbn0pKCk7XG5cbmV4cG9ydCB7XG4gIGhhc0Jyb3dzZXJFbnYsXG4gIGhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudixcbiAgaGFzU3RhbmRhcmRCcm93c2VyRW52XG59XG4iLCAiaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4vbm9kZS9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2NvbW1vbi91dGlscy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLi4udXRpbHMsXG4gIC4uLnBsYXRmb3JtXG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi90b0Zvcm1EYXRhLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvVVJMRW5jb2RlZEZvcm0oZGF0YSwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Gb3JtRGF0YShkYXRhLCBuZXcgcGxhdGZvcm0uY2xhc3Nlcy5VUkxTZWFyY2hQYXJhbXMoKSwgT2JqZWN0LmFzc2lnbih7XG4gICAgdmlzaXRvcjogZnVuY3Rpb24odmFsdWUsIGtleSwgcGF0aCwgaGVscGVycykge1xuICAgICAgaWYgKHBsYXRmb3JtLmlzTm9kZSAmJiB1dGlscy5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoa2V5LCB2YWx1ZS50b1N0cmluZygnYmFzZTY0JykpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoZWxwZXJzLmRlZmF1bHRWaXNpdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCBvcHRpb25zKSk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nIGxpa2UgYGZvb1t4XVt5XVt6XWAgYW5kIHJldHVybnMgYW4gYXJyYXkgbGlrZSBgWydmb28nLCAneCcsICd5JywgJ3onXVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdHJpbmdzLlxuICovXG5mdW5jdGlvbiBwYXJzZVByb3BQYXRoKG5hbWUpIHtcbiAgLy8gZm9vW3hdW3ldW3pdXG4gIC8vIGZvby54LnkuelxuICAvLyBmb28teC15LXpcbiAgLy8gZm9vIHggeSB6XG4gIHJldHVybiB1dGlscy5tYXRjaEFsbCgvXFx3K3xcXFsoXFx3KildL2csIG5hbWUpLm1hcChtYXRjaCA9PiB7XG4gICAgcmV0dXJuIG1hdGNoWzBdID09PSAnW10nID8gJycgOiBtYXRjaFsxXSB8fCBtYXRjaFswXTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBhcnJheSB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnIgLSBUaGUgYXJyYXkgdG8gY29udmVydCB0byBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhbmQgdmFsdWVzIGFzIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnIpIHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcnIpO1xuICBsZXQgaTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBrZXk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgb2JqW2tleV0gPSBhcnJba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgRm9ybURhdGEgb2JqZWN0IGFuZCByZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybURhdGEgVGhlIEZvcm1EYXRhIG9iamVjdCB0byBjb252ZXJ0IHRvIEpTT04uXG4gKlxuICogQHJldHVybnMge09iamVjdDxzdHJpbmcsIGFueT4gfCBudWxsfSBUaGUgY29udmVydGVkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZm9ybURhdGFUb0pTT04oZm9ybURhdGEpIHtcbiAgZnVuY3Rpb24gYnVpbGRQYXRoKHBhdGgsIHZhbHVlLCB0YXJnZXQsIGluZGV4KSB7XG4gICAgbGV0IG5hbWUgPSBwYXRoW2luZGV4KytdO1xuICAgIGNvbnN0IGlzTnVtZXJpY0tleSA9IE51bWJlci5pc0Zpbml0ZSgrbmFtZSk7XG4gICAgY29uc3QgaXNMYXN0ID0gaW5kZXggPj0gcGF0aC5sZW5ndGg7XG4gICAgbmFtZSA9ICFuYW1lICYmIHV0aWxzLmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldC5sZW5ndGggOiBuYW1lO1xuXG4gICAgaWYgKGlzTGFzdCkge1xuICAgICAgaWYgKHV0aWxzLmhhc093blByb3AodGFyZ2V0LCBuYW1lKSkge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSBbdGFyZ2V0W25hbWVdLCB2YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICFpc051bWVyaWNLZXk7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRbbmFtZV0gfHwgIXV0aWxzLmlzT2JqZWN0KHRhcmdldFtuYW1lXSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGJ1aWxkUGF0aChwYXRoLCB2YWx1ZSwgdGFyZ2V0W25hbWVdLCBpbmRleCk7XG5cbiAgICBpZiAocmVzdWx0ICYmIHV0aWxzLmlzQXJyYXkodGFyZ2V0W25hbWVdKSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gYXJyYXlUb09iamVjdCh0YXJnZXRbbmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiAhaXNOdW1lcmljS2V5O1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZm9ybURhdGEpICYmIHV0aWxzLmlzRnVuY3Rpb24oZm9ybURhdGEuZW50cmllcykpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcblxuICAgIHV0aWxzLmZvckVhY2hFbnRyeShmb3JtRGF0YSwgKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBidWlsZFBhdGgocGFyc2VQcm9wUGF0aChuYW1lKSwgdmFsdWUsIG9iaiwgMCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1EYXRhVG9KU09OO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgdHJhbnNpdGlvbmFsRGVmYXVsdHMgZnJvbSAnLi90cmFuc2l0aW9uYWwuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi4vaGVscGVycy90b0Zvcm1EYXRhLmpzJztcbmltcG9ydCB0b1VSTEVuY29kZWRGb3JtIGZyb20gJy4uL2hlbHBlcnMvdG9VUkxFbmNvZGVkRm9ybS5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IGZvcm1EYXRhVG9KU09OIGZyb20gJy4uL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nLCB0cmllcyB0byBwYXJzZSBpdCwgYW5kIGlmIGl0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBzdHJpbmdpZmllZCB2ZXJzaW9uXG4gKiBvZiB0aGUgaW5wdXRcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmF3VmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJzZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGEgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgdGhlIHJhd1ZhbHVlLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB0cmFuc2l0aW9uYWxEZWZhdWx0cyxcblxuICBhZGFwdGVyOiBbJ3hocicsICdodHRwJ10sXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXRDb250ZW50VHlwZSgpIHx8ICcnO1xuICAgIGNvbnN0IGhhc0pTT05Db250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xO1xuICAgIGNvbnN0IGlzT2JqZWN0UGF5bG9hZCA9IHV0aWxzLmlzT2JqZWN0KGRhdGEpO1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCAmJiB1dGlscy5pc0hUTUxGb3JtKGRhdGEpKSB7XG4gICAgICBkYXRhID0gbmV3IEZvcm1EYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRm9ybURhdGEgPSB1dGlscy5pc0Zvcm1EYXRhKGRhdGEpO1xuXG4gICAgaWYgKGlzRm9ybURhdGEpIHtcbiAgICAgIGlmICghaGFzSlNPTkNvbnRlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0pTT05Db250ZW50VHlwZSA/IEpTT04uc3RyaW5naWZ5KGZvcm1EYXRhVG9KU09OKGRhdGEpKSA6IGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcsIGZhbHNlKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgbGV0IGlzRmlsZUxpc3Q7XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkKSB7XG4gICAgICBpZiAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCB0aGlzLmZvcm1TZXJpYWxpemVyKS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGlzRmlsZUxpc3QgPSB1dGlscy5pc0ZpbGVMaXN0KGRhdGEpKSB8fCBjb250ZW50VHlwZS5pbmRleE9mKCdtdWx0aXBhcnQvZm9ybS1kYXRhJykgPiAtMSkge1xuICAgICAgICBjb25zdCBfRm9ybURhdGEgPSB0aGlzLmVudiAmJiB0aGlzLmVudi5Gb3JtRGF0YTtcblxuICAgICAgICByZXR1cm4gdG9Gb3JtRGF0YShcbiAgICAgICAgICBpc0ZpbGVMaXN0ID8geydmaWxlc1tdJzogZGF0YX0gOiBkYXRhLFxuICAgICAgICAgIF9Gb3JtRGF0YSAmJiBuZXcgX0Zvcm1EYXRhKCksXG4gICAgICAgICAgdGhpcy5mb3JtU2VyaWFsaXplclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc09iamVjdFBheWxvYWQgfHwgaGFzSlNPTkNvbnRlbnRUeXBlICkge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24vanNvbicsIGZhbHNlKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTYWZlbHkoZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsIHx8IGRlZmF1bHRzLnRyYW5zaXRpb25hbDtcbiAgICBjb25zdCBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgY29uc3QgSlNPTlJlcXVlc3RlZCA9IHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAoZGF0YSAmJiB1dGlscy5pc1N0cmluZyhkYXRhKSAmJiAoKGZvcmNlZEpTT05QYXJzaW5nICYmICF0aGlzLnJlc3BvbnNlVHlwZSkgfHwgSlNPTlJlcXVlc3RlZCkpIHtcbiAgICAgIGNvbnN0IHNpbGVudEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5zaWxlbnRKU09OUGFyc2luZztcbiAgICAgIGNvbnN0IHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIEpTT05SZXF1ZXN0ZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lID09PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZSwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFLCB0aGlzLCBudWxsLCB0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgZW52OiB7XG4gICAgRm9ybURhdGE6IHBsYXRmb3JtLmNsYXNzZXMuRm9ybURhdGEsXG4gICAgQmxvYjogcGxhdGZvcm0uY2xhc3Nlcy5CbG9iXG4gIH0sXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfSxcblxuICBoZWFkZXJzOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKicsXG4gICAgICAnQ29udGVudC1UeXBlJzogdW5kZWZpbmVkXG4gICAgfVxuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIChtZXRob2QpID0+IHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdHM7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbi8vIFJhd0F4aW9zSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbmNvbnN0IGlnbm9yZUR1cGxpY2F0ZU9mID0gdXRpbHMudG9PYmplY3RTZXQoW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl0pO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3SGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKlxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgcmF3SGVhZGVycyA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHt9O1xuICBsZXQga2V5O1xuICBsZXQgdmFsO1xuICBsZXQgaTtcblxuICByYXdIZWFkZXJzICYmIHJhd0hlYWRlcnMuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gbGluZS5zdWJzdHJpbmcoMCwgaSkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gbGluZS5zdWJzdHJpbmcoaSArIDEpLnRyaW0oKTtcblxuICAgIGlmICgha2V5IHx8IChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZltrZXldKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgaWYgKHBhcnNlZFtrZXldKSB7XG4gICAgICAgIHBhcnNlZFtrZXldLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gW3ZhbF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgcGFyc2VIZWFkZXJzIGZyb20gJy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzJztcblxuY29uc3QgJGludGVybmFscyA9IFN5bWJvbCgnaW50ZXJuYWxzJyk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlciAmJiBTdHJpbmcoaGVhZGVyKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHV0aWxzLmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZhbHVlKSA6IFN0cmluZyh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9rZW5zKHN0cikge1xuICBjb25zdCB0b2tlbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCB0b2tlbnNSRSA9IC8oW15cXHMsOz1dKylcXHMqKD86PVxccyooW14sO10rKSk/L2c7XG4gIGxldCBtYXRjaDtcblxuICB3aGlsZSAoKG1hdGNoID0gdG9rZW5zUkUuZXhlYyhzdHIpKSkge1xuICAgIHRva2Vuc1ttYXRjaFsxXV0gPSBtYXRjaFsyXTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmNvbnN0IGlzVmFsaWRIZWFkZXJOYW1lID0gKHN0cikgPT4gL15bLV9hLXpBLVowLTleYHx+LCEjJCUmJyorLl0rJC8udGVzdChzdHIudHJpbSgpKTtcblxuZnVuY3Rpb24gbWF0Y2hIZWFkZXJWYWx1ZShjb250ZXh0LCB2YWx1ZSwgaGVhZGVyLCBmaWx0ZXIsIGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICBpZiAodXRpbHMuaXNGdW5jdGlvbihmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKHRoaXMsIHZhbHVlLCBoZWFkZXIpO1xuICB9XG5cbiAgaWYgKGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICAgIHZhbHVlID0gaGVhZGVyO1xuICB9XG5cbiAgaWYgKCF1dGlscy5pc1N0cmluZyh2YWx1ZSkpIHJldHVybjtcblxuICBpZiAodXRpbHMuaXNTdHJpbmcoZmlsdGVyKSkge1xuICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKGZpbHRlcikgIT09IC0xO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzUmVnRXhwKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLnRlc3QodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhlYWRlcihoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlci50cmltKClcbiAgICAudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8oW2EtelxcZF0pKFxcdyopL2csICh3LCBjaGFyLCBzdHIpID0+IHtcbiAgICAgIHJldHVybiBjaGFyLnRvVXBwZXJDYXNlKCkgKyBzdHI7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQWNjZXNzb3JzKG9iaiwgaGVhZGVyKSB7XG4gIGNvbnN0IGFjY2Vzc29yTmFtZSA9IHV0aWxzLnRvQ2FtZWxDYXNlKCcgJyArIGhlYWRlcik7XG5cbiAgWydnZXQnLCAnc2V0JywgJ2hhcyddLmZvckVhY2gobWV0aG9kTmFtZSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbWV0aG9kTmFtZSArIGFjY2Vzc29yTmFtZSwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCBoZWFkZXIsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cblxuY2xhc3MgQXhpb3NIZWFkZXJzIHtcbiAgY29uc3RydWN0b3IoaGVhZGVycykge1xuICAgIGhlYWRlcnMgJiYgdGhpcy5zZXQoaGVhZGVycyk7XG4gIH1cblxuICBzZXQoaGVhZGVyLCB2YWx1ZU9yUmV3cml0ZSwgcmV3cml0ZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gc2V0SGVhZGVyKF92YWx1ZSwgX2hlYWRlciwgX3Jld3JpdGUpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghbEhlYWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hlYWRlciBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkoc2VsZiwgbEhlYWRlcik7XG5cbiAgICAgIGlmKCFrZXkgfHwgc2VsZltrZXldID09PSB1bmRlZmluZWQgfHwgX3Jld3JpdGUgPT09IHRydWUgfHwgKF9yZXdyaXRlID09PSB1bmRlZmluZWQgJiYgc2VsZltrZXldICE9PSBmYWxzZSkpIHtcbiAgICAgICAgc2VsZltrZXkgfHwgX2hlYWRlcl0gPSBub3JtYWxpemVWYWx1ZShfdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNldEhlYWRlcnMgPSAoaGVhZGVycywgX3Jld3JpdGUpID0+XG4gICAgICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIChfdmFsdWUsIF9oZWFkZXIpID0+IHNldEhlYWRlcihfdmFsdWUsIF9oZWFkZXIsIF9yZXdyaXRlKSk7XG5cbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChoZWFkZXIpIHx8IGhlYWRlciBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgIHNldEhlYWRlcnMoaGVhZGVyLCB2YWx1ZU9yUmV3cml0ZSlcbiAgICB9IGVsc2UgaWYodXRpbHMuaXNTdHJpbmcoaGVhZGVyKSAmJiAoaGVhZGVyID0gaGVhZGVyLnRyaW0oKSkgJiYgIWlzVmFsaWRIZWFkZXJOYW1lKGhlYWRlcikpIHtcbiAgICAgIHNldEhlYWRlcnMocGFyc2VIZWFkZXJzKGhlYWRlciksIHZhbHVlT3JSZXdyaXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyICE9IG51bGwgJiYgc2V0SGVhZGVyKHZhbHVlT3JSZXdyaXRlLCBoZWFkZXIsIHJld3JpdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KGhlYWRlciwgcGFyc2VyKSB7XG4gICAgaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKGhlYWRlcik7XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHRoaXMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2tleV07XG5cbiAgICAgICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5zKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhcnNlcikpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmNhbGwodGhpcywgdmFsdWUsIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNSZWdFeHAocGFyc2VyKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuZXhlYyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJzZXIgbXVzdCBiZSBib29sZWFufHJlZ2V4cHxmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhcyhoZWFkZXIsIG1hdGNoZXIpIHtcbiAgICBoZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoaGVhZGVyKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcblxuICAgICAgcmV0dXJuICEhKGtleSAmJiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlcikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBkZWxldGUoaGVhZGVyLCBtYXRjaGVyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUhlYWRlcihfaGVhZGVyKSB7XG4gICAgICBfaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoX2hlYWRlcikge1xuICAgICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHNlbGYsIF9oZWFkZXIpO1xuXG4gICAgICAgIGlmIChrZXkgJiYgKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUoc2VsZiwgc2VsZltrZXldLCBrZXksIG1hdGNoZXIpKSkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XG5cbiAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5KGhlYWRlcikpIHtcbiAgICAgIGhlYWRlci5mb3JFYWNoKGRlbGV0ZUhlYWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZUhlYWRlcihoZWFkZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWxldGVkO1xuICB9XG5cbiAgY2xlYXIobWF0Y2hlcikge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlciwgdHJ1ZSkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBub3JtYWxpemUoZm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuXG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLCAodmFsdWUsIGhlYWRlcikgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleShoZWFkZXJzLCBoZWFkZXIpO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHNlbGZba2V5XSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub3JtYWxpemVkID0gZm9ybWF0ID8gZm9ybWF0SGVhZGVyKGhlYWRlcikgOiBTdHJpbmcoaGVhZGVyKS50cmltKCk7XG5cbiAgICAgIGlmIChub3JtYWxpemVkICE9PSBoZWFkZXIpIHtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgIH1cblxuICAgICAgc2VsZltub3JtYWxpemVkXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcblxuICAgICAgaGVhZGVyc1tub3JtYWxpemVkXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbmNhdCguLi50YXJnZXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY29uY2F0KHRoaXMsIC4uLnRhcmdldHMpO1xuICB9XG5cbiAgdG9KU09OKGFzU3RyaW5ncykge1xuICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB1dGlscy5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSAmJiAob2JqW2hlYWRlcl0gPSBhc1N0cmluZ3MgJiYgdXRpbHMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsICcpIDogdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy50b0pTT04oKSkubWFwKChbaGVhZGVyLCB2YWx1ZV0pID0+IGhlYWRlciArICc6ICcgKyB2YWx1ZSkuam9pbignXFxuJyk7XG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdBeGlvc0hlYWRlcnMnO1xuICB9XG5cbiAgc3RhdGljIGZyb20odGhpbmcpIHtcbiAgICByZXR1cm4gdGhpbmcgaW5zdGFuY2VvZiB0aGlzID8gdGhpbmcgOiBuZXcgdGhpcyh0aGluZyk7XG4gIH1cblxuICBzdGF0aWMgY29uY2F0KGZpcnN0LCAuLi50YXJnZXRzKSB7XG4gICAgY29uc3QgY29tcHV0ZWQgPSBuZXcgdGhpcyhmaXJzdCk7XG5cbiAgICB0YXJnZXRzLmZvckVhY2goKHRhcmdldCkgPT4gY29tcHV0ZWQuc2V0KHRhcmdldCkpO1xuXG4gICAgcmV0dXJuIGNvbXB1dGVkO1xuICB9XG5cbiAgc3RhdGljIGFjY2Vzc29yKGhlYWRlcikge1xuICAgIGNvbnN0IGludGVybmFscyA9IHRoaXNbJGludGVybmFsc10gPSAodGhpc1skaW50ZXJuYWxzXSA9IHtcbiAgICAgIGFjY2Vzc29yczoge31cbiAgICB9KTtcblxuICAgIGNvbnN0IGFjY2Vzc29ycyA9IGludGVybmFscy5hY2Nlc3NvcnM7XG4gICAgY29uc3QgcHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVBY2Nlc3NvcihfaGVhZGVyKSB7XG4gICAgICBjb25zdCBsSGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoIWFjY2Vzc29yc1tsSGVhZGVyXSkge1xuICAgICAgICBidWlsZEFjY2Vzc29ycyhwcm90b3R5cGUsIF9oZWFkZXIpO1xuICAgICAgICBhY2Nlc3NvcnNbbEhlYWRlcl0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzLmlzQXJyYXkoaGVhZGVyKSA/IGhlYWRlci5mb3JFYWNoKGRlZmluZUFjY2Vzc29yKSA6IGRlZmluZUFjY2Vzc29yKGhlYWRlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5BeGlvc0hlYWRlcnMuYWNjZXNzb3IoWydDb250ZW50LVR5cGUnLCAnQ29udGVudC1MZW5ndGgnLCAnQWNjZXB0JywgJ0FjY2VwdC1FbmNvZGluZycsICdVc2VyLUFnZW50JywgJ0F1dGhvcml6YXRpb24nXSk7XG5cbi8vIHJlc2VydmVkIG5hbWVzIGhvdGZpeFxudXRpbHMucmVkdWNlRGVzY3JpcHRvcnMoQXhpb3NIZWFkZXJzLnByb3RvdHlwZSwgKHt2YWx1ZX0sIGtleSkgPT4ge1xuICBsZXQgbWFwcGVkID0ga2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7IC8vIG1hcCBgc2V0YCA9PiBgU2V0YFxuICByZXR1cm4ge1xuICAgIGdldDogKCkgPT4gdmFsdWUsXG4gICAgc2V0KGhlYWRlclZhbHVlKSB7XG4gICAgICB0aGlzW21hcHBlZF0gPSBoZWFkZXJWYWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG51dGlscy5mcmVlemVNZXRob2RzKEF4aW9zSGVhZGVycyk7XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zSGVhZGVycztcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHBhcmFtIHs/T2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2Ugb2JqZWN0XG4gKlxuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGZucywgcmVzcG9uc2UpIHtcbiAgY29uc3QgY29uZmlnID0gdGhpcyB8fCBkZWZhdWx0cztcbiAgY29uc3QgY29udGV4dCA9IHJlc3BvbnNlIHx8IGNvbmZpZztcbiAgY29uc3QgaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGNvbnRleHQuaGVhZGVycyk7XG4gIGxldCBkYXRhID0gY29udGV4dC5kYXRhO1xuXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4uY2FsbChjb25maWcsIGRhdGEsIGhlYWRlcnMubm9ybWFsaXplKCksIHJlc3BvbnNlID8gcmVzcG9uc2Uuc3RhdHVzIDogdW5kZWZpbmVkKTtcbiAgfSk7XG5cbiAgaGVhZGVycy5ub3JtYWxpemUoKTtcblxuICByZXR1cm4gZGF0YTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEEgYENhbmNlbGVkRXJyb3JgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3Q9fSByZXF1ZXN0IFRoZSByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm5zIHtDYW5jZWxlZEVycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsZWRFcnJvcihtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gIEF4aW9zRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlID09IG51bGwgPyAnY2FuY2VsZWQnIDogbWVzc2FnZSwgQXhpb3NFcnJvci5FUlJfQ0FOQ0VMRUQsIGNvbmZpZywgcmVxdWVzdCk7XG4gIHRoaXMubmFtZSA9ICdDYW5jZWxlZEVycm9yJztcbn1cblxudXRpbHMuaW5oZXJpdHMoQ2FuY2VsZWRFcnJvciwgQXhpb3NFcnJvciwge1xuICBfX0NBTkNFTF9fOiB0cnVlXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FuY2VsZWRFcnJvcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4vQXhpb3NFcnJvci5qcyc7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybnMge29iamVjdH0gVGhlIHJlc3BvbnNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICBjb25zdCB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgW0F4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0VdW01hdGguZmxvb3IocmVzcG9uc2Uuc3RhdHVzIC8gMTAwKSAtIDRdLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICB7XG4gICAgd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICBjb25zdCBjb29raWUgPSBbbmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSldO1xuXG4gICAgICB1dGlscy5pc051bWJlcihleHBpcmVzKSAmJiBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG5cbiAgICAgIHV0aWxzLmlzU3RyaW5nKHBhdGgpICYmIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcblxuICAgICAgdXRpbHMuaXNTdHJpbmcoZG9tYWluKSAmJiBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuXG4gICAgICBzZWN1cmUgPT09IHRydWUgJiYgY29va2llLnB1c2goJ3NlY3VyZScpO1xuXG4gICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICB9LFxuXG4gICAgcmVhZChuYW1lKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgIH0sXG5cbiAgICByZW1vdmUobmFtZSkge1xuICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICB9XG4gIH1cblxuICA6XG5cbiAgLy8gTm9uLXN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICB7XG4gICAgd3JpdGUoKSB7fSxcbiAgICByZWFkKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICByZW1vdmUoKSB7fVxuICB9O1xuXG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZCtcXC0uXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBpc0Fic29sdXRlVVJMIGZyb20gJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyc7XG5pbXBvcnQgY29tYmluZVVSTHMgZnJvbSAnLi4vaGVscGVycy9jb21iaW5lVVJMcy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCkge1xuICBpZiAoYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudiA/XG5cbi8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgY29uc3QgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgY29uc3QgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgbGV0IG9yaWdpblVSTDtcblxuICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXRzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgIGxldCBocmVmID0gdXJsO1xuXG4gICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgIH1cblxuICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VQcm90b2NvbCh1cmwpIHtcbiAgY29uc3QgbWF0Y2ggPSAvXihbLStcXHddezEsMjV9KSg6P1xcL1xcL3w6KS8uZXhlYyh1cmwpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBkYXRhIG1heFJhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2FtcGxlc0NvdW50PSAxMF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWluPSAxMDAwXVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBzcGVlZG9tZXRlcihzYW1wbGVzQ291bnQsIG1pbikge1xuICBzYW1wbGVzQ291bnQgPSBzYW1wbGVzQ291bnQgfHwgMTA7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IEFycmF5KHNhbXBsZXNDb3VudCk7XG4gIGNvbnN0IHRpbWVzdGFtcHMgPSBuZXcgQXJyYXkoc2FtcGxlc0NvdW50KTtcbiAgbGV0IGhlYWQgPSAwO1xuICBsZXQgdGFpbCA9IDA7XG4gIGxldCBmaXJzdFNhbXBsZVRTO1xuXG4gIG1pbiA9IG1pbiAhPT0gdW5kZWZpbmVkID8gbWluIDogMTAwMDtcblxuICByZXR1cm4gZnVuY3Rpb24gcHVzaChjaHVua0xlbmd0aCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBjb25zdCBzdGFydGVkQXQgPSB0aW1lc3RhbXBzW3RhaWxdO1xuXG4gICAgaWYgKCFmaXJzdFNhbXBsZVRTKSB7XG4gICAgICBmaXJzdFNhbXBsZVRTID0gbm93O1xuICAgIH1cblxuICAgIGJ5dGVzW2hlYWRdID0gY2h1bmtMZW5ndGg7XG4gICAgdGltZXN0YW1wc1toZWFkXSA9IG5vdztcblxuICAgIGxldCBpID0gdGFpbDtcbiAgICBsZXQgYnl0ZXNDb3VudCA9IDA7XG5cbiAgICB3aGlsZSAoaSAhPT0gaGVhZCkge1xuICAgICAgYnl0ZXNDb3VudCArPSBieXRlc1tpKytdO1xuICAgICAgaSA9IGkgJSBzYW1wbGVzQ291bnQ7XG4gICAgfVxuXG4gICAgaGVhZCA9IChoZWFkICsgMSkgJSBzYW1wbGVzQ291bnQ7XG5cbiAgICBpZiAoaGVhZCA9PT0gdGFpbCkge1xuICAgICAgdGFpbCA9ICh0YWlsICsgMSkgJSBzYW1wbGVzQ291bnQ7XG4gICAgfVxuXG4gICAgaWYgKG5vdyAtIGZpcnN0U2FtcGxlVFMgPCBtaW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYXNzZWQgPSBzdGFydGVkQXQgJiYgbm93IC0gc3RhcnRlZEF0O1xuXG4gICAgcmV0dXJuIHBhc3NlZCA/IE1hdGgucm91bmQoYnl0ZXNDb3VudCAqIDEwMDAgLyBwYXNzZWQpIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzcGVlZG9tZXRlcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBzZXR0bGUgZnJvbSAnLi8uLi9jb3JlL3NldHRsZS5qcyc7XG5pbXBvcnQgY29va2llcyBmcm9tICcuLy4uL2hlbHBlcnMvY29va2llcy5qcyc7XG5pbXBvcnQgYnVpbGRVUkwgZnJvbSAnLi8uLi9oZWxwZXJzL2J1aWxkVVJMLmpzJztcbmltcG9ydCBidWlsZEZ1bGxQYXRoIGZyb20gJy4uL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyc7XG5pbXBvcnQgaXNVUkxTYW1lT3JpZ2luIGZyb20gJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMnO1xuaW1wb3J0IHRyYW5zaXRpb25hbERlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IHBhcnNlUHJvdG9jb2wgZnJvbSAnLi4vaGVscGVycy9wYXJzZVByb3RvY29sLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcbmltcG9ydCBzcGVlZG9tZXRlciBmcm9tICcuLi9oZWxwZXJzL3NwZWVkb21ldGVyLmpzJztcblxuZnVuY3Rpb24gcHJvZ3Jlc3NFdmVudFJlZHVjZXIobGlzdGVuZXIsIGlzRG93bmxvYWRTdHJlYW0pIHtcbiAgbGV0IGJ5dGVzTm90aWZpZWQgPSAwO1xuICBjb25zdCBfc3BlZWRvbWV0ZXIgPSBzcGVlZG9tZXRlcig1MCwgMjUwKTtcblxuICByZXR1cm4gZSA9PiB7XG4gICAgY29uc3QgbG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgY29uc3QgdG90YWwgPSBlLmxlbmd0aENvbXB1dGFibGUgPyBlLnRvdGFsIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHByb2dyZXNzQnl0ZXMgPSBsb2FkZWQgLSBieXRlc05vdGlmaWVkO1xuICAgIGNvbnN0IHJhdGUgPSBfc3BlZWRvbWV0ZXIocHJvZ3Jlc3NCeXRlcyk7XG4gICAgY29uc3QgaW5SYW5nZSA9IGxvYWRlZCA8PSB0b3RhbDtcblxuICAgIGJ5dGVzTm90aWZpZWQgPSBsb2FkZWQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbG9hZGVkLFxuICAgICAgdG90YWwsXG4gICAgICBwcm9ncmVzczogdG90YWwgPyAobG9hZGVkIC8gdG90YWwpIDogdW5kZWZpbmVkLFxuICAgICAgYnl0ZXM6IHByb2dyZXNzQnl0ZXMsXG4gICAgICByYXRlOiByYXRlID8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGVzdGltYXRlZDogcmF0ZSAmJiB0b3RhbCAmJiBpblJhbmdlID8gKHRvdGFsIC0gbG9hZGVkKSAvIHJhdGUgOiB1bmRlZmluZWQsXG4gICAgICBldmVudDogZVxuICAgIH07XG5cbiAgICBkYXRhW2lzRG93bmxvYWRTdHJlYW0gPyAnZG93bmxvYWQnIDogJ3VwbG9hZCddID0gdHJ1ZTtcblxuICAgIGxpc3RlbmVyKGRhdGEpO1xuICB9O1xufVxuXG5jb25zdCBpc1hIUkFkYXB0ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnO1xuXG5leHBvcnQgZGVmYXVsdCBpc1hIUkFkYXB0ZXJTdXBwb3J0ZWQgJiYgZnVuY3Rpb24gKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxldCByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oY29uZmlnLmhlYWRlcnMpLm5vcm1hbGl6ZSgpO1xuICAgIGxldCB7cmVzcG9uc2VUeXBlLCB3aXRoWFNSRlRva2VufSA9IGNvbmZpZztcbiAgICBsZXQgb25DYW5jZWxlZDtcbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgICBjb25maWcuY2FuY2VsVG9rZW4udW5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuc2lnbmFsKSB7XG4gICAgICAgIGNvbmZpZy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgY29udGVudFR5cGU7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGlmIChwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgfHwgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52KSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKGZhbHNlKTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgICAgfSBlbHNlIGlmICgoY29udGVudFR5cGUgPSByZXF1ZXN0SGVhZGVycy5nZXRDb250ZW50VHlwZSgpKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gZml4IHNlbWljb2xvbiBkdXBsaWNhdGlvbiBpc3N1ZSBmb3IgUmVhY3ROYXRpdmUgRm9ybURhdGEgaW1wbGVtZW50YXRpb25cbiAgICAgICAgY29uc3QgW3R5cGUsIC4uLnRva2Vuc10gPSBjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JykubWFwKHRva2VuID0+IHRva2VuLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKFt0eXBlIHx8ICdtdWx0aXBhcnQvZm9ybS1kYXRhJywgLi4udG9rZW5zXS5qb2luKCc7ICcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgY29uc3QgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSA6ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuXG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gb25sb2FkZW5kKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShcbiAgICAgICAgJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCAmJiByZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gIXJlc3BvbnNlVHlwZSB8fCByZXNwb25zZVR5cGUgPT09ICd0ZXh0JyB8fCByZXNwb25zZVR5cGUgPT09ICdqc29uJyA/XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShmdW5jdGlvbiBfcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgZnVuY3Rpb24gX3JlamVjdChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcbiAgICAgIC8vIFVzZSBvbmxvYWRlbmQgaWYgYXZhaWxhYmxlXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZSB0byBlbXVsYXRlIG9ubG9hZGVuZFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZGVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignTmV0d29yayBFcnJvcicsIEF4aW9zRXJyb3IuRVJSX05FVFdPUkssIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICBsZXQgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0ID8gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyA6ICd0aW1lb3V0IGV4Y2VlZGVkJztcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWwgfHwgdHJhbnNpdGlvbmFsRGVmYXVsdHM7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICB0cmFuc2l0aW9uYWwuY2xhcmlmeVRpbWVvdXRFcnJvciA/IEF4aW9zRXJyb3IuRVRJTUVET1VUIDogQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZihwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYpIHtcbiAgICAgIHdpdGhYU1JGVG9rZW4gJiYgdXRpbHMuaXNGdW5jdGlvbih3aXRoWFNSRlRva2VuKSAmJiAod2l0aFhTUkZUb2tlbiA9IHdpdGhYU1JGVG9rZW4oY29uZmlnKSk7XG5cbiAgICAgIGlmICh3aXRoWFNSRlRva2VuIHx8ICh3aXRoWFNSRlRva2VuICE9PSBmYWxzZSAmJiBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSkge1xuICAgICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgICAgY29uc3QgeHNyZlZhbHVlID0gY29uZmlnLnhzcmZIZWFkZXJOYW1lICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSAmJiBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKTtcblxuICAgICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgICAgcmVxdWVzdEhlYWRlcnMuc2V0KGNvbmZpZy54c3JmSGVhZGVyTmFtZSwgeHNyZlZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICByZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkICYmIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKG51bGwpO1xuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMudG9KU09OKCksIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBwcm9ncmVzc0V2ZW50UmVkdWNlcihjb25maWcub25Eb3dubG9hZFByb2dyZXNzLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHByb2dyZXNzRXZlbnRSZWR1Y2VyKGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbiB8fCBjb25maWcuc2lnbmFsKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgb25DYW5jZWxlZCA9IGNhbmNlbCA9PiB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCBjYW5jZWwudHlwZSA/IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZywgcmVxdWVzdCkgOiBjYW5jZWwpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuICYmIGNvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICBpZiAoY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBjb25maWcuc2lnbmFsLmFib3J0ZWQgPyBvbkNhbmNlbGVkKCkgOiBjb25maWcuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdG9jb2wgPSBwYXJzZVByb3RvY29sKGZ1bGxQYXRoKTtcblxuICAgIGlmIChwcm90b2NvbCAmJiBwbGF0Zm9ybS5wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sICcgKyBwcm90b2NvbCArICc6JywgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIGNvbmZpZykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSB8fCBudWxsKTtcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBodHRwQWRhcHRlciBmcm9tICcuL2h0dHAuanMnO1xuaW1wb3J0IHhockFkYXB0ZXIgZnJvbSAnLi94aHIuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSBcIi4uL2NvcmUvQXhpb3NFcnJvci5qc1wiO1xuXG5jb25zdCBrbm93bkFkYXB0ZXJzID0ge1xuICBodHRwOiBodHRwQWRhcHRlcixcbiAgeGhyOiB4aHJBZGFwdGVyXG59XG5cbnV0aWxzLmZvckVhY2goa25vd25BZGFwdGVycywgKGZuLCB2YWx1ZSkgPT4ge1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbmFtZScsIHt2YWx1ZX0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICdhZGFwdGVyTmFtZScsIHt2YWx1ZX0pO1xuICB9XG59KTtcblxuY29uc3QgcmVuZGVyUmVhc29uID0gKHJlYXNvbikgPT4gYC0gJHtyZWFzb259YDtcblxuY29uc3QgaXNSZXNvbHZlZEhhbmRsZSA9IChhZGFwdGVyKSA9PiB1dGlscy5pc0Z1bmN0aW9uKGFkYXB0ZXIpIHx8IGFkYXB0ZXIgPT09IG51bGwgfHwgYWRhcHRlciA9PT0gZmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0QWRhcHRlcjogKGFkYXB0ZXJzKSA9PiB7XG4gICAgYWRhcHRlcnMgPSB1dGlscy5pc0FycmF5KGFkYXB0ZXJzKSA/IGFkYXB0ZXJzIDogW2FkYXB0ZXJzXTtcblxuICAgIGNvbnN0IHtsZW5ndGh9ID0gYWRhcHRlcnM7XG4gICAgbGV0IG5hbWVPckFkYXB0ZXI7XG4gICAgbGV0IGFkYXB0ZXI7XG5cbiAgICBjb25zdCByZWplY3RlZFJlYXNvbnMgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hbWVPckFkYXB0ZXIgPSBhZGFwdGVyc1tpXTtcbiAgICAgIGxldCBpZDtcblxuICAgICAgYWRhcHRlciA9IG5hbWVPckFkYXB0ZXI7XG5cbiAgICAgIGlmICghaXNSZXNvbHZlZEhhbmRsZShuYW1lT3JBZGFwdGVyKSkge1xuICAgICAgICBhZGFwdGVyID0ga25vd25BZGFwdGVyc1soaWQgPSBTdHJpbmcobmFtZU9yQWRhcHRlcikpLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChhZGFwdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihgVW5rbm93biBhZGFwdGVyICcke2lkfSdgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWRhcHRlcikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmVqZWN0ZWRSZWFzb25zW2lkIHx8ICcjJyArIGldID0gYWRhcHRlcjtcbiAgICB9XG5cbiAgICBpZiAoIWFkYXB0ZXIpIHtcblxuICAgICAgY29uc3QgcmVhc29ucyA9IE9iamVjdC5lbnRyaWVzKHJlamVjdGVkUmVhc29ucylcbiAgICAgICAgLm1hcCgoW2lkLCBzdGF0ZV0pID0+IGBhZGFwdGVyICR7aWR9IGAgK1xuICAgICAgICAgIChzdGF0ZSA9PT0gZmFsc2UgPyAnaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQnIDogJ2lzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJ1aWxkJylcbiAgICAgICAgKTtcblxuICAgICAgbGV0IHMgPSBsZW5ndGggP1xuICAgICAgICAocmVhc29ucy5sZW5ndGggPiAxID8gJ3NpbmNlIDpcXG4nICsgcmVhc29ucy5tYXAocmVuZGVyUmVhc29uKS5qb2luKCdcXG4nKSA6ICcgJyArIHJlbmRlclJlYXNvbihyZWFzb25zWzBdKSkgOlxuICAgICAgICAnYXMgbm8gYWRhcHRlciBzcGVjaWZpZWQnO1xuXG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgYFRoZXJlIGlzIG5vIHN1aXRhYmxlIGFkYXB0ZXIgdG8gZGlzcGF0Y2ggdGhlIHJlcXVlc3QgYCArIHMsXG4gICAgICAgICdFUlJfTk9UX1NVUFBPUlQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBhZGFwdGVyO1xuICB9LFxuICBhZGFwdGVyczoga25vd25BZGFwdGVyc1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHRyYW5zZm9ybURhdGEgZnJvbSAnLi90cmFuc2Zvcm1EYXRhLmpzJztcbmltcG9ydCBpc0NhbmNlbCBmcm9tICcuLi9jYW5jZWwvaXNDYW5jZWwuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4uL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuaW1wb3J0IGFkYXB0ZXJzIGZyb20gXCIuLi9hZGFwdGVycy9hZGFwdGVycy5qc1wiO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxlZEVycm9yYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG5cbiAgaWYgKGNvbmZpZy5zaWduYWwgJiYgY29uZmlnLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgdGhyb3cgbmV3IENhbmNlbGVkRXJyb3IobnVsbCwgY29uZmlnKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIGNvbmZpZy5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oY29uZmlnLmhlYWRlcnMpO1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgaWYgKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXS5pbmRleE9mKGNvbmZpZy5tZXRob2QpICE9PSAtMSkge1xuICAgIGNvbmZpZy5oZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLCBmYWxzZSk7XG4gIH1cblxuICBjb25zdCBhZGFwdGVyID0gYWRhcHRlcnMuZ2V0QWRhcHRlcihjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyKTtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgIGNvbmZpZyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZSxcbiAgICAgIHJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShyZXNwb25zZS5oZWFkZXJzKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShyZWFzb24ucmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vQXhpb3NIZWFkZXJzLmpzXCI7XG5cbmNvbnN0IGhlYWRlcnNUb09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgaW5zdGFuY2VvZiBBeGlvc0hlYWRlcnMgPyB0aGluZy50b0pTT04oKSA6IHRoaW5nO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICBjb25zdCBjb25maWcgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSwgY2FzZWxlc3MpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlLmNhbGwoe2Nhc2VsZXNzfSwgdGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKGEsIGIsIGNhc2VsZXNzKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIsIGNhc2VsZXNzKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChhKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSwgY2FzZWxlc3MpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKGEsIGIpIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBiKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihhLCBiKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYik7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURpcmVjdEtleXMoYSwgYiwgcHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShhLCBiKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWVyZ2VNYXAgPSB7XG4gICAgdXJsOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIG1ldGhvZDogdmFsdWVGcm9tQ29uZmlnMixcbiAgICBkYXRhOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIGJhc2VVUkw6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdHJhbnNmb3JtUmVxdWVzdDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc2Zvcm1SZXNwb25zZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBwYXJhbXNTZXJpYWxpemVyOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRpbWVvdXQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdGltZW91dE1lc3NhZ2U6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgd2l0aENyZWRlbnRpYWxzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHdpdGhYU1JGVG9rZW46IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgYWRhcHRlcjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICByZXNwb25zZVR5cGU6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgeHNyZkNvb2tpZU5hbWU6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgeHNyZkhlYWRlck5hbWU6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgb25VcGxvYWRQcm9ncmVzczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBvbkRvd25sb2FkUHJvZ3Jlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgZGVjb21wcmVzczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBtYXhDb250ZW50TGVuZ3RoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG1heEJvZHlMZW5ndGg6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgYmVmb3JlUmVkaXJlY3Q6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdHJhbnNwb3J0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGh0dHBBZ2VudDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBodHRwc0FnZW50OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGNhbmNlbFRva2VuOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHNvY2tldFBhdGg6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgcmVzcG9uc2VFbmNvZGluZzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB2YWxpZGF0ZVN0YXR1czogbWVyZ2VEaXJlY3RLZXlzLFxuICAgIGhlYWRlcnM6IChhLCBiKSA9PiBtZXJnZURlZXBQcm9wZXJ0aWVzKGhlYWRlcnNUb09iamVjdChhKSwgaGVhZGVyc1RvT2JqZWN0KGIpLCB0cnVlKVxuICB9O1xuXG4gIHV0aWxzLmZvckVhY2goT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnMSwgY29uZmlnMikpLCBmdW5jdGlvbiBjb21wdXRlQ29uZmlnVmFsdWUocHJvcCkge1xuICAgIGNvbnN0IG1lcmdlID0gbWVyZ2VNYXBbcHJvcF0gfHwgbWVyZ2VEZWVwUHJvcGVydGllcztcbiAgICBjb25zdCBjb25maWdWYWx1ZSA9IG1lcmdlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0sIHByb3ApO1xuICAgICh1dGlscy5pc1VuZGVmaW5lZChjb25maWdWYWx1ZSkgJiYgbWVyZ2UgIT09IG1lcmdlRGlyZWN0S2V5cykgfHwgKGNvbmZpZ1twcm9wXSA9IGNvbmZpZ1ZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cbiIsICJleHBvcnQgY29uc3QgVkVSU0lPTiA9IFwiMS42LjJcIjsiLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4uL2Vudi9kYXRhLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5cbmNvbnN0IHZhbGlkYXRvcnMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ2Z1bmN0aW9uJywgJ3N0cmluZycsICdzeW1ib2wnXS5mb3JFYWNoKCh0eXBlLCBpKSA9PiB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG5jb25zdCBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvciAtIHNldCB0byBmYWxzZSBpZiB0aGUgdHJhbnNpdGlvbmFsIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb24gLSBkZXByZWNhdGVkIHZlcnNpb24gLyByZW1vdmVkIHNpbmNlIHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nP30gbWVzc2FnZSAtIHNvbWUgbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgaW5mb1xuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBWRVJTSU9OICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiAodmFsdWUsIG9wdCwgb3B0cykgPT4ge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCcgKyAodmVyc2lvbiA/ICcgaW4gJyArIHZlcnNpb24gOiAnJykpLFxuICAgICAgICBBeGlvc0Vycm9yLkVSUl9ERVBSRUNBVEVEXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKlxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBjb25zdCBvcHQgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYXNzZXJ0T3B0aW9ucyxcbiAgdmFsaWRhdG9yc1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBidWlsZFVSTCBmcm9tICcuLi9oZWxwZXJzL2J1aWxkVVJMLmpzJztcbmltcG9ydCBJbnRlcmNlcHRvck1hbmFnZXIgZnJvbSAnLi9JbnRlcmNlcHRvck1hbmFnZXIuanMnO1xuaW1wb3J0IGRpc3BhdGNoUmVxdWVzdCBmcm9tICcuL2Rpc3BhdGNoUmVxdWVzdC5qcyc7XG5pbXBvcnQgbWVyZ2VDb25maWcgZnJvbSAnLi9tZXJnZUNvbmZpZy5qcyc7XG5pbXBvcnQgYnVpbGRGdWxsUGF0aCBmcm9tICcuL2J1aWxkRnVsbFBhdGguanMnO1xuaW1wb3J0IHZhbGlkYXRvciBmcm9tICcuLi9oZWxwZXJzL3ZhbGlkYXRvci5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4vQXhpb3NIZWFkZXJzLmpzJztcblxuY29uc3QgdmFsaWRhdG9ycyA9IHZhbGlkYXRvci52YWxpZGF0b3JzO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5jbGFzcyBBeGlvcyB7XG4gIGNvbnN0cnVjdG9yKGluc3RhbmNlQ29uZmlnKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uZmlnT3JVcmwgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICAgKiBAcGFyYW0gez9PYmplY3R9IGNvbmZpZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gICAqL1xuICByZXF1ZXN0KGNvbmZpZ09yVXJsLCBjb25maWcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gICAgaWYgKHR5cGVvZiBjb25maWdPclVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgIGNvbmZpZy51cmwgPSBjb25maWdPclVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnID0gY29uZmlnT3JVcmwgfHwge307XG4gICAgfVxuXG4gICAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAgIGNvbnN0IHt0cmFuc2l0aW9uYWwsIHBhcmFtc1NlcmlhbGl6ZXIsIGhlYWRlcnN9ID0gY29uZmlnO1xuXG4gICAgaWYgKHRyYW5zaXRpb25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyh0cmFuc2l0aW9uYWwsIHtcbiAgICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICAgIGZvcmNlZEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxuICAgICAgICBjbGFyaWZ5VGltZW91dEVycm9yOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pXG4gICAgICB9LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ocGFyYW1zU2VyaWFsaXplcikpIHtcbiAgICAgICAgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIgPSB7XG4gICAgICAgICAgc2VyaWFsaXplOiBwYXJhbXNTZXJpYWxpemVyXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHBhcmFtc1NlcmlhbGl6ZXIsIHtcbiAgICAgICAgICBlbmNvZGU6IHZhbGlkYXRvcnMuZnVuY3Rpb24sXG4gICAgICAgICAgc2VyaWFsaXplOiB2YWxpZGF0b3JzLmZ1bmN0aW9uXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBjb25maWcubWV0aG9kXG4gICAgY29uZmlnLm1ldGhvZCA9IChjb25maWcubWV0aG9kIHx8IHRoaXMuZGVmYXVsdHMubWV0aG9kIHx8ICdnZXQnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gICAgbGV0IGNvbnRleHRIZWFkZXJzID0gaGVhZGVycyAmJiB1dGlscy5tZXJnZShcbiAgICAgIGhlYWRlcnMuY29tbW9uLFxuICAgICAgaGVhZGVyc1tjb25maWcubWV0aG9kXVxuICAgICk7XG5cbiAgICBoZWFkZXJzICYmIHV0aWxzLmZvckVhY2goXG4gICAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICAgIChtZXRob2QpID0+IHtcbiAgICAgICAgZGVsZXRlIGhlYWRlcnNbbWV0aG9kXTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuY29uY2F0KGNvbnRleHRIZWFkZXJzLCBoZWFkZXJzKTtcblxuICAgIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgICBjb25zdCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICAgIGxldCBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBsZXQgcHJvbWlzZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGxlbjtcblxuICAgIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgICBjb25zdCBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QuYmluZCh0aGlzKSwgdW5kZWZpbmVkXTtcbiAgICAgIGNoYWluLnVuc2hpZnQuYXBwbHkoY2hhaW4sIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICAgIGNoYWluLnB1c2guYXBwbHkoY2hhaW4sIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbik7XG4gICAgICBsZW4gPSBjaGFpbi5sZW5ndGg7XG5cbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbltpKytdLCBjaGFpbltpKytdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgbGVuID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoO1xuXG4gICAgbGV0IG5ld0NvbmZpZyA9IGNvbmZpZztcblxuICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGNvbnN0IG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW5baSsrXTtcbiAgICAgIGNvbnN0IG9uUmVqZWN0ZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIG9uUmVqZWN0ZWQuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0LmNhbGwodGhpcywgbmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpID0gMDtcbiAgICBsZW4gPSByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4ocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluW2krK10sIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbltpKytdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGdldFVyaShjb25maWcpIHtcbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gICAgcmV0dXJuIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcik7XG4gIH1cbn1cblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVIVFRQTWV0aG9kKGlzRm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBodHRwTWV0aG9kKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IGlzRm9ybSA/IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnXG4gICAgICAgIH0gOiB7fSxcbiAgICAgICAgdXJsLFxuICAgICAgICBkYXRhXG4gICAgICB9KSk7XG4gICAgfTtcbiAgfVxuXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZ2VuZXJhdGVIVFRQTWV0aG9kKCk7XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZCArICdGb3JtJ10gPSBnZW5lcmF0ZUhUVFBNZXRob2QodHJ1ZSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3M7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuL0NhbmNlbGVkRXJyb3IuanMnO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtDYW5jZWxUb2tlbn1cbiAqL1xuY2xhc3MgQ2FuY2VsVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG5cbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbihjYW5jZWwgPT4ge1xuICAgICAgaWYgKCF0b2tlbi5fbGlzdGVuZXJzKSByZXR1cm47XG5cbiAgICAgIGxldCBpID0gdG9rZW4uX2xpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIHRva2VuLl9saXN0ZW5lcnNbaV0oY2FuY2VsKTtcbiAgICAgIH1cbiAgICAgIHRva2VuLl9saXN0ZW5lcnMgPSBudWxsO1xuICAgIH0pO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbiA9IG9uZnVsZmlsbGVkID0+IHtcbiAgICAgIGxldCBfcmVzb2x2ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRva2VuLnN1YnNjcmliZShyZXNvbHZlKTtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSkudGhlbihvbmZ1bGZpbGxlZCk7XG5cbiAgICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gcmVqZWN0KCkge1xuICAgICAgICB0b2tlbi51bnN1YnNjcmliZShfcmVzb2x2ZSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAgICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsZWRFcnJvcihtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpO1xuICAgICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAgICovXG4gIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBjYW5jZWwgc2lnbmFsXG4gICAqL1xuXG4gIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgbGlzdGVuZXIodGhpcy5yZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW2xpc3RlbmVyXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cblxuICB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gICAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gICAqL1xuICBzdGF0aWMgc291cmNlKCkge1xuICAgIGxldCBjYW5jZWw7XG4gICAgY29uc3QgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgICAgY2FuY2VsID0gYztcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW4sXG4gICAgICBjYW5jZWxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbmNlbFRva2VuO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiB1dGlscy5pc09iamVjdChwYXlsb2FkKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufVxuIiwgImNvbnN0IEh0dHBTdGF0dXNDb2RlID0ge1xuICBDb250aW51ZTogMTAwLFxuICBTd2l0Y2hpbmdQcm90b2NvbHM6IDEwMSxcbiAgUHJvY2Vzc2luZzogMTAyLFxuICBFYXJseUhpbnRzOiAxMDMsXG4gIE9rOiAyMDAsXG4gIENyZWF0ZWQ6IDIwMSxcbiAgQWNjZXB0ZWQ6IDIwMixcbiAgTm9uQXV0aG9yaXRhdGl2ZUluZm9ybWF0aW9uOiAyMDMsXG4gIE5vQ29udGVudDogMjA0LFxuICBSZXNldENvbnRlbnQ6IDIwNSxcbiAgUGFydGlhbENvbnRlbnQ6IDIwNixcbiAgTXVsdGlTdGF0dXM6IDIwNyxcbiAgQWxyZWFkeVJlcG9ydGVkOiAyMDgsXG4gIEltVXNlZDogMjI2LFxuICBNdWx0aXBsZUNob2ljZXM6IDMwMCxcbiAgTW92ZWRQZXJtYW5lbnRseTogMzAxLFxuICBGb3VuZDogMzAyLFxuICBTZWVPdGhlcjogMzAzLFxuICBOb3RNb2RpZmllZDogMzA0LFxuICBVc2VQcm94eTogMzA1LFxuICBVbnVzZWQ6IDMwNixcbiAgVGVtcG9yYXJ5UmVkaXJlY3Q6IDMwNyxcbiAgUGVybWFuZW50UmVkaXJlY3Q6IDMwOCxcbiAgQmFkUmVxdWVzdDogNDAwLFxuICBVbmF1dGhvcml6ZWQ6IDQwMSxcbiAgUGF5bWVudFJlcXVpcmVkOiA0MDIsXG4gIEZvcmJpZGRlbjogNDAzLFxuICBOb3RGb3VuZDogNDA0LFxuICBNZXRob2ROb3RBbGxvd2VkOiA0MDUsXG4gIE5vdEFjY2VwdGFibGU6IDQwNixcbiAgUHJveHlBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA0MDcsXG4gIFJlcXVlc3RUaW1lb3V0OiA0MDgsXG4gIENvbmZsaWN0OiA0MDksXG4gIEdvbmU6IDQxMCxcbiAgTGVuZ3RoUmVxdWlyZWQ6IDQxMSxcbiAgUHJlY29uZGl0aW9uRmFpbGVkOiA0MTIsXG4gIFBheWxvYWRUb29MYXJnZTogNDEzLFxuICBVcmlUb29Mb25nOiA0MTQsXG4gIFVuc3VwcG9ydGVkTWVkaWFUeXBlOiA0MTUsXG4gIFJhbmdlTm90U2F0aXNmaWFibGU6IDQxNixcbiAgRXhwZWN0YXRpb25GYWlsZWQ6IDQxNyxcbiAgSW1BVGVhcG90OiA0MTgsXG4gIE1pc2RpcmVjdGVkUmVxdWVzdDogNDIxLFxuICBVbnByb2Nlc3NhYmxlRW50aXR5OiA0MjIsXG4gIExvY2tlZDogNDIzLFxuICBGYWlsZWREZXBlbmRlbmN5OiA0MjQsXG4gIFRvb0Vhcmx5OiA0MjUsXG4gIFVwZ3JhZGVSZXF1aXJlZDogNDI2LFxuICBQcmVjb25kaXRpb25SZXF1aXJlZDogNDI4LFxuICBUb29NYW55UmVxdWVzdHM6IDQyOSxcbiAgUmVxdWVzdEhlYWRlckZpZWxkc1Rvb0xhcmdlOiA0MzEsXG4gIFVuYXZhaWxhYmxlRm9yTGVnYWxSZWFzb25zOiA0NTEsXG4gIEludGVybmFsU2VydmVyRXJyb3I6IDUwMCxcbiAgTm90SW1wbGVtZW50ZWQ6IDUwMSxcbiAgQmFkR2F0ZXdheTogNTAyLFxuICBTZXJ2aWNlVW5hdmFpbGFibGU6IDUwMyxcbiAgR2F0ZXdheVRpbWVvdXQ6IDUwNCxcbiAgSHR0cFZlcnNpb25Ob3RTdXBwb3J0ZWQ6IDUwNSxcbiAgVmFyaWFudEFsc29OZWdvdGlhdGVzOiA1MDYsXG4gIEluc3VmZmljaWVudFN0b3JhZ2U6IDUwNyxcbiAgTG9vcERldGVjdGVkOiA1MDgsXG4gIE5vdEV4dGVuZGVkOiA1MTAsXG4gIE5ldHdvcmtBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA1MTEsXG59O1xuXG5PYmplY3QuZW50cmllcyhIdHRwU3RhdHVzQ29kZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gIEh0dHBTdGF0dXNDb2RlW3ZhbHVlXSA9IGtleTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBIdHRwU3RhdHVzQ29kZTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCBiaW5kIGZyb20gJy4vaGVscGVycy9iaW5kLmpzJztcbmltcG9ydCBBeGlvcyBmcm9tICcuL2NvcmUvQXhpb3MuanMnO1xuaW1wb3J0IG1lcmdlQ29uZmlnIGZyb20gJy4vY29yZS9tZXJnZUNvbmZpZy5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgZm9ybURhdGFUb0pTT04gZnJvbSAnLi9oZWxwZXJzL2Zvcm1EYXRhVG9KU09OLmpzJztcbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IENhbmNlbFRva2VuIGZyb20gJy4vY2FuY2VsL0NhbmNlbFRva2VuLmpzJztcbmltcG9ydCBpc0NhbmNlbCBmcm9tICcuL2NhbmNlbC9pc0NhbmNlbC5qcyc7XG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4vZW52L2RhdGEuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi9oZWxwZXJzL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IHNwcmVhZCBmcm9tICcuL2hlbHBlcnMvc3ByZWFkLmpzJztcbmltcG9ydCBpc0F4aW9zRXJyb3IgZnJvbSAnLi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuL2NvcmUvQXhpb3NIZWFkZXJzLmpzXCI7XG5pbXBvcnQgYWRhcHRlcnMgZnJvbSAnLi9hZGFwdGVycy9hZGFwdGVycy5qcyc7XG5pbXBvcnQgSHR0cFN0YXR1c0NvZGUgZnJvbSAnLi9oZWxwZXJzL0h0dHBTdGF0dXNDb2RlLmpzJztcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm5zIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICBjb25zdCBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICBjb25zdCBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0LCB7YWxsT3duS2V5czogdHJ1ZX0pO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQsIG51bGwsIHthbGxPd25LZXlzOiB0cnVlfSk7XG5cbiAgLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuICBpbnN0YW5jZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgaW5zdGFuY2VDb25maWcpKTtcbiAgfTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxuY29uc3QgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWxlZEVycm9yID0gQ2FuY2VsZWRFcnJvcjtcbmF4aW9zLkNhbmNlbFRva2VuID0gQ2FuY2VsVG9rZW47XG5heGlvcy5pc0NhbmNlbCA9IGlzQ2FuY2VsO1xuYXhpb3MuVkVSU0lPTiA9IFZFUlNJT047XG5heGlvcy50b0Zvcm1EYXRhID0gdG9Gb3JtRGF0YTtcblxuLy8gRXhwb3NlIEF4aW9zRXJyb3IgY2xhc3NcbmF4aW9zLkF4aW9zRXJyb3IgPSBBeGlvc0Vycm9yO1xuXG4vLyBhbGlhcyBmb3IgQ2FuY2VsZWRFcnJvciBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuYXhpb3MuQ2FuY2VsID0gYXhpb3MuQ2FuY2VsZWRFcnJvcjtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcblxuYXhpb3Muc3ByZWFkID0gc3ByZWFkO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSBpc0F4aW9zRXJyb3I7XG5cbi8vIEV4cG9zZSBtZXJnZUNvbmZpZ1xuYXhpb3MubWVyZ2VDb25maWcgPSBtZXJnZUNvbmZpZztcblxuYXhpb3MuQXhpb3NIZWFkZXJzID0gQXhpb3NIZWFkZXJzO1xuXG5heGlvcy5mb3JtVG9KU09OID0gdGhpbmcgPT4gZm9ybURhdGFUb0pTT04odXRpbHMuaXNIVE1MRm9ybSh0aGluZykgPyBuZXcgRm9ybURhdGEodGhpbmcpIDogdGhpbmcpO1xuXG5heGlvcy5nZXRBZGFwdGVyID0gYWRhcHRlcnMuZ2V0QWRhcHRlcjtcblxuYXhpb3MuSHR0cFN0YXR1c0NvZGUgPSBIdHRwU3RhdHVzQ29kZTtcblxuYXhpb3MuZGVmYXVsdCA9IGF4aW9zO1xuXG4vLyB0aGlzIG1vZHVsZSBzaG91bGQgb25seSBoYXZlIGEgZGVmYXVsdCBleHBvcnRcbmV4cG9ydCBkZWZhdWx0IGF4aW9zXG4iLCAiaW1wb3J0IGF4aW9zIGZyb20gJy4vbGliL2F4aW9zLmpzJztcblxuLy8gVGhpcyBtb2R1bGUgaXMgaW50ZW5kZWQgdG8gdW53cmFwIEF4aW9zIGRlZmF1bHQgZXhwb3J0IGFzIG5hbWVkLlxuLy8gS2VlcCB0b3AtbGV2ZWwgZXhwb3J0IHNhbWUgd2l0aCBzdGF0aWMgcHJvcGVydGllc1xuLy8gc28gdGhhdCBpdCBjYW4ga2VlcCBzYW1lIHdpdGggZXMgbW9kdWxlIG9yIGNqc1xuY29uc3Qge1xuICBBeGlvcyxcbiAgQXhpb3NFcnJvcixcbiAgQ2FuY2VsZWRFcnJvcixcbiAgaXNDYW5jZWwsXG4gIENhbmNlbFRva2VuLFxuICBWRVJTSU9OLFxuICBhbGwsXG4gIENhbmNlbCxcbiAgaXNBeGlvc0Vycm9yLFxuICBzcHJlYWQsXG4gIHRvRm9ybURhdGEsXG4gIEF4aW9zSGVhZGVycyxcbiAgSHR0cFN0YXR1c0NvZGUsXG4gIGZvcm1Ub0pTT04sXG4gIGdldEFkYXB0ZXIsXG4gIG1lcmdlQ29uZmlnXG59ID0gYXhpb3M7XG5cbmV4cG9ydCB7XG4gIGF4aW9zIGFzIGRlZmF1bHQsXG4gIEF4aW9zLFxuICBBeGlvc0Vycm9yLFxuICBDYW5jZWxlZEVycm9yLFxuICBpc0NhbmNlbCxcbiAgQ2FuY2VsVG9rZW4sXG4gIFZFUlNJT04sXG4gIGFsbCxcbiAgQ2FuY2VsLFxuICBpc0F4aW9zRXJyb3IsXG4gIHNwcmVhZCxcbiAgdG9Gb3JtRGF0YSxcbiAgQXhpb3NIZWFkZXJzLFxuICBIdHRwU3RhdHVzQ29kZSxcbiAgZm9ybVRvSlNPTixcbiAgZ2V0QWRhcHRlcixcbiAgbWVyZ2VDb25maWdcbn1cbiIsICJpbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCJcclxuaW1wb3J0IHsgUExVR0lOX05BTUUgfSBmcm9tIFwiLi9zdGF0aWNcIlxyXG5pbXBvcnQgeyBIaXN0b3J5RmlsZVZpZXdBY3Rpb24sICBQb2NrZXRTZXR0aW5ncyB9IGZyb20gXCJkXCJcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgUG9ja2V0IHtcclxuICBwcmVmaXg6IHN0cmluZyA9ICdzbm93Zmxha2Vfb2JzaWRpYW4nXHJcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3M/OiBQb2NrZXRTZXR0aW5ncykge1xyXG4gICAgdGhpcy5wcmVmaXggPSBzZXR0aW5ncz8ucHJlZml4IHx8IHRoaXMucHJlZml4XHJcbiAgfVxyXG4gIGdldChrZXk6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMucHJlZml4ICsga2V5KVxyXG4gIH1cclxuICBzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBudWxsKSB7XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnByZWZpeCArIGtleSwgYCR7dmFsdWV9YClcclxuICB9XHJcbiAgY2xlYXIoa2V5OiBzdHJpbmcpIHtcclxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMucHJlZml4ICsga2V5KVxyXG4gIH1cclxuICBjbGVhcl9hbGwoKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpXHJcbiAgICAgIGlmIChrZXk/LnN0YXJ0c1dpdGgodGhpcy5wcmVmaXgpKVxyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBGaWxlTWV0YURhdGEge1xyXG4gIHBhdGg6IHN0cmluZyA9ICcnXHJcbiAgY29uZmlnX2Rpcjogc3RyaW5nID0gJy5vYnNpZGlhbidcclxuICBleHRfcGF0aDogKCkgPT4gc3RyaW5nID0gKCkgPT4gYCR7dGhpcy5jb25maWdfZGlyfS9wbHVnaW5zLyR7UExVR0lOX05BTUV9YFxyXG4gIGZpbGVuYW1lOiBzdHJpbmdcclxuICBsaW5lc19saW1pdDogbnVtYmVyID0gNTAwXHJcbiAgY3VycmVudF9saW5lc19wb2ludGVyOiBudW1iZXIgPSAwXHJcbiAgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZFxyXG4gIGNvbnN0cnVjdG9yKGZpbGVuYW1lOiBzdHJpbmcsIGNvbmZpZ19kaXI6IHN0cmluZyA9ICcub2JzaWRpYW4nKSB7XHJcbiAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWVcclxuICAgIHRoaXMuY29uZmlnX2RpciA9IGNvbmZpZ19kaXJcclxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcpXHJcbiAgICAgIHRoaXMucGF0aCA9IHBhdGguam9pbih0aGlzLmV4dF9wYXRoKCksIHRoaXMuZmlsZW5hbWUpXHJcbiAgICBlbHNlXHJcbiAgICAgIHRoaXMucGF0aCA9IFt0aGlzLmV4dF9wYXRoKCksIHRoaXMuZmlsZW5hbWVdLmpvaW4oJy8nKVxyXG4gIH1cclxuICBzZXRfbWFpbl9wYXRoKCkge1xyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JylcclxuICAgICAgdGhpcy5wYXRoID0gcGF0aC5qb2luKHRoaXMuZXh0X3BhdGgoKSwgdGhpcy5maWxlbmFtZSlcclxuICAgIGVsc2VcclxuICAgICAgdGhpcy5wYXRoID0gW3RoaXMuZXh0X3BhdGgoKSwgdGhpcy5maWxlbmFtZV0uam9pbignLycpXHJcbiAgfVxyXG4gIHNldF9saW1pdChsaW1pdDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLmxpbmVzX2xpbWl0ID0gbGltaXRcclxuICB9XHJcbiAgc2V0X2NhbGxiYWNrKGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQpIHtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xyXG4gIH1cclxuICBzZXRfY29uZmlnX2Rpcihjb25maWdfZGlyOiBzdHJpbmcpIHtcclxuICAgIHRoaXMuY29uZmlnX2RpciA9IGNvbmZpZ19kaXJcclxuICB9XHJcbiAgY3JlYXRlKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXBwLnZhdWx0LmFkYXB0ZXIud3JpdGUodGhpcy5wYXRoLCAnJylcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICBjb25zb2xlLmxvZygnRXJyb3I6IFdyaXRlIEZpbGUnKVxyXG4gICAgfVxyXG4gIH1cclxuICBhc3luYyBzZXQodmFsdWU6IHN0cmluZykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgYXBwLnZhdWx0LmFkYXB0ZXIud3JpdGUodGhpcy5wYXRoLCB2YWx1ZSlcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICBjb25zb2xlLmxvZygnRXJyb3I6IFdyaXRlIEZpbGUgU3luYycpXHJcbiAgICB9XHJcbiAgfVxyXG4gIGFzeW5jIGFkZCh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBhcHAudmF1bHQuYWRhcHRlci5hcHBlbmQodGhpcy5wYXRoLCB2YWx1ZSlcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICBjb25zb2xlLmxvZygnRXJyb3I6IEFwcGVuZCBGaWxlIFN5bmMnKVxyXG4gICAgfVxyXG4gIH1cclxuICBhc3luYyBnZXQoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gYXdhaXQgYXBwLnZhdWx0LmFkYXB0ZXIucmVhZCh0aGlzLnBhdGgpXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5sb2coJ0Vycm9yOiBSZWFkIEZpbGUgU3luYyAtICcgKyBlcnIubWVzc2FnZSlcclxuICAgICAgcmV0dXJuICcnXHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqICByZXR1cm5zIGBjb3VudGAgb2YgbGluZXMgZnJvbSBgc3RhcnRgIHZhbHVlLlxyXG4gICAqIGBzdGFydGAgY291bGQgYmUgYWxzbyBsZXNzIHRoZW4gYDBgLCB0aGVuIGBjb3VudGAgd2lsbCBiZSBnZXQgYnkgdGhlIGVuZCBvZiB0aGUgZmlsZVxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSBzdGFydCBcclxuICAgKiBAcGFyYW0gY291bnQgXHJcbiAgICogQHJldHVybnMgXHJcbiovXHJcbiAgYXN5bmMgZ2V0X2xpbmVzX2J5X2luZGV4KHN0YXJ0OiBudW1iZXIsIGNvdW50PzogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy5nZXQoKVxyXG4gICAgY29uc3QgbGluZXMgPSBmaWxlLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpXHJcbiAgICBjb25zdCBsZW4gPSBsaW5lcy5sZW5ndGhcclxuICAgIGlmIChzdGFydCA+IGxlbikgcmV0dXJuIFtdXHJcbiAgICBpZiAoIWNvdW50KSBjb3VudCA9IGxlblxyXG4gICAgaWYgKHN0YXJ0IDwgMClcclxuICAgICAgc3RhcnQgPSBsZW4gKyBzdGFydFxyXG4gICAgaWYgKHN0YXJ0IDwgMClcclxuICAgICAgc3RhcnQgPSAwXHJcbiAgICBpZiAoc3RhcnQgKyBjb3VudCA+PSBsZW4pXHJcbiAgICAgIGNvdW50ID0gbGVuXHJcbiAgICBlbHNlXHJcbiAgICAgIGNvdW50ID0gc3RhcnQgKyBjb3VudFxyXG4gICAgdGhpcy5jdXJyZW50X2xpbmVzX3BvaW50ZXIgPSBsZW5cclxuXHJcbiAgICByZXR1cm4gbGluZXMuc2xpY2Uoc3RhcnQsIGNvdW50KS5maWx0ZXIoaXRlbSA9PiAhIWl0ZW0pXHJcbiAgfVxyXG4gIGFzeW5jIGdldF9saW5lc19mcm9tX3RvX3BocmFzZShwaHJhc2U6IHN0cmluZywgY291bnQ6IG51bWJlciA9IDEsIGNvbnRhaW5fcGhyYXNlID0gZmFsc2UsIHJldmVyc2U6IGJvb2xlYW4gPSB0cnVlKSB7XHJcbiAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy5nZXQoKVxyXG4gICAgY29uc3QgbGluZXMgPSBmaWxlLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLnJldmVyc2UoKVxyXG4gICAgY29uc3QgbGVuID0gbGluZXMubGVuZ3RoXHJcbiAgICBjb25zdCBsaW5lc190b19yZXR1cm4gPSBbXVxyXG4gICAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xyXG4gICAgICBpZiAobGluZS5jb250YWlucyhwaHJhc2UpKSB7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5fcGhyYXNlKVxyXG4gICAgICAgICAgbGluZXNfdG9fcmV0dXJuLnB1c2gobGluZSlcclxuICAgICAgICBjb3VudC0tXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGluZXNfdG9fcmV0dXJuLnB1c2gobGluZSlcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNvdW50ID09IDApXHJcbiAgICAgICAgYnJlYWtcclxuICAgIH1cclxuICAgIHRoaXMuY3VycmVudF9saW5lc19wb2ludGVyID0gbGVuXHJcblxyXG4gICAgcmV0dXJuIGxpbmVzX3RvX3JldHVybi5maWx0ZXIoaXRlbSA9PiAhIWl0ZW0pXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTG9nZ2VyIGV4dGVuZHMgRmlsZU1ldGFEYXRhIHtcclxuICBjb25zdHJ1Y3RvcihmaWxlbmFtZTogc3RyaW5nLCBjb25maWdfZGlyOiBzdHJpbmcgPSAnLm9ic2lkaWFuJykge1xyXG4gICAgc3VwZXIoZmlsZW5hbWUsIGNvbmZpZ19kaXIpXHJcbiAgfVxyXG4gIGFzeW5jIGNoZWNrX2xpbWl0KCkge1xyXG4gICAgaWYgKHRoaXMuY3VycmVudF9saW5lc19wb2ludGVyID4gMC45ICogdGhpcy5saW5lc19saW1pdCkge1xyXG4gICAgICBjb25zdCBzdGFydCA9IDAuMSAqIHRoaXMubGluZXNfbGltaXRcclxuICAgICAgYXdhaXQgdGhpcy5zZXQoKGF3YWl0IHRoaXMuZ2V0X2xpbmVzX2J5X2luZGV4KC1zdGFydCkpLmpvaW4oJ1xcbicpKVxyXG4gICAgICB0aGlzLmN1cnJlbnRfbGluZXNfcG9pbnRlciA9IHN0YXJ0XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBsb2cobWVzc2FnZTogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoKVxyXG4gICAgY29uc3QgZnVsbG1lc3NhZ2UgPSBgXFxuWyR7ZGF0ZS50b0xvY2FsZVN0cmluZygpLnJlcGxhY2UoJywgJywgJ3wnKX1dPlxcdCR7bWVzc2FnZX1gXHJcbiAgICBhd2FpdCB0aGlzLmFkZChmdWxsbWVzc2FnZSlcclxuICAgIGlmICh0aGlzLmNhbGxiYWNrKVxyXG4gICAgICB0aGlzLmNhbGxiYWNrKGZ1bGxtZXNzYWdlKVxyXG4gICAgdGhpcy5jdXJyZW50X2xpbmVzX3BvaW50ZXIrK1xyXG4gICAgYXdhaXQgdGhpcy5jaGVja19saW1pdCgpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgSGlzdG9yeSBleHRlbmRzIEZpbGVNZXRhRGF0YSB7XHJcbiAgbGluZXNfbGltaXQ6IG51bWJlciA9IDIwMDBcclxuICBjdXJyZW50X2xpbmVzX3BvaW50ZXI6IG51bWJlciA9IDBcclxuICBjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkXHJcbiAgY29uc3RydWN0b3IoZmlsZW5hbWU6IHN0cmluZywgY29uZmlnX2Rpcjogc3RyaW5nID0gJy5vYnNpZGlhbicpIHtcclxuICAgIHN1cGVyKGZpbGVuYW1lLCBjb25maWdfZGlyKVxyXG4gIH1cclxuICBhc3luYyBjaGVja19saW1pdCgpIHtcclxuICAgIGlmICh0aGlzLmN1cnJlbnRfbGluZXNfcG9pbnRlciA+IDAuOSAqIHRoaXMubGluZXNfbGltaXQpIHtcclxuICAgICAgY29uc3Qgc3RhcnQgPSAwLjMgKiB0aGlzLmxpbmVzX2xpbWl0XHJcbiAgICAgIGF3YWl0IHRoaXMuc2V0KChhd2FpdCB0aGlzLmdldF9saW5lc19ieV9pbmRleCgtc3RhcnQpKS5qb2luKCdcXG4nKSlcclxuICAgICAgdGhpcy5jdXJyZW50X2xpbmVzX3BvaW50ZXIgPSBzdGFydFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcGFyc2VyKGxpbmU6IHN0cmluZykge1xyXG4gICAgY29uc3QgW3RpbWUsIGFjdGlvbiwgcGF0aCwgb2xkX3BhdGhdID0gbGluZS5zcGxpdCgnXFx0JylcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRpbWUsIGFjdGlvbiwgcGF0aCwgb2xkX3BhdGhcclxuICAgIH1cclxuICB9XHJcbiAgYXN5bmMgY2xlYXIoKSB7XHJcbiAgICBhd2FpdCB0aGlzLnNldCgnJylcclxuICAgIHRoaXMuY3VycmVudF9saW5lc19wb2ludGVyID0gMFxyXG4gIH1cclxuICBhc3luYyBsb2dzX2luY2x1ZGVfcmVwZWF0cyhfYWN0aW9uOiBzdHJpbmcsIF9wYXRoOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IGxhc3RfY2hhbmdlcyA9IGF3YWl0IHRoaXMuZ2V0X2xpbmVzX2J5X2luZGV4KC0yMDApXHJcbiAgICAvLyBjaGVjayBmb3IgcHVzaCBjaGFuZ2VzIGFuZCByZXNldCAtIGNoZWNrIHJlcGVhdHNcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBsYXN0X2NoYW5nZXMucmV2ZXJzZSgpKSB7XHJcbiAgICAgIGNvbnN0IHsgYWN0aW9uLCBwYXRoIH0gPSB0aGlzLnBhcnNlcihpdGVtKVxyXG4gICAgICBpZihhY3Rpb24uc3RhcnRzV2l0aCgnTE9DQUwgQ0hBTkdFUycpKSByZXR1cm4gZmFsc2VcclxuICAgICAgaWYgKGFjdGlvbiA9PSAnTU9ESUZZJyAmJiBfYWN0aW9uID09IGFjdGlvbiAmJiBwYXRoID09IF9wYXRoKVxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbiAgYXN5bmMgYWRkX2FjdGlvbihhY3Rpb246IEhpc3RvcnlGaWxlVmlld0FjdGlvbiwgcGF0aDogc3RyaW5nLCBvbGRfcGF0aD86IHN0cmluZykge1xyXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKClcclxuICAgIGlmICgoYXdhaXQgdGhpcy5sb2dzX2luY2x1ZGVfcmVwZWF0cyhhY3Rpb24sIHBhdGgpKSkgcmV0dXJuXHJcbiAgICBjb25zdCBmdWxsbWVzc2FnZSA9IGBcXG5bJHtkYXRlLnRvTG9jYWxlU3RyaW5nKCl9XVxcdCR7YWN0aW9ufVxcdCR7cGF0aH1cXHQke29sZF9wYXRoIHx8ICdudWxsJ31gXHJcbiAgICBhd2FpdCB0aGlzLmFkZChmdWxsbWVzc2FnZSlcclxuICAgIGlmICh0aGlzLmNhbGxiYWNrKVxyXG4gICAgICB0aGlzLmNhbGxiYWNrKGZ1bGxtZXNzYWdlKVxyXG4gICAgdGhpcy5jdXJyZW50X2xpbmVzX3BvaW50ZXIrK1xyXG4gICAgYXdhaXQgdGhpcy5jaGVja19saW1pdCgpXHJcbiAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBTZXR0aW5nc1ZpZXdwb2ludCB9IGZyb20gXCJkXCI7XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogU2V0dGluZ3NWaWV3cG9pbnQgPSB7XHJcblx0dG9rZW46ICcqKioqKicsXHJcblx0dXNlcm5hbWU6ICcnLFxyXG5cdHJlcG9fbmFtZTogJycsXHJcblx0cHJvamVjdF9uYW1lOiAnJyxcclxuXHRlbWFpbDogJycsXHJcblx0YXV0bzogZmFsc2UsXHJcblx0ZmV0Y2g6IGZhbHNlLFxyXG5cdGJyYW5jaDogJ21hc3RlcicsXHJcblx0bm90aWY6IHRydWUsXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBJTlRFUlZBTF9BRlRFUl9DSEFOR0VTID0gMTVcclxuXHJcbmV4cG9ydCBjb25zdCBMT0dHRVJfRklMRSA9ICdsb2dnZXIubG9nJ1xyXG5leHBvcnQgY29uc3QgSElTVE9SWV9GSUxFID0gJ2hpc3RvcnkubG9nJ1xyXG5leHBvcnQgY29uc3QgUE9DS0VUX1RPS0VOX0tFWSA9ICdnaXRsYWJ0b2tlbidcclxuZXhwb3J0IGNvbnN0IEhJU1RPUllfVklFVyA9ICdoaXN0b3J5J1xyXG5cclxuZXhwb3J0IGNvbnN0IEdJVExBQl9BUElfVVJMID0gJ2h0dHBzOi8vZ2l0bGFiLmNvbS9hcGkvdjQnXHJcblxyXG5leHBvcnQgY29uc3QgUExVR0lOX05BTUUgPSAnb2JzaWRpYW4tc25vd2ZsYWtlJyIsICJleHBvcnQgY2xhc3MgUXVldWUge1xyXG5cdGFjdGlvbnM6ICgoKSA9PiBQcm9taXNlPGFueT4pW10gPSBbXVxyXG5cdGNvbnN0cnVjdG9yKCkgeyB9XHJcblx0YXBwZW5kKGFjdGlvbjogKCkgPT4gUHJvbWlzZTxhbnk+KSB7XHJcblx0XHR0aGlzLmFjdGlvbnMucHVzaChhY3Rpb24pXHJcblx0XHRpZiAodGhpcy5hY3Rpb25zLmxlbmd0aCA9PSAxKVxyXG5cdFx0XHR0aGlzLmFjdGlvbl9oYW5kbGUoKVxyXG5cdH1cclxuXHRhc3luYyBhY3Rpb25faGFuZGxlKCkge1xyXG5cdFx0aWYgKHRoaXMuYWN0aW9ucy5sZW5ndGggIT0gMCkge1xyXG5cdFx0XHRjb25zdCBhY3Rpb24gPSB0aGlzLmFjdGlvbnNbMF1cclxuXHRcdFx0aWYgKGFjdGlvbilcclxuXHRcdFx0XHRhd2FpdCBhY3Rpb24oKVxyXG5cdFx0XHR0aGlzLmFjdGlvbnMuc2hpZnQoKVxyXG5cdFx0XHR0aGlzLmFjdGlvbl9oYW5kbGUoKVxyXG5cdFx0fVxyXG5cdH1cclxufSIsICJpbXBvcnQgU3luY1Nub3dmbGFrZSwgeyBwb2NrZXQgfSBmcm9tIFwibWFpblwiXHJcbmltcG9ydCB7IEFwcCwgTm90aWNlLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCJcclxuXHJcbmV4cG9ydCBjbGFzcyBTbm93Zmxha2VTZXR0aW5ncyBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG5cdHBsdWdpbjogU3luY1Nub3dmbGFrZVxyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBTeW5jU25vd2ZsYWtlKSB7XHJcblx0XHRzdXBlcihhcHAsIHBsdWdpbilcclxuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luXHJcblx0fVxyXG5cclxuXHRkaXNwbGF5KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpc1xyXG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKVxyXG5cdFx0Y29uc3Qgc2V0ID0gKCkgPT4gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRzZXQoKS5zZXROYW1lKCdUb2tlbicpIFxyXG5cdFx0XHQuc2V0RGVzYygnSGVyZSBpcyBnaXRsYWIgdG9rZW4nKVxyXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHlvdXIgc2VjcmV0JylcclxuXHRcdFx0XHQuc2V0VmFsdWUoJyonLnJlcGVhdChwb2NrZXQuZ2V0KCdnaXRsYWJ0b2tlbicpPy5sZW5ndGggfHwgMCkpXHJcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0cG9ja2V0LnNldCgnZ2l0bGFidG9rZW4nLCB2YWx1ZSlcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXHJcblx0XHRcdFx0fSkpXHJcblx0XHRzZXQoKS5zZXROYW1lKCdFbWFpbCcpXHJcblx0XHRcdC5zZXREZXNjKCdIZXJlIGlzIGVtYWlsIC0gZ2l0IGNvbW1pdCcpXHJcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRW50ZXIgeW91ciBlbWFpbCcpXHJcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmVtYWlsKVxyXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmVtYWlsID0gdmFsdWVcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXHJcblx0XHRcdFx0fSkpXHJcblx0XHRzZXQoKS5zZXROYW1lKCdVc2VybmFtZScpXHJcblx0XHRcdC5zZXREZXNjKCdIZXJlIGlzIGdpdGxhYiB1c2VybmFtZSAtIGdpdCBjb21taXQnKVxyXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHlvdXIgdXNlcm5hbWUnKVxyXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VybmFtZSlcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VybmFtZSA9IHZhbHVlXHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKVxyXG5cdFx0XHRcdH0pKVxyXG5cdFx0c2V0KCkuc2V0TmFtZSgnUHJvamVjdCcpXHJcblx0XHRcdC5zZXREZXNjKCdIZXJlIGlzIGdpdGxhYiBwcm9qZWN0IG5hbWUnKVxyXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHByb2plY3QgbmFtZScpXHJcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2plY3RfbmFtZSlcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9qZWN0X25hbWUgPSB2YWx1ZVxyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKClcclxuXHRcdFx0XHR9KSlcclxuXHRcdHNldCgpLnNldE5hbWUoJ05hbWUnKVxyXG5cdFx0XHQuc2V0RGVzYygnSGVyZSBpcyBnaXRsYWIgcmVwb3NpdG9yeSBuYW1lJylcclxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdFbnRlciByZXBvc2l0b3J5IG5hbWUnKVxyXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvX25hbWUpXHJcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucmVwb19uYW1lID0gdmFsdWVcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXHJcblx0XHRcdFx0fSkpXHJcblx0XHRzZXQoKS5zZXROYW1lKCdNYWluIGJyYW5jaCcpXHJcblx0XHRcdC5zZXREZXNjKCdIZXJlIGlzIGdpdGxhYiBtYWluIGJyYW5jaCBuYW1lJylcclxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdFbnRlciB5b3VyIGJyYW5jaCBuYW1lJylcclxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoKVxyXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmJyYW5jaCA9IHZhbHVlXHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKVxyXG5cdFx0XHRcdH0pKVxyXG5cdFx0c2V0KCkuc2V0TmFtZSgnU3luYyBBdXRvJylcclxuXHRcdFx0LnNldERlc2MoJ1NldCBvbiBpZiB5b3Ugd2FudCB0byBzeW5jIHJlcG9zaXRvcnkgYXV0b21hdGljYWxseScpXHJcblx0XHRcdC5hZGRUb2dnbGUoY2IgPT4gY2Iuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXV0bylcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvID0gdmFsdWVcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXHJcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBBdXRvIE1vZGU6ICR7dmFsdWUgPyAnb24nIDogJ29mZid9YClcclxuXHRcdFx0XHR9KSlcclxuXHRcdHNldCgpLnNldE5hbWUoJ0ZldGNoIG9uIHN0YXJ0JylcclxuXHRcdFx0LnNldERlc2MoJ1NldCBvbiBpZiB5b3Ugd2FudCB0byBzeW5jIHJlcG9zaXRvcnkgb24gc3RhcnQnKVxyXG5cdFx0XHQuYWRkVG9nZ2xlKGNiID0+IGNiLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmZldGNoKVxyXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmZldGNoID0gdmFsdWVcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXHJcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBBdXRvIEZldGNoOiAke3ZhbHVlID8gJ29uJyA6ICdvZmYnfWApXHJcblx0XHRcdFx0fSkpXHJcblx0XHRzZXQoKS5zZXROYW1lKCdOb3RpZmljYXRpb25zJylcclxuXHRcdFx0LnNldERlc2MoJ1NldCBvbiBpZiB5b3Ugd2FudCBub3RpZmljYXRpb25zJylcclxuXHRcdFx0LmFkZFRvZ2dsZShjYiA9PiBjYi5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3RpZilcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3RpZiA9IHZhbHVlXHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKVxyXG5cdFx0XHRcdFx0bmV3IE5vdGljZShgTm90aWZpY2F0aW9uczogJHt2YWx1ZSA/ICdvbicgOiAnb2ZmJ31gKVxyXG5cdFx0XHRcdH0pKVxyXG5cdFx0c2V0KCkuc2V0TmFtZSgnUmVsb2FkIFNldHRpbmdzJylcclxuXHRcdFx0LnNldERlc2MoJ0NsaWNrIHRvIHJlbG9hZCBjdXJyZW50IHNldHRpbmdzJylcclxuXHRcdFx0LmFkZEJ1dHRvbihjYiA9PiBjYi5zZXRCdXR0b25UZXh0KCdSZWxvYWQnKS5zZXRJY29uKCdyZWZyZXNoLWN3Jykub25DbGljaygoKSA9PiB7XHJcblx0XHRcdFx0dGhpcy5wbHVnaW4ubG9hZFNldHRpbmdzKClcclxuXHRcdFx0XHRuZXcgTm90aWNlKCdTZXR0aW5ncyB1cGRhdGVkJylcclxuXHRcdFx0fSkpXHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQgeyBsb2NhbF9jaGFuZ2VzX2xvZ3MsIHN5bmNfbG9ncyB9IGZyb20gXCJtYWluXCI7XHJcbmltcG9ydCB7IEl0ZW1WaWV3LCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IEZpbGVNZXRhRGF0YSwgfSBmcm9tIFwic3JjL3N0b3JhZ2VcIjtcclxuaW1wb3J0IHsgSElTVE9SWV9WSUVXIH0gZnJvbSBcInNyYy9zdGF0aWNcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgSGlzdG9yeUxlYWYgZXh0ZW5kcyBJdGVtVmlldyB7XHJcbiAgc3luY19sb2dzOiBIVE1MRWxlbWVudFxyXG4gIGxvY2FsX2xvZ3M6IEhUTUxFbGVtZW50XHJcbiAgY29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZikge1xyXG4gICAgc3VwZXIobGVhZilcclxuICB9XHJcbiAgaWNvbjogc3RyaW5nID0gJ3Njcm9sbCdcclxuICBnZXRWaWV3VHlwZSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIEhJU1RPUllfVklFV1xyXG4gIH1cclxuICBnZXREaXNwbGF5VGV4dCgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuICdTbm93Zmxha2UgSGlzdG9yeSdcclxuICB9XHJcbiAgYXN5bmMgcmVsb2FkX2xvZ3MoZWxlbWVudDogSFRNTEVsZW1lbnQsIHR5cGU6IEZpbGVNZXRhRGF0YSkge1xyXG4gICAgY29uc3QgbG9ncyA9IGF3YWl0IHR5cGUuZ2V0X2xpbmVzX2J5X2luZGV4KC0zMDApXHJcbiAgICBlbGVtZW50LmVtcHR5KClcclxuICAgIGxvZ3MucmV2ZXJzZSgpLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgZWxlbWVudC5jcmVhdGVFbCgnY29kZScsIHtcclxuICAgICAgICAgIHRleHQ6IGl0ZW0ucmVwbGFjZSgvXFx0L2dtLCAnIHwgJyksXHJcbiAgICAgIH0pXHJcbiAgICB9KVxyXG4gIH1cclxuICBjcmVhdGVfYnV0dG9uKHBhcmVudDogRWxlbWVudCwgbmFtZTogc3RyaW5nLCBjYWxsYmFjazogKCkgPT4gdm9pZCkge1xyXG4gICAgY29uc3QgYnV0dG9uID0gcGFyZW50LmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcbiAgICAgIHRleHQ6IG5hbWVcclxuICAgIH0pXHJcbiAgICBidXR0b24uc3R5bGUubWFyZ2luID0gJzEwcHgnXHJcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgIGNhbGxiYWNrKClcclxuICAgIH0pXHJcblxyXG4gIH1cclxuICBhc3luYyByZW5kZXIoKSB7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lckVsLmNoaWxkcmVuWzFdO1xyXG4gICAgY29udGFpbmVyLmVtcHR5KCk7XHJcbiAgICBjb250YWluZXIuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiU25vd2ZsYWtlIEhpc3RvcnlcIiB9KTtcclxuICAgIGNvbnRhaW5lci5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJTbm93Zmxha2UgTG9jYWwgQ2hhbmdlc1wiIH0pO1xyXG5cclxuICAgIHRoaXMubG9jYWxfbG9ncyA9IGNvbnRhaW5lci5jcmVhdGVFbCgnZGl2JylcclxuICAgIGNvbnRhaW5lci5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJTbm93Zmxha2UgU3luYyBMb2dzXCIgfSk7XHJcblxyXG4gICAgdGhpcy5zeW5jX2xvZ3MgPSBjb250YWluZXIuY3JlYXRlRWwoJ2RpdicpO1xyXG4gICAgW3RoaXMubG9jYWxfbG9ncywgdGhpcy5zeW5jX2xvZ3NdLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgIGl0ZW0uc3R5bGUuZm9udFNpemUgPSAnMTBweCdcclxuICAgICAgaXRlbS5zdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCdcclxuICAgICAgaXRlbS5zdHlsZS5tYXhIZWlnaHQgPSAnNTAwcHgnXHJcbiAgICAgIGl0ZW0uc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nXHJcbiAgICAgIGl0ZW0uc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xyXG4gICAgICBpdGVtLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAnY29sdW1uLXJldmVyc2UnXHJcbiAgICB9KVxyXG4gIH1cclxuICBhc3luYyB1cGRhdGUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCB0aGlzLnJlbG9hZF9sb2dzKHRoaXMubG9jYWxfbG9ncywgbG9jYWxfY2hhbmdlc19sb2dzKVxyXG4gICAgYXdhaXQgdGhpcy5yZWxvYWRfbG9ncyh0aGlzLnN5bmNfbG9ncywgc3luY19sb2dzKVxyXG4gIH1cclxuICBhc3luYyBvbk9wZW4oKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCB0aGlzLnJlbmRlcigpXHJcbiAgICBhd2FpdCB0aGlzLnJlbG9hZF9sb2dzKHRoaXMubG9jYWxfbG9ncywgbG9jYWxfY2hhbmdlc19sb2dzKVxyXG4gICAgYXdhaXQgdGhpcy5yZWxvYWRfbG9ncyh0aGlzLnN5bmNfbG9ncywgc3luY19sb2dzKVxyXG4gIH1cclxufSIsICJpbXBvcnQgeyBBcHAsIFdvcmtzcGFjZUxlYWYgfSBmcm9tIFwib2JzaWRpYW5cIlxyXG5pbXBvcnQgeyBsb2NhbF9jaGFuZ2VzX2xvZ3MsIHN5bmNfbG9ncyB9IGZyb20gXCJtYWluXCJcclxuaW1wb3J0IHsgSElTVE9SWV9WSUVXIH0gZnJvbSBcInNyYy9zdGF0aWNcIlxyXG5pbXBvcnQgeyBIaXN0b3J5TGVhZiB9IGZyb20gXCIuL2hpc3Rvcnlfdmlld1wiXHJcblxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCAgYWN0aXZhdGVfaGlzdG9yeV92aWV3ID0gYXN5bmMoKSA9PiAge1xyXG4gIGNvbnN0IHsgd29ya3NwYWNlIH0gPSBhcHBcclxuXHJcbiAgbGV0IGxlYWY6IFdvcmtzcGFjZUxlYWYgfCBudWxsID0gbnVsbFxyXG4gIGNvbnN0IGxlYXZlcyA9IHdvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoSElTVE9SWV9WSUVXKVxyXG4gIGlmIChsZWF2ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgbGVhZiA9IGxlYXZlc1swXVxyXG4gIH0gZWxzZSB7XHJcbiAgICBsZWFmID0gd29ya3NwYWNlLmdldFJpZ2h0TGVhZihmYWxzZSlcclxuICAgIGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHsgdHlwZTogSElTVE9SWV9WSUVXLCBhY3RpdmU6IGZhbHNlIH0pXHJcbiAgfVxyXG4gIHN5bmNfbG9ncy5zZXRfY2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKGxlYWYpXHJcbiAgICAgIChsZWFmLnZpZXcgYXMgSGlzdG9yeUxlYWYpLnVwZGF0ZSgpXHJcbiAgfSlcclxuICBsb2NhbF9jaGFuZ2VzX2xvZ3Muc2V0X2NhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmIChsZWFmKVxyXG4gICAgICAobGVhZi52aWV3IGFzIEhpc3RvcnlMZWFmKS51cGRhdGUoKVxyXG4gIH0pXHJcbn0iLCAiaW1wb3J0IHsgYWN0aXZhdGVfaGlzdG9yeV92aWV3IH0gZnJvbSBcInZpZXdzL3ZpZXdzXCJcclxuXHJcbmV4cG9ydCBjb25zdCBsb2dzX3BhbmVsID0ge1xyXG4gIGlkOiAnb3Blbl9sb2dzX3BhbmVsJyxcclxuICBuYW1lOiAnT3BlbiBTbm93Zmxha2UgTG9ncycsXHJcbiAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcclxuICAgIGFjdGl2YXRlX2hpc3RvcnlfdmlldygpXHJcbiAgfVxyXG59IiwgImltcG9ydCB7IE9wdGlvbmFsR2VuZXJhbE1vZGFsQ29uZmlnIH0gZnJvbSBcImRcIlxyXG5pbXBvcnQgeyBTdWdnZXN0TW9kYWwgfSBmcm9tIFwib2JzaWRpYW5cIlxyXG5cclxuZXhwb3J0IGNsYXNzIENvbW1hbmRTZWxlY3Rpb24gZXh0ZW5kcyBTdWdnZXN0TW9kYWw8c3RyaW5nPntcclxuXHRyZXNvbHZlOiAoXHJcblx0XHR2YWx1ZTogc3RyaW5nIHwgdW5kZWZpbmVkIHwgUHJvbWlzZUxpa2U8c3RyaW5nIHwgdW5kZWZpbmVkPlxyXG5cdCkgPT4gdm9pZFxyXG5cdGNvbmZpZzogT3B0aW9uYWxHZW5lcmFsTW9kYWxDb25maWdcclxuXHJcblx0Y29uc3RydWN0b3IoY29uZmlnOiBPcHRpb25hbEdlbmVyYWxNb2RhbENvbmZpZykge1xyXG5cdFx0c3VwZXIoYXBwKVxyXG5cdFx0dGhpcy5jb25maWcgPSB7IC4uLmNvbmZpZyB9XHJcblx0XHR0aGlzLnNldFBsYWNlaG9sZGVyKHRoaXMuY29uZmlnLnBsYWNlaG9sZGVyIHx8ICcnKVxyXG5cdH1cclxuXHJcblx0b3BlbigpOiBQcm9taXNlPHN0cmluZz4ge1xyXG5cdFx0c3VwZXIub3BlbigpXHJcblxyXG5cdFx0aWYgKHRoaXMuY29uZmlnLmluaXRpYWxWYWx1ZSAhPSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5pbnB1dEVsLnZhbHVlID0gdGhpcy5jb25maWcuaW5pdGlhbFZhbHVlXHJcblx0XHRcdHRoaXMuaW5wdXRFbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIpKVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG5cdFx0XHR0aGlzLnJlc29sdmUgPSByZXNvbHZlXHJcblx0XHR9KVxyXG5cdH1cclxuXHRzZWxlY3RTdWdnZXN0aW9uKHZhbHVlOiBzdHJpbmcsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLnJlc29sdmUpIHtcclxuXHRcdFx0bGV0IHJlc1xyXG5cdFx0XHRpZiAodGhpcy5jb25maWcuYWxsb3dFbXB0eSAmJiB2YWx1ZSA9PT0gXCIgXCIpIHJlcyA9IFwiXCJcclxuXHRcdFx0ZWxzZSBpZiAodmFsdWUgPT09IFwiLi4uXCIpIHJlcyA9IHVuZGVmaW5lZFxyXG5cdFx0XHRlbHNlIHJlcyA9IHZhbHVlXHJcblx0XHRcdHRoaXMucmVzb2x2ZShyZXMpXHJcblx0XHR9XHJcblx0XHRzdXBlci5zZWxlY3RTdWdnZXN0aW9uKHZhbHVlLCBldnQpXHJcblx0fVxyXG5cdG9uQ2xvc2UoKSB7XHJcblx0XHRpZiAodGhpcy5yZXNvbHZlKSB0aGlzLnJlc29sdmUodW5kZWZpbmVkKVxyXG5cdH1cclxuXHRnZXRTdWdnZXN0aW9ucyhxdWVyeTogc3RyaW5nKTogc3RyaW5nW10ge1xyXG5cdFx0aWYgKHRoaXMuY29uZmlnLm9ubHlTZWxlY3Rpb24pIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuY29uZmlnLm9wdGlvbnMgfHwgW11cclxuXHRcdH0gZWxzZSBpZiAodGhpcy5jb25maWcuYWxsb3dFbXB0eSkge1xyXG5cdFx0XHRyZXR1cm4gW3F1ZXJ5Lmxlbmd0aCA+IDAgPyBxdWVyeSA6IFwiIFwiLCAuLi50aGlzLmNvbmZpZy5vcHRpb25zIHx8IFtdXVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIFtxdWVyeS5sZW5ndGggPiAwID8gcXVlcnkgOiBcIi4uLlwiLCAuLi50aGlzLmNvbmZpZy5vcHRpb25zIHx8IFtdXVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZW5kZXJTdWdnZXN0aW9uKHZhbHVlOiBzdHJpbmcsIGVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG5cdFx0ZWwuc2V0VGV4dCh2YWx1ZSlcclxuXHR9XHJcblx0b25DaG9vc2VTdWdnZXN0aW9uKGl0ZW06IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkgeyB9XHJcbn1cclxuIiwgImltcG9ydCB7IGdpdGxhYiwgbG9jYWxfY2hhbmdlc19sb2dzLCBwb2NrZXQsIHJlcV9xdWV1ZSwgc3luY19sb2dzIH0gZnJvbSAnbWFpbidcclxuaW1wb3J0IHsgQ29tbWFuZFNlbGVjdGlvbiB9IGZyb20gJy4uL21vZGFsL3NlbGVjdGlvbidcclxuaW1wb3J0IHsgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nXHJcbmltcG9ydCB7IGJhc2U2NFRvQXJyYXlCdWZmZXIgfSBmcm9tICdzcmMvdXRpbHMnXHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgY29uc3QgY29tbWFuZF9fc2VuZF9hbGwgPSBhc3luYyAoKSA9PiB7XHJcbiAgY29uc3QgbmMgPSBuZXcgTm90aWNlKCdTZW5kaW5nLi4uJywgMClcclxuICBjb25zdCBzdGF0dXMgPSBbMCwgMF1cclxuICBjb25zdCByZWFkX2ZvbGRlciA9IGFzeW5jIChkaXI6IHN0cmluZykgPT4ge1xyXG4gICAgaWYgKGRpci5jb250YWlucygnLmdpdCcpIHx8IGRpci5jb250YWlucygnbm9kZV9tb2R1bGVzJykpXHJcbiAgICAgIHJldHVyblxyXG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IGFwcC52YXVsdC5hZGFwdGVyLmxpc3QoZGlyKVxyXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIGNvbnRlbnQuZmlsZXMpIHtcclxuICAgICAgbmMuc2V0TWVzc2FnZShwYXRoKVxyXG4gICAgICBzdGF0dXNbMF0gKz0gMVxyXG4gICAgICBhd2FpdCBnaXRsYWIuY3JlYXRlKHBhdGgsIHt9LCBmYWxzZSlcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBjb250ZW50LmZvbGRlcnMpIHtcclxuICAgICAgbmMuc2V0TWVzc2FnZShwYXRoKVxyXG4gICAgICBzdGF0dXNbMV0gKz0gMVxyXG4gICAgICBhd2FpdCByZWFkX2ZvbGRlcihwYXRoKVxyXG4gICAgfVxyXG4gIH1cclxuICBhd2FpdCByZWFkX2ZvbGRlcignLycpXHJcbiAgYXdhaXQgZ2l0bGFiLnNhdmVfbGFzdF9jb21taXQoKVxyXG4gIG5jLnNldE1lc3NhZ2UoYERvbmUgZm9yICR7c3RhdHVzWzBdfSBmaWxlcyBpbiAke3N0YXR1c1sxXX0gZm9sZGVyc2ApXHJcbiAgc2V0VGltZW91dCgoKSA9PiBuYy5oaWRlKCksIDEwMDAgKiA1KVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY29tbWFuZF9fc2VuZF9jaGFuZ2VzID0gYXN5bmMgKCkgPT4ge1xyXG4gIGNvbnN0IGxvZ2dlZF9sb2NhbF9jaGFuZ2VzX2Zyb21fZmlsZSA9IGF3YWl0IGxvY2FsX2NoYW5nZXNfbG9ncy5nZXRfbGluZXNfZnJvbV90b19waHJhc2UoJ0xPQ0FMIENIQU5HRVMnKVxyXG4gIGNvbnN0IGZpbGVzX3N0YXRlczogTWFwPHN0cmluZywgeyB0aW1lOiBzdHJpbmcsIGFjdGlvbjogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIG9sZF9wYXRoPzogc3RyaW5nIH0+ID0gbmV3IE1hcCgpXHJcbiAgbGV0IGxvZ2dlZF9sb2NhbF9jaGFuZ2VzX3BhcnNlZDogW3N0cmluZywgeyB0aW1lOiBzdHJpbmcsIGFjdGlvbjogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIG9sZF9wYXRoPzogc3RyaW5nIH1dW10gPSBbXVxyXG4gIGxvZ2dlZF9sb2NhbF9jaGFuZ2VzX2Zyb21fZmlsZS5yZXZlcnNlKCkuZm9yRWFjaChpdGVtID0+IHtcclxuICAgIGNvbnN0IHBhcnNlZF9vYmplY3QgPSBsb2NhbF9jaGFuZ2VzX2xvZ3MucGFyc2VyKGl0ZW0pXHJcbiAgICBpZiAoISFwYXJzZWRfb2JqZWN0Lm9sZF9wYXRoKVxyXG4gICAgICBmaWxlc19zdGF0ZXMuZGVsZXRlKHBhcnNlZF9vYmplY3Qub2xkX3BhdGgpXHJcblxyXG4gICAgaWYgKGZpbGVzX3N0YXRlcy5oYXMocGFyc2VkX29iamVjdC5wYXRoKSAmJiBwYXJzZWRfb2JqZWN0LmFjdGlvbiA9PSAnREVMRVRFJylcclxuICAgICAgZmlsZXNfc3RhdGVzLmRlbGV0ZShwYXJzZWRfb2JqZWN0LnBhdGgpXHJcblxyXG4gICAgaWYgKGZpbGVzX3N0YXRlcy5oYXMocGFyc2VkX29iamVjdC5wYXRoKSAmJiBwYXJzZWRfb2JqZWN0LmFjdGlvbiA9PSAnTU9ESUZZJykge1xyXG4gICAgICBmaWxlc19zdGF0ZXMuc2V0KHBhcnNlZF9vYmplY3QucGF0aCwgeyAuLi5wYXJzZWRfb2JqZWN0LCBhY3Rpb246ICdDUkVBVEUnIH0pXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGZpbGVzX3N0YXRlcy5zZXQocGFyc2VkX29iamVjdC5wYXRoLCBwYXJzZWRfb2JqZWN0KVxyXG4gICAgbG9nZ2VkX2xvY2FsX2NoYW5nZXNfcGFyc2VkID0gQXJyYXkuZnJvbShmaWxlc19zdGF0ZXMuZW50cmllcygpKVxyXG4gIH1cclxuICApXHJcblxyXG4gIGxvZ2dlZF9sb2NhbF9jaGFuZ2VzX3BhcnNlZC5mb3JFYWNoKChpdGVtOiBhbnkpID0+IHtcclxuICAgIGNvbnN0IHBhcnNlZCA9IGl0ZW1bMV1cclxuICAgIGlmIChwYXJzZWQuYWN0aW9uID09ICdDUkVBVEUnKVxyXG4gICAgICByZXFfcXVldWUuYXBwZW5kKGFzeW5jICgpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgYXdhaXQgZ2l0bGFiLmNyZWF0ZShwYXJzZWQucGF0aCxcclxuICAgICAgICAgICAgeyBjb21taXRfbWVzc2FnZTogYGNyZWF0aW5nIGZpbGUgXCIke3BhcnNlZC5wYXRofVwiIC0gJHtwYXJzZWQudGltZX1gIH1cclxuICAgICAgICAgICAgLCBmYWxzZSlcclxuICAgICAgICAgIHN5bmNfbG9ncy5sb2coYGNyZWF0aW5nIGZpbGUgXCIke3BhcnNlZC5wYXRofVwiYClcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2gge1xyXG4gICAgICAgICAgc3luY19sb2dzLmxvZyhgRkFJTDogY3JlYXRpbmcgZmlsZSBcIiR7cGFyc2VkLnBhdGh9XCJgKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIGlmIChwYXJzZWQuYWN0aW9uID09ICdNT0RJRlknKVxyXG4gICAgICByZXFfcXVldWUuYXBwZW5kKGFzeW5jICgpID0+IHtcclxuICAgICAgICB0cnkge1xyXG5cclxuICAgICAgICAgIGF3YWl0IGdpdGxhYi5tb2RpZnkocGFyc2VkLnBhdGgsXHJcbiAgICAgICAgICAgIHsgY29tbWl0X21lc3NhZ2U6IGBtb2RpZnlpbmcgZmlsZSBcIiR7cGFyc2VkLnBhdGh9XCIgLSAke3BhcnNlZC50aW1lfWAgfSwgZmFsc2UpXHJcbiAgICAgICAgICBzeW5jX2xvZ3MubG9nKGBtb2RpZnlpbmcgZmlsZSBcIiR7cGFyc2VkLnBhdGh9XCJgKVxyXG5cclxuICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgIHN5bmNfbG9ncy5sb2coYEZBSUw6IG1vZGlmeWluZyBmaWxlIFwiJHtwYXJzZWQucGF0aH1cImApXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgaWYgKHBhcnNlZC5hY3Rpb24gPT0gJ0RFTEVURScpXHJcbiAgICAgIHJlcV9xdWV1ZS5hcHBlbmQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCBnaXRsYWIuZGVsZXRlKHBhcnNlZC5wYXRoLFxyXG4gICAgICAgICAgICB7IGNvbW1pdF9tZXNzYWdlOiBgZGVsZXRpbmcgZmlsZSBcIiR7cGFyc2VkLnBhdGh9XCIgLSAke3BhcnNlZC50aW1lfWAgfSwgZmFsc2UpXHJcbiAgICAgICAgICBzeW5jX2xvZ3MubG9nKGBkZWxldGluZyBmaWxlIFwiJHtwYXJzZWQucGF0aH1cImApXHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICBzeW5jX2xvZ3MubG9nKGBGQUlMOiBkZWxldGluZyBmaWxlIFwiJHtwYXJzZWQucGF0aH1cImApXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgaWYgKHBhcnNlZC5hY3Rpb24gPT0gJ1JFTkFNRScpXHJcbiAgICAgIHJlcV9xdWV1ZS5hcHBlbmQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCBnaXRsYWIuY3JlYXRlKHBhcnNlZC5wYXRoLFxyXG4gICAgICAgICAgICB7IGNvbW1pdF9tZXNzYWdlOiBgcmVuYW1pbmdbY10gZmlsZSBcIiR7cGFyc2VkLm9sZF9wYXRofVwiIC0+IFwiJHtwYXJzZWQucGF0aH1cIiAtICR7cGFyc2VkLnRpbWV9YCB9LCBmYWxzZSlcclxuICAgICAgICAgIGF3YWl0IGdpdGxhYi5kZWxldGUocGFyc2VkLm9sZF9wYXRoLFxyXG4gICAgICAgICAgICB7IGNvbW1pdF9tZXNzYWdlOiBgcmVuYW1pbmdbZF0gZmlsZSBcIiR7cGFyc2VkLm9sZF9wYXRofVwiIC0+IFwiJHtwYXJzZWQucGF0aH1cIiAtICR7cGFyc2VkLnRpbWV9YCB9LCBmYWxzZSlcclxuICAgICAgICAgIHN5bmNfbG9ncy5sb2coYHJlbmFtaW5nIGZpbGUgXCIke3BhcnNlZC5vbGRfcGF0aH1cIiAtPiBcIiR7cGFyc2VkLnBhdGh9XCJgKVxyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgc3luY19sb2dzLmxvZyhgRkFJTDogcmVuYW1pbmcgZmlsZSBcIiR7cGFyc2VkLm9sZF9wYXRofVwiIC0+IFwiJHtwYXJzZWQucGF0aH1cImApXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gIH0pXHJcbiAgYXdhaXQgZ2l0bGFiLnNhdmVfbGFzdF9jb21taXQoKVxyXG4gIGxvY2FsX2NoYW5nZXNfbG9ncy5hZGRfYWN0aW9uKCdMT0NBTCBDSEFOR0VTIFBVU0hFRCcsIGAke2xvZ2dlZF9sb2NhbF9jaGFuZ2VzX3BhcnNlZC5sZW5ndGh9IGNoYW5nZXNgKVxyXG4gIGxvY2FsX2NoYW5nZXNfbG9ncy5jYWxsYmFjaygpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjb21tYW5kX19nZXRfYWxsX3JlcG8gPSBhc3luYyAoKSA9PiB7XHJcbiAgY29uc3QgaW5jbHVkZV9jb25maWcgPSBhd2FpdCBuZXcgQ29tbWFuZFNlbGVjdGlvbih7XHJcbiAgICBwbGFjZWhvbGRlcjogJ0luY2x1ZGVzIC5vYnNpZGlhbj8nLFxyXG4gICAgb3B0aW9uczogWydZRVMnLCAnTk8nXVxyXG4gIH0pLm9wZW4oKVxyXG5cclxuICBjb25zdCBjaG9vc2VfcGF0aHRyZWUgPSBhc3luYyAoc3RhcnRfcGF0aDogc3RyaW5nID0gJycpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gICAgY29uc3QgdHJlZSA9IGF3YWl0IGdpdGxhYi5yZWFkX3JlcG9fdHJlZShzdGFydF9wYXRoLCAwLCAwLCBmYWxzZSlcclxuICAgIGNvbnN0IGZvbGRlcnMgPSB0cmVlLmZpbHRlcihpdGVtID0+IGl0ZW1bMl0pLm1hcChpdGVtID0+IGl0ZW1bMV0pXHJcbiAgICBpZiAoZm9sZGVycy5sZW5ndGggPT0gMClcclxuICAgICAgcmV0dXJuIHN0YXJ0X3BhdGhcclxuICAgIGNvbnN0IHJlcG9fcGF0aCA9IGF3YWl0IG5ldyBDb21tYW5kU2VsZWN0aW9uKHtcclxuICAgICAgcGxhY2Vob2xkZXI6ICdSZXBvIGRpciBwYXRoIC0gbGVhdmUgZW1wdHkgZm9yIHdob2xlIHJlcG8gb3IgLi4gdG8gYmFjaycsXHJcbiAgICAgIG9wdGlvbnM6IGZvbGRlcnNcclxuICAgIH0pLm9wZW4oKVxyXG5cclxuICAgIGlmICghcmVwb19wYXRoKVxyXG4gICAgICByZXR1cm4gc3RhcnRfcGF0aFxyXG4gICAgaWYgKHJlcG9fcGF0aCA9PSAnLi4nKVxyXG4gICAgICByZXR1cm4gY2hvb3NlX3BhdGh0cmVlKCcnKVxyXG4gICAgcmV0dXJuIGNob29zZV9wYXRodHJlZShyZXBvX3BhdGgpXHJcbiAgfVxyXG5cclxuICBjb25zdCBwYXRoID0gYXdhaXQgY2hvb3NlX3BhdGh0cmVlKCcnKVxyXG4gIGNvbnN0IHRyZWUgPSBhd2FpdCBnaXRsYWIucmVhZF9yZXBvX3RyZWUocGF0aClcclxuICB0cmVlLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICBpZiAoaXRlbVsyXSlcclxuICAgICAgYXBwLnZhdWx0LmFkYXB0ZXIubWtkaXIoaXRlbVsxXSlcclxuICB9KVxyXG4gIGNvbnN0IGZpbGVfc3RhdHVzID0gbmV3IE5vdGljZSgnRmlsZTogJywgMClcclxuICBmb3IgKGNvbnN0IGZpbGUgb2YgdHJlZSkge1xyXG4gICAgaWYgKGluY2x1ZGVfY29uZmlnID09ICdZRVMnICYmIGZpbGVbMV0uc3RhcnRzV2l0aCgnLm9ic2lkaWFuJykpIGNvbnRpbnVlXHJcbiAgICBpZiAoZmlsZVsyXSkgY29udGludWVcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGdpdGxhYi5yZWFkKGZpbGVbMV0pXHJcbiAgICBpZiAocmVzID09IG51bGwpIGNvbnRpbnVlXHJcbiAgICBmaWxlX3N0YXR1cy5zZXRNZXNzYWdlKCdGaWxlOiAnICsgZmlsZVsxXSlcclxuICAgIGFwcC52YXVsdC5hZGFwdGVyLndyaXRlQmluYXJ5KGZpbGVbMV0sIGJhc2U2NFRvQXJyYXlCdWZmZXIocmVzLmRhdGEuY29udGVudCkpXHJcbiAgfVxyXG4gIGF3YWl0IGdpdGxhYi5zYXZlX2xhc3RfY29tbWl0KClcclxuXHJcbiAgZmlsZV9zdGF0dXMuaGlkZSgpXHJcbiAgbmV3IE5vdGljZSgnRG9uZScpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjb21tYW5kX19mZXRjaF9jaGFuZ2VzID0gYXN5bmMgKCkgPT4ge1xyXG4gIGNvbnN0IG5jID0gbmV3IE5vdGljZSgnRmV0Y2hpbmcuLi4nLCAwKVxyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGdpdGxhYi5nZXRfY29tbWl0cygpXHJcbiAgY29uc3QgbGFzdF9jb21taXQgPSByZXNbcmVzLmxlbmd0aCAtIDFdXHJcbiAgaWYgKCFsYXN0X2NvbW1pdClcclxuICAgIHJldHVybiBhd2FpdCBnaXRsYWIuc2F2ZV9sYXN0X2NvbW1pdCgpXHJcblxyXG4gIGlmIChsYXN0X2NvbW1pdC5pZCA9PSBwb2NrZXQuZ2V0KCdsYXN0X2NvbW1pdF9pZCcpKVxyXG4gICAgcmV0dXJuIG5jLnNldE1lc3NhZ2UoJ0V2ZXJ5dGhpbmcgaXMgdXAgdG8gZGF0ZScpXHJcbiAgbGV0IGNvbnRlbnRfcmVtb3RlX2NoYW5nZXMgPSAwXHJcbiAgcmVxX3F1ZXVlLmFwcGVuZChhc3luYyAoKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IGNvbW1pdCBvZiByZXMpIHtcclxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZ2l0bGFiLmdldF9kaWZmcyhjb21taXQuaWQpXHJcbiAgICAgIHJlcz8uZGF0YS5mb3JFYWNoKGFzeW5jIChpdGVtOiBhbnkpID0+IHtcclxuICAgICAgICBjb250ZW50X3JlbW90ZV9jaGFuZ2VzKytcclxuICAgICAgICByZXFfcXVldWUuYXBwZW5kKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtLm5ld19maWxlIHx8ICghaXRlbS5yZW5hbWVkX2ZpbGUgJiYgIWl0ZW0ubmV3X2ZpbGUgJiYgIWl0ZW0uZGVsZXRlZF9maWxlKSlcclxuICAgICAgICAgICAgICBhd2FpdCBnaXRsYWIuc2F2ZV9sb2NhbF9maWxlKGl0ZW0ubmV3X3BhdGgpXHJcbiAgICAgICAgICAgIGlmIChpdGVtLnJlbmFtZWRfZmlsZSlcclxuICAgICAgICAgICAgICBhd2FpdCBhcHAudmF1bHQuYWRhcHRlci5yZW5hbWUoaXRlbS5vbGRfcGF0aCwgaXRlbS5uZXdfcGF0aClcclxuICAgICAgICAgICAgaWYgKGl0ZW0uZGVsZXRlZF9maWxlKVxyXG4gICAgICAgICAgICAgIGF3YWl0IGFwcC52YXVsdC5hZGFwdGVyLnJlbW92ZShpdGVtLm5ld19wYXRoKVxyXG4gICAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmZXRjaGluZyBlcnJvcnMnKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgfSlcclxuICBhd2FpdCBnaXRsYWIuc2F2ZV9sYXN0X2NvbW1pdCgpXHJcbiAgcmVxX3F1ZXVlLmFwcGVuZCgoKSA9PiBsb2NhbF9jaGFuZ2VzX2xvZ3MuYWRkX2FjdGlvbignTE9DQUwgQ0hBTkdFUyBQVUxMRUQnLCBgJHtjb250ZW50X3JlbW90ZV9jaGFuZ2VzfSBjaGFuZ2VzYCkpXHJcblxyXG4gIG5jLnNldE1lc3NhZ2UoJ0V2ZXJ5dGhpbmcgaXMgdXAgdG8gZGF0ZVxcbkxhc3QgY29tbWl0OiAnICsgcG9ja2V0LmdldCgnbGFzdF9jb21taXRfaWQnKSlcclxufVxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBnZXRfYWxsX3JlcG9zaXRvcnkgPSB7XHJcbiAgaWQ6ICdnZXRfYWxsX3JlcG9zaXRvcnknLFxyXG4gIG5hbWU6ICdEb3dubG9hZCBhbGwgcmVwb3NpdG9yeScsXHJcbiAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcclxuICAgIGNvbW1hbmRfX2dldF9hbGxfcmVwbygpXHJcbiAgfVxyXG59XHJcbmV4cG9ydCBjb25zdCBmZXRjaF9jaGFuZ2VzID0ge1xyXG4gIGlkOiAnZmV0Y2hfY2hhbmdlcycsXHJcbiAgbmFtZTogJ0ZldGNoIHJlbW90ZSBjaGFuZ2VzJyxcclxuICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG4gICAgY29tbWFuZF9fZmV0Y2hfY2hhbmdlcygpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgc2VuZF9hbGxfZ2l0bGFiID0ge1xyXG4gIGlkOiAnc2VuZF9hbGxfZ2l0bGFiJyxcclxuICBuYW1lOiAnU2VuZCBhbGwgbG9jYWwgZmlsZXMnLFxyXG4gIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XHJcbiAgICBjb21tYW5kX19zZW5kX2FsbCgpXHJcbiAgfSxcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHNlbmRfY2hhbmdlc19naXRsYWIgPSB7XHJcbiAgaWQ6ICdzZW5kX2NoYW5nZXNfZ2l0bGFiJyxcclxuICBuYW1lOiAnU2VuZCBsb2NhbCBjaGFuZ2VzJyxcclxuICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG4gICAgY29tbWFuZF9fc2VuZF9jaGFuZ2VzKClcclxuICB9XHJcbn1cclxuXHJcbiIsICJleHBvcnQgY29uc3QgYmFzZTY0VG9BcnJheUJ1ZmZlciA9IChiYXNlNjQ6IHN0cmluZykgPT4ge1xyXG5cdHZhciBiaW5hcnlTdHJpbmcgPSBhdG9iKGJhc2U2NClcclxuXHR2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpXHJcblx0fVxyXG5cdHJldHVybiBieXRlcy5idWZmZXJcclxufVxyXG5leHBvcnQgY29uc3QgY2FsbGJhY2tfdGltZV9idWZmZXIgPSAoaGFuZGxlcjogbnVtYmVyIHwgTm9kZUpTLlRpbWVvdXQgfCBudWxsICA9IG51bGwpID0+ICh7XHJcblx0cnVuX3Rhc2tfaW50ZXJ2YWw6IChjYWxsYmFjazogKCkgPT4gdm9pZCwgdGltZW91dDogbnVtYmVyKSA9PiB7XHJcblx0XHRjb25zdCBuZXdfdGFza19pbnRlcnZhbCA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWVvdXQpXHJcblx0XHRyZXR1cm4gY2FsbGJhY2tfdGltZV9idWZmZXIobmV3X3Rhc2tfaW50ZXJ2YWwpXHJcblx0fSxcclxuXHRicmVha19pbnRlcnZhbF9hbmRfcHVzaF90YXNrOiAoY2FsbGJhY2s6ICgpID0+IHZvaWQsIHRpbWVvdXQ6IG51bWJlcikgPT4ge1xyXG5cdFx0aWYoaGFuZGxlcilcclxuXHRcdFx0Y2xlYXJJbnRlcnZhbChoYW5kbGVyKVxyXG5cdFx0cmV0dXJuIGNhbGxiYWNrX3RpbWVfYnVmZmVyKCkucnVuX3Rhc2tfaW50ZXJ2YWwoY2FsbGJhY2ssIHRpbWVvdXQpXHJcblx0fVxyXG59KVxyXG5cclxuLyoqXHJcbiAqIGxldCBjYWxsYmFja19idWZmZXIgPSBjYWxsYmFja190aW1lX2J1ZmZlcigpXHJcbiAqIFxyXG4gKiBcclxuICogRVZFTlRcclxuICogY2FsbGJhY2tfYnVmZmVyID0gY2FsbGJhY2tfYnVmZmVyLmJyZWFrX2ludGVydmFsX2FuZF9wdXNoX3Rhc2soLi4uLCAuLi4pXHJcbiAqIFxyXG4gKi8iLCAiaW1wb3J0IHtsb2dzX3BhbmVsfSBmcm9tIFwiLi9zaG93X3BhbmVsc1wiXHJcbmltcG9ydCB7ZmV0Y2hfY2hhbmdlcywgZ2V0X2FsbF9yZXBvc2l0b3J5LCBzZW5kX2FsbF9naXRsYWIsIHNlbmRfY2hhbmdlc19naXRsYWJ9IGZyb20gXCIuL3JlcG9zaXRvcnlfY29udHJvbGxlclwiXHJcblxyXG5jb25zdCBjb21tYW5kcyA9IFtcclxuICBsb2dzX3BhbmVsLFxyXG4gIGdldF9hbGxfcmVwb3NpdG9yeSxcclxuICBzZW5kX2FsbF9naXRsYWIsXHJcbiAgc2VuZF9jaGFuZ2VzX2dpdGxhYixcclxuICBmZXRjaF9jaGFuZ2VzXHJcbl1cclxuZXhwb3J0IGRlZmF1bHQgY29tbWFuZHMiLCAiaW1wb3J0IHsgZ2l0bGFiLCByZXFfcXVldWUgfSBmcm9tIFwibWFpblwiXHJcbmltcG9ydCB7IE1lbnUsIE5vdGljZSwgVEFic3RyYWN0RmlsZSwgVEZvbGRlciB9IGZyb20gXCJvYnNpZGlhblwiXHJcbmltcG9ydCB7IGJhc2U2NFRvQXJyYXlCdWZmZXIgfSBmcm9tIFwic3JjL3V0aWxzXCJcclxuXHJcbmV4cG9ydCBjb25zdCBmaWxlX21lbnVfc2VuZF9maWxlID0gKG1lbnU6IE1lbnUsIGZpbGU6IFRBYnN0cmFjdEZpbGUpID0+IHtcclxuICBtZW51LmFkZEl0ZW0oKGl0ZW0pID0+IHtcclxuICAgIGl0ZW1cclxuICAgICAgLnNldFRpdGxlKFwiR2l0bGFiOiBTZW5kIEZpbGVcIilcclxuICAgICAgLnNldEljb24oXCJzZW5kXCIpXHJcbiAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBuYyA9IG5ldyBOb3RpY2UoJ1NlbmRpbmcuLi4nLCAwKVxyXG4gICAgICAgIHJlcV9xdWV1ZS5hcHBlbmQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKChmaWxlIGFzIFRGb2xkZXIpLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWRfZm9sZGVyID0gYXN5bmMgKGRpcjogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IGFwcC52YXVsdC5hZGFwdGVyLmxpc3QoZGlyKVxyXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBjb250ZW50LmZpbGVzKSB7XHJcbiAgICAgICAgICAgICAgICBuYy5zZXRNZXNzYWdlKHBhdGgpXHJcbiAgICAgICAgICAgICAgICBhd2FpdCBnaXRsYWIuY3JlYXRlKHBhdGgpXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBjb250ZW50LmZvbGRlcnMpIHtcclxuICAgICAgICAgICAgICAgIG5jLnNldE1lc3NhZ2UocGF0aClcclxuICAgICAgICAgICAgICAgIGF3YWl0IHJlYWRfZm9sZGVyKHBhdGgpXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF3YWl0IHJlYWRfZm9sZGVyKGZpbGUucGF0aClcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGdpdGxhYi5jcmVhdGUoZmlsZS5wYXRoKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbmMuc2V0TWVzc2FnZSgnRG9uZScpXHJcbiAgICAgICAgfSlcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG5jLmhpZGUoKSwgMTAwMCAqIDUpXHJcbiAgICAgIH0pXHJcbiAgfSlcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGZpbGVfbWVudV9sb2FkX2ZpbGUgPSAobWVudTogTWVudSwgZmlsZTogVEFic3RyYWN0RmlsZSkgPT4ge1xyXG4gIG1lbnUuYWRkSXRlbSgoaXRlbSkgPT4ge1xyXG4gICAgaXRlbVxyXG4gICAgICAuc2V0VGl0bGUoXCJHaXRsYWI6IExvYWQgRmlsZVwiKVxyXG4gICAgICAuc2V0SWNvbihcImZpbGUtZG93blwiKVxyXG4gICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbmMgPSBuZXcgTm90aWNlKCdMb2FkaW5nLi4uJywgMClcclxuICAgICAgICByZXFfcXVldWUuYXBwZW5kKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgIGlmICgoZmlsZSBhcyBURm9sZGVyKS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBjb25zdCB0cmVlID0gYXdhaXQgZ2l0bGFiLnJlYWRfcmVwb190cmVlKGZpbGUucGF0aClcclxuICAgICAgICAgICAgdHJlZS5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChpdGVtWzJdKVxyXG4gICAgICAgICAgICAgICAgYXBwLnZhdWx0LmFkYXB0ZXIubWtkaXIoaXRlbVsxXSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIHRyZWUpIHtcclxuICAgICAgICAgICAgICBpZiAoZmlsZVsyXSkgY29udGludWVcclxuICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBnaXRsYWIucmVhZChmaWxlWzFdKVxyXG4gICAgICAgICAgICAgIGlmIChyZXMgPT0gbnVsbCkgY29udGludWVcclxuICAgICAgICAgICAgICBhcHAudmF1bHQuYWRhcHRlci53cml0ZUJpbmFyeShmaWxlWzFdLCBiYXNlNjRUb0FycmF5QnVmZmVyKHJlcy5kYXRhLmNvbnRlbnQpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBnaXRsYWIucmVhZChmaWxlLnBhdGgpXHJcbiAgICAgICAgICAgIGlmIChyZXMgPT0gbnVsbCkgcmV0dXJuXHJcbiAgICAgICAgICAgIGFwcC52YXVsdC5hZGFwdGVyLndyaXRlQmluYXJ5KGZpbGUucGF0aCwgYmFzZTY0VG9BcnJheUJ1ZmZlcihyZXMuZGF0YS5jb250ZW50KSlcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5jLnNldE1lc3NhZ2UoJ0RvbmUnKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBuYy5oaWRlKCksIDEwMDAgKiA3KVxyXG5cclxuICAgICAgfSlcclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZmlsZV9tZW51X2RlbGV0ZV9maWxlID0gKG1lbnU6IE1lbnUsIGZpbGU6IFRBYnN0cmFjdEZpbGUpID0+IHtcclxuICBtZW51LmFkZEl0ZW0oKGl0ZW0pID0+IHtcclxuICAgIGl0ZW1cclxuICAgICAgLnNldFRpdGxlKFwiR2l0bGFiOiBEZWxldGUgRmlsZVwiKVxyXG4gICAgICAuc2V0SWNvbihcInRyYXNoLTJcIilcclxuICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5jID0gbmV3IE5vdGljZSgnRGVsZXRpbmcuLi4nLCAwKVxyXG4gICAgICAgIHJlcV9xdWV1ZS5hcHBlbmQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKChmaWxlIGFzIGFueSkuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgcmVhZF9mb2xkZXIgPSBhc3luYyAoZGlyOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgYXBwLnZhdWx0LmFkYXB0ZXIubGlzdChkaXIpXHJcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIGNvbnRlbnQuZmlsZXMpIHtcclxuICAgICAgICAgICAgICAgIG5jLnNldE1lc3NhZ2UocGF0aClcclxuICAgICAgICAgICAgICAgIGF3YWl0IGdpdGxhYi5kZWxldGUocGF0aClcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIGNvbnRlbnQuZm9sZGVycykge1xyXG4gICAgICAgICAgICAgICAgbmMuc2V0TWVzc2FnZShwYXRoKVxyXG4gICAgICAgICAgICAgICAgYXdhaXQgcmVhZF9mb2xkZXIocGF0aClcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXdhaXQgcmVhZF9mb2xkZXIoZmlsZS5wYXRoKVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXdhaXQgZ2l0bGFiLmRlbGV0ZShmaWxlLnBhdGgpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBuYy5zZXRNZXNzYWdlKCdEb25lJylcclxuICAgICAgICB9KVxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbmMuaGlkZSgpLCAxMDAwICogNSlcclxuICAgICAgfSlcclxuICB9KVxyXG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQSxpQkFBQUE7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsbUJBQStCOzs7QUNBL0Isc0JBQXdEOzs7QUNFekMsU0FBUixLQUFzQixJQUFJLFNBQVM7QUFDeEMsU0FBTyxTQUFTLE9BQU87QUFDckIsV0FBTyxHQUFHLE1BQU0sU0FBUyxTQUFTO0FBQUEsRUFDcEM7QUFDRjs7O0FDQUEsSUFBTSxFQUFDLFNBQVEsSUFBSSxPQUFPO0FBQzFCLElBQU0sRUFBQyxlQUFjLElBQUk7QUFFekIsSUFBTSxVQUFVLFdBQVMsV0FBUztBQUM5QixRQUFNLE1BQU0sU0FBUyxLQUFLLEtBQUs7QUFDL0IsU0FBTyxNQUFNLEdBQUcsTUFBTSxNQUFNLEdBQUcsSUFBSSxJQUFJLE1BQU0sR0FBRyxFQUFFLEVBQUUsWUFBWTtBQUNwRSxHQUFHLHVCQUFPLE9BQU8sSUFBSSxDQUFDO0FBRXRCLElBQU0sYUFBYSxDQUFDLFNBQVM7QUFDM0IsU0FBTyxLQUFLLFlBQVk7QUFDeEIsU0FBTyxDQUFDLFVBQVUsT0FBTyxLQUFLLE1BQU07QUFDdEM7QUFFQSxJQUFNLGFBQWEsVUFBUSxXQUFTLE9BQU8sVUFBVTtBQVNyRCxJQUFNLEVBQUMsUUFBTyxJQUFJO0FBU2xCLElBQU0sY0FBYyxXQUFXLFdBQVc7QUFTMUMsU0FBUyxTQUFTLEtBQUs7QUFDckIsU0FBTyxRQUFRLFFBQVEsQ0FBQyxZQUFZLEdBQUcsS0FBSyxJQUFJLGdCQUFnQixRQUFRLENBQUMsWUFBWSxJQUFJLFdBQVcsS0FDL0YsV0FBVyxJQUFJLFlBQVksUUFBUSxLQUFLLElBQUksWUFBWSxTQUFTLEdBQUc7QUFDM0U7QUFTQSxJQUFNLGdCQUFnQixXQUFXLGFBQWE7QUFVOUMsU0FBUyxrQkFBa0IsS0FBSztBQUM5QixNQUFJO0FBQ0osTUFBSyxPQUFPLGdCQUFnQixlQUFpQixZQUFZLFFBQVM7QUFDaEUsYUFBUyxZQUFZLE9BQU8sR0FBRztBQUFBLEVBQ2pDLE9BQU87QUFDTCxhQUFVLE9BQVMsSUFBSSxVQUFZLGNBQWMsSUFBSSxNQUFNO0FBQUEsRUFDN0Q7QUFDQSxTQUFPO0FBQ1Q7QUFTQSxJQUFNLFdBQVcsV0FBVyxRQUFRO0FBUXBDLElBQU0sYUFBYSxXQUFXLFVBQVU7QUFTeEMsSUFBTSxXQUFXLFdBQVcsUUFBUTtBQVNwQyxJQUFNLFdBQVcsQ0FBQyxVQUFVLFVBQVUsUUFBUSxPQUFPLFVBQVU7QUFRL0QsSUFBTSxZQUFZLFdBQVMsVUFBVSxRQUFRLFVBQVU7QUFTdkQsSUFBTSxnQkFBZ0IsQ0FBQyxRQUFRO0FBQzdCLE1BQUksT0FBTyxHQUFHLE1BQU0sVUFBVTtBQUM1QixXQUFPO0FBQUEsRUFDVDtBQUVBLFFBQU1DLGFBQVksZUFBZSxHQUFHO0FBQ3BDLFVBQVFBLGVBQWMsUUFBUUEsZUFBYyxPQUFPLGFBQWEsT0FBTyxlQUFlQSxVQUFTLE1BQU0sU0FBUyxFQUFFLE9BQU8sZUFBZSxRQUFRLEVBQUUsT0FBTyxZQUFZO0FBQ3JLO0FBU0EsSUFBTSxTQUFTLFdBQVcsTUFBTTtBQVNoQyxJQUFNLFNBQVMsV0FBVyxNQUFNO0FBU2hDLElBQU0sU0FBUyxXQUFXLE1BQU07QUFTaEMsSUFBTSxhQUFhLFdBQVcsVUFBVTtBQVN4QyxJQUFNLFdBQVcsQ0FBQyxRQUFRLFNBQVMsR0FBRyxLQUFLLFdBQVcsSUFBSSxJQUFJO0FBUzlELElBQU0sYUFBYSxDQUFDLFVBQVU7QUFDNUIsTUFBSTtBQUNKLFNBQU8sVUFDSixPQUFPLGFBQWEsY0FBYyxpQkFBaUIsWUFDbEQsV0FBVyxNQUFNLE1BQU0sT0FDcEIsT0FBTyxPQUFPLEtBQUssT0FBTztBQUFBLEVBRTFCLFNBQVMsWUFBWSxXQUFXLE1BQU0sUUFBUSxLQUFLLE1BQU0sU0FBUyxNQUFNO0FBSWpGO0FBU0EsSUFBTSxvQkFBb0IsV0FBVyxpQkFBaUI7QUFTdEQsSUFBTSxPQUFPLENBQUMsUUFBUSxJQUFJLE9BQ3hCLElBQUksS0FBSyxJQUFJLElBQUksUUFBUSxzQ0FBc0MsRUFBRTtBQWlCbkUsU0FBUyxRQUFRLEtBQUssSUFBSSxFQUFDLGFBQWEsTUFBSyxJQUFJLENBQUMsR0FBRztBQUVuRCxNQUFJLFFBQVEsUUFBUSxPQUFPLFFBQVEsYUFBYTtBQUM5QztBQUFBLEVBQ0Y7QUFFQSxNQUFJO0FBQ0osTUFBSTtBQUdKLE1BQUksT0FBTyxRQUFRLFVBQVU7QUFFM0IsVUFBTSxDQUFDLEdBQUc7QUFBQSxFQUNaO0FBRUEsTUFBSSxRQUFRLEdBQUcsR0FBRztBQUVoQixTQUFLLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxJQUFJLEdBQUcsS0FBSztBQUN0QyxTQUFHLEtBQUssTUFBTSxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUc7QUFBQSxJQUM5QjtBQUFBLEVBQ0YsT0FBTztBQUVMLFVBQU0sT0FBTyxhQUFhLE9BQU8sb0JBQW9CLEdBQUcsSUFBSSxPQUFPLEtBQUssR0FBRztBQUMzRSxVQUFNLE1BQU0sS0FBSztBQUNqQixRQUFJO0FBRUosU0FBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLEtBQUs7QUFDeEIsWUFBTSxLQUFLLENBQUM7QUFDWixTQUFHLEtBQUssTUFBTSxJQUFJLEdBQUcsR0FBRyxLQUFLLEdBQUc7QUFBQSxJQUNsQztBQUFBLEVBQ0Y7QUFDRjtBQUVBLFNBQVMsUUFBUSxLQUFLLEtBQUs7QUFDekIsUUFBTSxJQUFJLFlBQVk7QUFDdEIsUUFBTSxPQUFPLE9BQU8sS0FBSyxHQUFHO0FBQzVCLE1BQUksSUFBSSxLQUFLO0FBQ2IsTUFBSTtBQUNKLFNBQU8sTUFBTSxHQUFHO0FBQ2QsV0FBTyxLQUFLLENBQUM7QUFDYixRQUFJLFFBQVEsS0FBSyxZQUFZLEdBQUc7QUFDOUIsYUFBTztBQUFBLElBQ1Q7QUFBQSxFQUNGO0FBQ0EsU0FBTztBQUNUO0FBRUEsSUFBTSxXQUFXLE1BQU07QUFFckIsTUFBSSxPQUFPLGVBQWU7QUFBYSxXQUFPO0FBQzlDLFNBQU8sT0FBTyxTQUFTLGNBQWMsT0FBUSxPQUFPLFdBQVcsY0FBYyxTQUFTO0FBQ3hGLEdBQUc7QUFFSCxJQUFNLG1CQUFtQixDQUFDLFlBQVksQ0FBQyxZQUFZLE9BQU8sS0FBSyxZQUFZO0FBb0IzRSxTQUFTLFFBQW1DO0FBQzFDLFFBQU0sRUFBQyxTQUFRLElBQUksaUJBQWlCLElBQUksS0FBSyxRQUFRLENBQUM7QUFDdEQsUUFBTSxTQUFTLENBQUM7QUFDaEIsUUFBTSxjQUFjLENBQUMsS0FBSyxRQUFRO0FBQ2hDLFVBQU0sWUFBWSxZQUFZLFFBQVEsUUFBUSxHQUFHLEtBQUs7QUFDdEQsUUFBSSxjQUFjLE9BQU8sU0FBUyxDQUFDLEtBQUssY0FBYyxHQUFHLEdBQUc7QUFDMUQsYUFBTyxTQUFTLElBQUksTUFBTSxPQUFPLFNBQVMsR0FBRyxHQUFHO0FBQUEsSUFDbEQsV0FBVyxjQUFjLEdBQUcsR0FBRztBQUM3QixhQUFPLFNBQVMsSUFBSSxNQUFNLENBQUMsR0FBRyxHQUFHO0FBQUEsSUFDbkMsV0FBVyxRQUFRLEdBQUcsR0FBRztBQUN2QixhQUFPLFNBQVMsSUFBSSxJQUFJLE1BQU07QUFBQSxJQUNoQyxPQUFPO0FBQ0wsYUFBTyxTQUFTLElBQUk7QUFBQSxJQUN0QjtBQUFBLEVBQ0Y7QUFFQSxXQUFTLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxJQUFJLEdBQUcsS0FBSztBQUNoRCxjQUFVLENBQUMsS0FBSyxRQUFRLFVBQVUsQ0FBQyxHQUFHLFdBQVc7QUFBQSxFQUNuRDtBQUNBLFNBQU87QUFDVDtBQVlBLElBQU0sU0FBUyxDQUFDLEdBQUcsR0FBRyxTQUFTLEVBQUMsV0FBVSxJQUFHLENBQUMsTUFBTTtBQUNsRCxVQUFRLEdBQUcsQ0FBQyxLQUFLLFFBQVE7QUFDdkIsUUFBSSxXQUFXLFdBQVcsR0FBRyxHQUFHO0FBQzlCLFFBQUUsR0FBRyxJQUFJLEtBQUssS0FBSyxPQUFPO0FBQUEsSUFDNUIsT0FBTztBQUNMLFFBQUUsR0FBRyxJQUFJO0FBQUEsSUFDWDtBQUFBLEVBQ0YsR0FBRyxFQUFDLFdBQVUsQ0FBQztBQUNmLFNBQU87QUFDVDtBQVNBLElBQU0sV0FBVyxDQUFDLFlBQVk7QUFDNUIsTUFBSSxRQUFRLFdBQVcsQ0FBQyxNQUFNLE9BQVE7QUFDcEMsY0FBVSxRQUFRLE1BQU0sQ0FBQztBQUFBLEVBQzNCO0FBQ0EsU0FBTztBQUNUO0FBV0EsSUFBTSxXQUFXLENBQUMsYUFBYSxrQkFBa0IsT0FBT0MsaUJBQWdCO0FBQ3RFLGNBQVksWUFBWSxPQUFPLE9BQU8saUJBQWlCLFdBQVdBLFlBQVc7QUFDN0UsY0FBWSxVQUFVLGNBQWM7QUFDcEMsU0FBTyxlQUFlLGFBQWEsU0FBUztBQUFBLElBQzFDLE9BQU8saUJBQWlCO0FBQUEsRUFDMUIsQ0FBQztBQUNELFdBQVMsT0FBTyxPQUFPLFlBQVksV0FBVyxLQUFLO0FBQ3JEO0FBV0EsSUFBTSxlQUFlLENBQUMsV0FBVyxTQUFTQyxTQUFRLGVBQWU7QUFDL0QsTUFBSTtBQUNKLE1BQUk7QUFDSixNQUFJO0FBQ0osUUFBTSxTQUFTLENBQUM7QUFFaEIsWUFBVSxXQUFXLENBQUM7QUFFdEIsTUFBSSxhQUFhO0FBQU0sV0FBTztBQUU5QixLQUFHO0FBQ0QsWUFBUSxPQUFPLG9CQUFvQixTQUFTO0FBQzVDLFFBQUksTUFBTTtBQUNWLFdBQU8sTUFBTSxHQUFHO0FBQ2QsYUFBTyxNQUFNLENBQUM7QUFDZCxXQUFLLENBQUMsY0FBYyxXQUFXLE1BQU0sV0FBVyxPQUFPLE1BQU0sQ0FBQyxPQUFPLElBQUksR0FBRztBQUMxRSxnQkFBUSxJQUFJLElBQUksVUFBVSxJQUFJO0FBQzlCLGVBQU8sSUFBSSxJQUFJO0FBQUEsTUFDakI7QUFBQSxJQUNGO0FBQ0EsZ0JBQVlBLFlBQVcsU0FBUyxlQUFlLFNBQVM7QUFBQSxFQUMxRCxTQUFTLGNBQWMsQ0FBQ0EsV0FBVUEsUUFBTyxXQUFXLE9BQU8sTUFBTSxjQUFjLE9BQU87QUFFdEYsU0FBTztBQUNUO0FBV0EsSUFBTSxXQUFXLENBQUMsS0FBSyxjQUFjLGFBQWE7QUFDaEQsUUFBTSxPQUFPLEdBQUc7QUFDaEIsTUFBSSxhQUFhLFVBQWEsV0FBVyxJQUFJLFFBQVE7QUFDbkQsZUFBVyxJQUFJO0FBQUEsRUFDakI7QUFDQSxjQUFZLGFBQWE7QUFDekIsUUFBTSxZQUFZLElBQUksUUFBUSxjQUFjLFFBQVE7QUFDcEQsU0FBTyxjQUFjLE1BQU0sY0FBYztBQUMzQztBQVVBLElBQU0sVUFBVSxDQUFDLFVBQVU7QUFDekIsTUFBSSxDQUFDO0FBQU8sV0FBTztBQUNuQixNQUFJLFFBQVEsS0FBSztBQUFHLFdBQU87QUFDM0IsTUFBSSxJQUFJLE1BQU07QUFDZCxNQUFJLENBQUMsU0FBUyxDQUFDO0FBQUcsV0FBTztBQUN6QixRQUFNLE1BQU0sSUFBSSxNQUFNLENBQUM7QUFDdkIsU0FBTyxNQUFNLEdBQUc7QUFDZCxRQUFJLENBQUMsSUFBSSxNQUFNLENBQUM7QUFBQSxFQUNsQjtBQUNBLFNBQU87QUFDVDtBQVdBLElBQU0sZ0JBQWdCLGdCQUFjO0FBRWxDLFNBQU8sV0FBUztBQUNkLFdBQU8sY0FBYyxpQkFBaUI7QUFBQSxFQUN4QztBQUNGLEdBQUcsT0FBTyxlQUFlLGVBQWUsZUFBZSxVQUFVLENBQUM7QUFVbEUsSUFBTSxlQUFlLENBQUMsS0FBSyxPQUFPO0FBQ2hDLFFBQU0sWUFBWSxPQUFPLElBQUksT0FBTyxRQUFRO0FBRTVDLFFBQU0sV0FBVyxVQUFVLEtBQUssR0FBRztBQUVuQyxNQUFJO0FBRUosVUFBUSxTQUFTLFNBQVMsS0FBSyxNQUFNLENBQUMsT0FBTyxNQUFNO0FBQ2pELFVBQU0sT0FBTyxPQUFPO0FBQ3BCLE9BQUcsS0FBSyxLQUFLLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO0FBQUEsRUFDL0I7QUFDRjtBQVVBLElBQU0sV0FBVyxDQUFDLFFBQVEsUUFBUTtBQUNoQyxNQUFJO0FBQ0osUUFBTSxNQUFNLENBQUM7QUFFYixVQUFRLFVBQVUsT0FBTyxLQUFLLEdBQUcsT0FBTyxNQUFNO0FBQzVDLFFBQUksS0FBSyxPQUFPO0FBQUEsRUFDbEI7QUFFQSxTQUFPO0FBQ1Q7QUFHQSxJQUFNLGFBQWEsV0FBVyxpQkFBaUI7QUFFL0MsSUFBTSxjQUFjLFNBQU87QUFDekIsU0FBTyxJQUFJLFlBQVksRUFBRTtBQUFBLElBQVE7QUFBQSxJQUMvQixTQUFTLFNBQVMsR0FBRyxJQUFJLElBQUk7QUFDM0IsYUFBTyxHQUFHLFlBQVksSUFBSTtBQUFBLElBQzVCO0FBQUEsRUFDRjtBQUNGO0FBR0EsSUFBTSxrQkFBa0IsQ0FBQyxFQUFDLGdCQUFBQyxnQkFBYyxNQUFNLENBQUMsS0FBSyxTQUFTQSxnQkFBZSxLQUFLLEtBQUssSUFBSSxHQUFHLE9BQU8sU0FBUztBQVM3RyxJQUFNLFdBQVcsV0FBVyxRQUFRO0FBRXBDLElBQU0sb0JBQW9CLENBQUMsS0FBSyxZQUFZO0FBQzFDLFFBQU1GLGVBQWMsT0FBTywwQkFBMEIsR0FBRztBQUN4RCxRQUFNLHFCQUFxQixDQUFDO0FBRTVCLFVBQVFBLGNBQWEsQ0FBQyxZQUFZLFNBQVM7QUFDekMsUUFBSTtBQUNKLFNBQUssTUFBTSxRQUFRLFlBQVksTUFBTSxHQUFHLE9BQU8sT0FBTztBQUNwRCx5QkFBbUIsSUFBSSxJQUFJLE9BQU87QUFBQSxJQUNwQztBQUFBLEVBQ0YsQ0FBQztBQUVELFNBQU8saUJBQWlCLEtBQUssa0JBQWtCO0FBQ2pEO0FBT0EsSUFBTSxnQkFBZ0IsQ0FBQyxRQUFRO0FBQzdCLG9CQUFrQixLQUFLLENBQUMsWUFBWSxTQUFTO0FBRTNDLFFBQUksV0FBVyxHQUFHLEtBQUssQ0FBQyxhQUFhLFVBQVUsUUFBUSxFQUFFLFFBQVEsSUFBSSxNQUFNLElBQUk7QUFDN0UsYUFBTztBQUFBLElBQ1Q7QUFFQSxVQUFNLFFBQVEsSUFBSSxJQUFJO0FBRXRCLFFBQUksQ0FBQyxXQUFXLEtBQUs7QUFBRztBQUV4QixlQUFXLGFBQWE7QUFFeEIsUUFBSSxjQUFjLFlBQVk7QUFDNUIsaUJBQVcsV0FBVztBQUN0QjtBQUFBLElBQ0Y7QUFFQSxRQUFJLENBQUMsV0FBVyxLQUFLO0FBQ25CLGlCQUFXLE1BQU0sTUFBTTtBQUNyQixjQUFNLE1BQU0sdUNBQXdDLE9BQU8sR0FBSTtBQUFBLE1BQ2pFO0FBQUEsSUFDRjtBQUFBLEVBQ0YsQ0FBQztBQUNIO0FBRUEsSUFBTSxjQUFjLENBQUMsZUFBZSxjQUFjO0FBQ2hELFFBQU0sTUFBTSxDQUFDO0FBRWIsUUFBTSxTQUFTLENBQUMsUUFBUTtBQUN0QixRQUFJLFFBQVEsV0FBUztBQUNuQixVQUFJLEtBQUssSUFBSTtBQUFBLElBQ2YsQ0FBQztBQUFBLEVBQ0g7QUFFQSxVQUFRLGFBQWEsSUFBSSxPQUFPLGFBQWEsSUFBSSxPQUFPLE9BQU8sYUFBYSxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBRTlGLFNBQU87QUFDVDtBQUVBLElBQU0sT0FBTyxNQUFNO0FBQUM7QUFFcEIsSUFBTSxpQkFBaUIsQ0FBQyxPQUFPLGlCQUFpQjtBQUM5QyxVQUFRLENBQUM7QUFDVCxTQUFPLE9BQU8sU0FBUyxLQUFLLElBQUksUUFBUTtBQUMxQztBQUVBLElBQU0sUUFBUTtBQUVkLElBQU0sUUFBUTtBQUVkLElBQU0sV0FBVztBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsRUFDQSxhQUFhLFFBQVEsTUFBTSxZQUFZLElBQUk7QUFDN0M7QUFFQSxJQUFNLGlCQUFpQixDQUFDLE9BQU8sSUFBSSxXQUFXLFNBQVMsZ0JBQWdCO0FBQ3JFLE1BQUksTUFBTTtBQUNWLFFBQU0sRUFBQyxPQUFNLElBQUk7QUFDakIsU0FBTyxRQUFRO0FBQ2IsV0FBTyxTQUFTLEtBQUssT0FBTyxJQUFJLFNBQU8sQ0FBQztBQUFBLEVBQzFDO0FBRUEsU0FBTztBQUNUO0FBU0EsU0FBUyxvQkFBb0IsT0FBTztBQUNsQyxTQUFPLENBQUMsRUFBRSxTQUFTLFdBQVcsTUFBTSxNQUFNLEtBQUssTUFBTSxPQUFPLFdBQVcsTUFBTSxjQUFjLE1BQU0sT0FBTyxRQUFRO0FBQ2xIO0FBRUEsSUFBTSxlQUFlLENBQUMsUUFBUTtBQUM1QixRQUFNLFFBQVEsSUFBSSxNQUFNLEVBQUU7QUFFMUIsUUFBTSxRQUFRLENBQUMsUUFBUSxNQUFNO0FBRTNCLFFBQUksU0FBUyxNQUFNLEdBQUc7QUFDcEIsVUFBSSxNQUFNLFFBQVEsTUFBTSxLQUFLLEdBQUc7QUFDOUI7QUFBQSxNQUNGO0FBRUEsVUFBRyxFQUFFLFlBQVksU0FBUztBQUN4QixjQUFNLENBQUMsSUFBSTtBQUNYLGNBQU0sU0FBUyxRQUFRLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQztBQUV2QyxnQkFBUSxRQUFRLENBQUMsT0FBTyxRQUFRO0FBQzlCLGdCQUFNLGVBQWUsTUFBTSxPQUFPLElBQUksQ0FBQztBQUN2QyxXQUFDLFlBQVksWUFBWSxNQUFNLE9BQU8sR0FBRyxJQUFJO0FBQUEsUUFDL0MsQ0FBQztBQUVELGNBQU0sQ0FBQyxJQUFJO0FBRVgsZUFBTztBQUFBLE1BQ1Q7QUFBQSxJQUNGO0FBRUEsV0FBTztBQUFBLEVBQ1Q7QUFFQSxTQUFPLE1BQU0sS0FBSyxDQUFDO0FBQ3JCO0FBRUEsSUFBTSxZQUFZLFdBQVcsZUFBZTtBQUU1QyxJQUFNLGFBQWEsQ0FBQyxVQUNsQixVQUFVLFNBQVMsS0FBSyxLQUFLLFdBQVcsS0FBSyxNQUFNLFdBQVcsTUFBTSxJQUFJLEtBQUssV0FBVyxNQUFNLEtBQUs7QUFFckcsSUFBTyxnQkFBUTtBQUFBLEVBQ2I7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQSxZQUFZO0FBQUE7QUFBQSxFQUNaO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQSxRQUFRO0FBQUEsRUFDUjtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUNGOzs7QUNuc0JBLFNBQVMsV0FBVyxTQUFTLE1BQU0sUUFBUSxTQUFTLFVBQVU7QUFDNUQsUUFBTSxLQUFLLElBQUk7QUFFZixNQUFJLE1BQU0sbUJBQW1CO0FBQzNCLFVBQU0sa0JBQWtCLE1BQU0sS0FBSyxXQUFXO0FBQUEsRUFDaEQsT0FBTztBQUNMLFNBQUssUUFBUyxJQUFJLE1BQU0sRUFBRztBQUFBLEVBQzdCO0FBRUEsT0FBSyxVQUFVO0FBQ2YsT0FBSyxPQUFPO0FBQ1osV0FBUyxLQUFLLE9BQU87QUFDckIsYUFBVyxLQUFLLFNBQVM7QUFDekIsY0FBWSxLQUFLLFVBQVU7QUFDM0IsZUFBYSxLQUFLLFdBQVc7QUFDL0I7QUFFQSxjQUFNLFNBQVMsWUFBWSxPQUFPO0FBQUEsRUFDaEMsUUFBUSxTQUFTLFNBQVM7QUFDeEIsV0FBTztBQUFBO0FBQUEsTUFFTCxTQUFTLEtBQUs7QUFBQSxNQUNkLE1BQU0sS0FBSztBQUFBO0FBQUEsTUFFWCxhQUFhLEtBQUs7QUFBQSxNQUNsQixRQUFRLEtBQUs7QUFBQTtBQUFBLE1BRWIsVUFBVSxLQUFLO0FBQUEsTUFDZixZQUFZLEtBQUs7QUFBQSxNQUNqQixjQUFjLEtBQUs7QUFBQSxNQUNuQixPQUFPLEtBQUs7QUFBQTtBQUFBLE1BRVosUUFBUSxjQUFNLGFBQWEsS0FBSyxNQUFNO0FBQUEsTUFDdEMsTUFBTSxLQUFLO0FBQUEsTUFDWCxRQUFRLEtBQUssWUFBWSxLQUFLLFNBQVMsU0FBUyxLQUFLLFNBQVMsU0FBUztBQUFBLElBQ3pFO0FBQUEsRUFDRjtBQUNGLENBQUM7QUFFRCxJQUFNLFlBQVksV0FBVztBQUM3QixJQUFNLGNBQWMsQ0FBQztBQUVyQjtBQUFBLEVBQ0U7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBO0FBRUYsRUFBRSxRQUFRLFVBQVE7QUFDaEIsY0FBWSxJQUFJLElBQUksRUFBQyxPQUFPLEtBQUk7QUFDbEMsQ0FBQztBQUVELE9BQU8saUJBQWlCLFlBQVksV0FBVztBQUMvQyxPQUFPLGVBQWUsV0FBVyxnQkFBZ0IsRUFBQyxPQUFPLEtBQUksQ0FBQztBQUc5RCxXQUFXLE9BQU8sQ0FBQyxPQUFPLE1BQU0sUUFBUSxTQUFTLFVBQVUsZ0JBQWdCO0FBQ3pFLFFBQU0sYUFBYSxPQUFPLE9BQU8sU0FBUztBQUUxQyxnQkFBTSxhQUFhLE9BQU8sWUFBWSxTQUFTRyxRQUFPLEtBQUs7QUFDekQsV0FBTyxRQUFRLE1BQU07QUFBQSxFQUN2QixHQUFHLFVBQVE7QUFDVCxXQUFPLFNBQVM7QUFBQSxFQUNsQixDQUFDO0FBRUQsYUFBVyxLQUFLLFlBQVksTUFBTSxTQUFTLE1BQU0sUUFBUSxTQUFTLFFBQVE7QUFFMUUsYUFBVyxRQUFRO0FBRW5CLGFBQVcsT0FBTyxNQUFNO0FBRXhCLGlCQUFlLE9BQU8sT0FBTyxZQUFZLFdBQVc7QUFFcEQsU0FBTztBQUNUO0FBRUEsSUFBTyxxQkFBUTs7O0FDbEdmLElBQU8sZUFBUTs7O0FDYWYsU0FBUyxZQUFZLE9BQU87QUFDMUIsU0FBTyxjQUFNLGNBQWMsS0FBSyxLQUFLLGNBQU0sUUFBUSxLQUFLO0FBQzFEO0FBU0EsU0FBUyxlQUFlLEtBQUs7QUFDM0IsU0FBTyxjQUFNLFNBQVMsS0FBSyxJQUFJLElBQUksSUFBSSxNQUFNLEdBQUcsRUFBRSxJQUFJO0FBQ3hEO0FBV0EsU0FBUyxVQUFVQyxPQUFNLEtBQUssTUFBTTtBQUNsQyxNQUFJLENBQUNBO0FBQU0sV0FBTztBQUNsQixTQUFPQSxNQUFLLE9BQU8sR0FBRyxFQUFFLElBQUksU0FBUyxLQUFLLE9BQU8sR0FBRztBQUVsRCxZQUFRLGVBQWUsS0FBSztBQUM1QixXQUFPLENBQUMsUUFBUSxJQUFJLE1BQU0sUUFBUSxNQUFNO0FBQUEsRUFDMUMsQ0FBQyxFQUFFLEtBQUssT0FBTyxNQUFNLEVBQUU7QUFDekI7QUFTQSxTQUFTLFlBQVksS0FBSztBQUN4QixTQUFPLGNBQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxJQUFJLEtBQUssV0FBVztBQUNwRDtBQUVBLElBQU0sYUFBYSxjQUFNLGFBQWEsZUFBTyxDQUFDLEdBQUcsTUFBTSxTQUFTLE9BQU8sTUFBTTtBQUMzRSxTQUFPLFdBQVcsS0FBSyxJQUFJO0FBQzdCLENBQUM7QUF5QkQsU0FBUyxXQUFXLEtBQUssVUFBVSxTQUFTO0FBQzFDLE1BQUksQ0FBQyxjQUFNLFNBQVMsR0FBRyxHQUFHO0FBQ3hCLFVBQU0sSUFBSSxVQUFVLDBCQUEwQjtBQUFBLEVBQ2hEO0FBR0EsYUFBVyxZQUFZLEtBQUssZ0JBQW9CLFVBQVU7QUFHMUQsWUFBVSxjQUFNLGFBQWEsU0FBUztBQUFBLElBQ3BDLFlBQVk7QUFBQSxJQUNaLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxFQUNYLEdBQUcsT0FBTyxTQUFTLFFBQVEsUUFBUSxRQUFRO0FBRXpDLFdBQU8sQ0FBQyxjQUFNLFlBQVksT0FBTyxNQUFNLENBQUM7QUFBQSxFQUMxQyxDQUFDO0FBRUQsUUFBTSxhQUFhLFFBQVE7QUFFM0IsUUFBTSxVQUFVLFFBQVEsV0FBVztBQUNuQyxRQUFNLE9BQU8sUUFBUTtBQUNyQixRQUFNLFVBQVUsUUFBUTtBQUN4QixRQUFNLFFBQVEsUUFBUSxRQUFRLE9BQU8sU0FBUyxlQUFlO0FBQzdELFFBQU0sVUFBVSxTQUFTLGNBQU0sb0JBQW9CLFFBQVE7QUFFM0QsTUFBSSxDQUFDLGNBQU0sV0FBVyxPQUFPLEdBQUc7QUFDOUIsVUFBTSxJQUFJLFVBQVUsNEJBQTRCO0FBQUEsRUFDbEQ7QUFFQSxXQUFTLGFBQWEsT0FBTztBQUMzQixRQUFJLFVBQVU7QUFBTSxhQUFPO0FBRTNCLFFBQUksY0FBTSxPQUFPLEtBQUssR0FBRztBQUN2QixhQUFPLE1BQU0sWUFBWTtBQUFBLElBQzNCO0FBRUEsUUFBSSxDQUFDLFdBQVcsY0FBTSxPQUFPLEtBQUssR0FBRztBQUNuQyxZQUFNLElBQUksbUJBQVcsOENBQThDO0FBQUEsSUFDckU7QUFFQSxRQUFJLGNBQU0sY0FBYyxLQUFLLEtBQUssY0FBTSxhQUFhLEtBQUssR0FBRztBQUMzRCxhQUFPLFdBQVcsT0FBTyxTQUFTLGFBQWEsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksT0FBTyxLQUFLLEtBQUs7QUFBQSxJQUN0RjtBQUVBLFdBQU87QUFBQSxFQUNUO0FBWUEsV0FBUyxlQUFlLE9BQU8sS0FBS0EsT0FBTTtBQUN4QyxRQUFJLE1BQU07QUFFVixRQUFJLFNBQVMsQ0FBQ0EsU0FBUSxPQUFPLFVBQVUsVUFBVTtBQUMvQyxVQUFJLGNBQU0sU0FBUyxLQUFLLElBQUksR0FBRztBQUU3QixjQUFNLGFBQWEsTUFBTSxJQUFJLE1BQU0sR0FBRyxFQUFFO0FBRXhDLGdCQUFRLEtBQUssVUFBVSxLQUFLO0FBQUEsTUFDOUIsV0FDRyxjQUFNLFFBQVEsS0FBSyxLQUFLLFlBQVksS0FBSyxNQUN4QyxjQUFNLFdBQVcsS0FBSyxLQUFLLGNBQU0sU0FBUyxLQUFLLElBQUksT0FBTyxNQUFNLGNBQU0sUUFBUSxLQUFLLElBQ2xGO0FBRUgsY0FBTSxlQUFlLEdBQUc7QUFFeEIsWUFBSSxRQUFRLFNBQVMsS0FBSyxJQUFJLE9BQU87QUFDbkMsWUFBRSxjQUFNLFlBQVksRUFBRSxLQUFLLE9BQU8sU0FBUyxTQUFTO0FBQUE7QUFBQSxZQUVsRCxZQUFZLE9BQU8sVUFBVSxDQUFDLEdBQUcsR0FBRyxPQUFPLElBQUksSUFBSyxZQUFZLE9BQU8sTUFBTSxNQUFNO0FBQUEsWUFDbkYsYUFBYSxFQUFFO0FBQUEsVUFDakI7QUFBQSxRQUNGLENBQUM7QUFDRCxlQUFPO0FBQUEsTUFDVDtBQUFBLElBQ0Y7QUFFQSxRQUFJLFlBQVksS0FBSyxHQUFHO0FBQ3RCLGFBQU87QUFBQSxJQUNUO0FBRUEsYUFBUyxPQUFPLFVBQVVBLE9BQU0sS0FBSyxJQUFJLEdBQUcsYUFBYSxLQUFLLENBQUM7QUFFL0QsV0FBTztBQUFBLEVBQ1Q7QUFFQSxRQUFNLFFBQVEsQ0FBQztBQUVmLFFBQU0saUJBQWlCLE9BQU8sT0FBTyxZQUFZO0FBQUEsSUFDL0M7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0YsQ0FBQztBQUVELFdBQVMsTUFBTSxPQUFPQSxPQUFNO0FBQzFCLFFBQUksY0FBTSxZQUFZLEtBQUs7QUFBRztBQUU5QixRQUFJLE1BQU0sUUFBUSxLQUFLLE1BQU0sSUFBSTtBQUMvQixZQUFNLE1BQU0sb0NBQW9DQSxNQUFLLEtBQUssR0FBRyxDQUFDO0FBQUEsSUFDaEU7QUFFQSxVQUFNLEtBQUssS0FBSztBQUVoQixrQkFBTSxRQUFRLE9BQU8sU0FBUyxLQUFLLElBQUksS0FBSztBQUMxQyxZQUFNLFNBQVMsRUFBRSxjQUFNLFlBQVksRUFBRSxLQUFLLE9BQU8sU0FBUyxRQUFRO0FBQUEsUUFDaEU7QUFBQSxRQUFVO0FBQUEsUUFBSSxjQUFNLFNBQVMsR0FBRyxJQUFJLElBQUksS0FBSyxJQUFJO0FBQUEsUUFBS0E7QUFBQSxRQUFNO0FBQUEsTUFDOUQ7QUFFQSxVQUFJLFdBQVcsTUFBTTtBQUNuQixjQUFNLElBQUlBLFFBQU9BLE1BQUssT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7QUFBQSxNQUMzQztBQUFBLElBQ0YsQ0FBQztBQUVELFVBQU0sSUFBSTtBQUFBLEVBQ1o7QUFFQSxNQUFJLENBQUMsY0FBTSxTQUFTLEdBQUcsR0FBRztBQUN4QixVQUFNLElBQUksVUFBVSx3QkFBd0I7QUFBQSxFQUM5QztBQUVBLFFBQU0sR0FBRztBQUVULFNBQU87QUFDVDtBQUVBLElBQU8scUJBQVE7OztBQzlNZixTQUFTLE9BQU8sS0FBSztBQUNuQixRQUFNLFVBQVU7QUFBQSxJQUNkLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLE9BQU87QUFBQSxJQUNQLE9BQU87QUFBQSxFQUNUO0FBQ0EsU0FBTyxtQkFBbUIsR0FBRyxFQUFFLFFBQVEsb0JBQW9CLFNBQVMsU0FBUyxPQUFPO0FBQ2xGLFdBQU8sUUFBUSxLQUFLO0FBQUEsRUFDdEIsQ0FBQztBQUNIO0FBVUEsU0FBUyxxQkFBcUIsUUFBUSxTQUFTO0FBQzdDLE9BQUssU0FBUyxDQUFDO0FBRWYsWUFBVSxtQkFBVyxRQUFRLE1BQU0sT0FBTztBQUM1QztBQUVBLElBQU1DLGFBQVkscUJBQXFCO0FBRXZDQSxXQUFVLFNBQVMsU0FBUyxPQUFPLE1BQU0sT0FBTztBQUM5QyxPQUFLLE9BQU8sS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDO0FBQ2hDO0FBRUFBLFdBQVUsV0FBVyxTQUFTQyxVQUFTLFNBQVM7QUFDOUMsUUFBTSxVQUFVLFVBQVUsU0FBUyxPQUFPO0FBQ3hDLFdBQU8sUUFBUSxLQUFLLE1BQU0sT0FBTyxNQUFNO0FBQUEsRUFDekMsSUFBSTtBQUVKLFNBQU8sS0FBSyxPQUFPLElBQUksU0FBUyxLQUFLLE1BQU07QUFDekMsV0FBTyxRQUFRLEtBQUssQ0FBQyxDQUFDLElBQUksTUFBTSxRQUFRLEtBQUssQ0FBQyxDQUFDO0FBQUEsRUFDakQsR0FBRyxFQUFFLEVBQUUsS0FBSyxHQUFHO0FBQ2pCO0FBRUEsSUFBTywrQkFBUTs7O0FDNUNmLFNBQVNDLFFBQU8sS0FBSztBQUNuQixTQUFPLG1CQUFtQixHQUFHLEVBQzNCLFFBQVEsU0FBUyxHQUFHLEVBQ3BCLFFBQVEsUUFBUSxHQUFHLEVBQ25CLFFBQVEsU0FBUyxHQUFHLEVBQ3BCLFFBQVEsUUFBUSxHQUFHLEVBQ25CLFFBQVEsU0FBUyxHQUFHLEVBQ3BCLFFBQVEsU0FBUyxHQUFHO0FBQ3hCO0FBV2UsU0FBUixTQUEwQixLQUFLLFFBQVEsU0FBUztBQUVyRCxNQUFJLENBQUMsUUFBUTtBQUNYLFdBQU87QUFBQSxFQUNUO0FBRUEsUUFBTSxVQUFVLFdBQVcsUUFBUSxVQUFVQTtBQUU3QyxRQUFNLGNBQWMsV0FBVyxRQUFRO0FBRXZDLE1BQUk7QUFFSixNQUFJLGFBQWE7QUFDZix1QkFBbUIsWUFBWSxRQUFRLE9BQU87QUFBQSxFQUNoRCxPQUFPO0FBQ0wsdUJBQW1CLGNBQU0sa0JBQWtCLE1BQU0sSUFDL0MsT0FBTyxTQUFTLElBQ2hCLElBQUksNkJBQXFCLFFBQVEsT0FBTyxFQUFFLFNBQVMsT0FBTztBQUFBLEVBQzlEO0FBRUEsTUFBSSxrQkFBa0I7QUFDcEIsVUFBTSxnQkFBZ0IsSUFBSSxRQUFRLEdBQUc7QUFFckMsUUFBSSxrQkFBa0IsSUFBSTtBQUN4QixZQUFNLElBQUksTUFBTSxHQUFHLGFBQWE7QUFBQSxJQUNsQztBQUNBLFlBQVEsSUFBSSxRQUFRLEdBQUcsTUFBTSxLQUFLLE1BQU0sT0FBTztBQUFBLEVBQ2pEO0FBRUEsU0FBTztBQUNUOzs7QUMxREEsSUFBTSxxQkFBTixNQUF5QjtBQUFBLEVBQ3ZCLGNBQWM7QUFDWixTQUFLLFdBQVcsQ0FBQztBQUFBLEVBQ25CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBVUEsSUFBSSxXQUFXLFVBQVUsU0FBUztBQUNoQyxTQUFLLFNBQVMsS0FBSztBQUFBLE1BQ2pCO0FBQUEsTUFDQTtBQUFBLE1BQ0EsYUFBYSxVQUFVLFFBQVEsY0FBYztBQUFBLE1BQzdDLFNBQVMsVUFBVSxRQUFRLFVBQVU7QUFBQSxJQUN2QyxDQUFDO0FBQ0QsV0FBTyxLQUFLLFNBQVMsU0FBUztBQUFBLEVBQ2hDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVNBLE1BQU0sSUFBSTtBQUNSLFFBQUksS0FBSyxTQUFTLEVBQUUsR0FBRztBQUNyQixXQUFLLFNBQVMsRUFBRSxJQUFJO0FBQUEsSUFDdEI7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsUUFBUTtBQUNOLFFBQUksS0FBSyxVQUFVO0FBQ2pCLFdBQUssV0FBVyxDQUFDO0FBQUEsSUFDbkI7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVlBLFFBQVEsSUFBSTtBQUNWLGtCQUFNLFFBQVEsS0FBSyxVQUFVLFNBQVMsZUFBZSxHQUFHO0FBQ3RELFVBQUksTUFBTSxNQUFNO0FBQ2QsV0FBRyxDQUFDO0FBQUEsTUFDTjtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0g7QUFDRjtBQUVBLElBQU8sNkJBQVE7OztBQ3BFZixJQUFPLHVCQUFRO0FBQUEsRUFDYixtQkFBbUI7QUFBQSxFQUNuQixtQkFBbUI7QUFBQSxFQUNuQixxQkFBcUI7QUFDdkI7OztBQ0hBLElBQU8sMEJBQVEsT0FBTyxvQkFBb0IsY0FBYyxrQkFBa0I7OztBQ0QxRSxJQUFPLG1CQUFRLE9BQU8sYUFBYSxjQUFjLFdBQVc7OztBQ0E1RCxJQUFPLGVBQVEsT0FBTyxTQUFTLGNBQWMsT0FBTzs7O0FDRXBELElBQU8sa0JBQVE7QUFBQSxFQUNiLFdBQVc7QUFBQSxFQUNYLFNBQVM7QUFBQSxJQUNQO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNGO0FBQUEsRUFDQSxXQUFXLENBQUMsUUFBUSxTQUFTLFFBQVEsUUFBUSxPQUFPLE1BQU07QUFDNUQ7OztBQ1pBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQU0sZ0JBQWdCLE9BQU8sV0FBVyxlQUFlLE9BQU8sYUFBYTtBQW1CM0UsSUFBTSx5QkFDSixDQUFDLFlBQVk7QUFDWCxTQUFPLGlCQUFpQixDQUFDLGVBQWUsZ0JBQWdCLElBQUksRUFBRSxRQUFRLE9BQU8sSUFBSTtBQUNuRixHQUFHLE9BQU8sY0FBYyxlQUFlLFVBQVUsT0FBTztBQVcxRCxJQUFNLGtDQUFrQyxNQUFNO0FBQzVDLFNBQ0UsT0FBTyxzQkFBc0I7QUFBQSxFQUU3QixnQkFBZ0IscUJBQ2hCLE9BQU8sS0FBSyxrQkFBa0I7QUFFbEMsR0FBRzs7O0FDckNILElBQU8sbUJBQVE7QUFBQSxFQUNiLEdBQUc7QUFBQSxFQUNILEdBQUc7QUFDTDs7O0FDQWUsU0FBUixpQkFBa0MsTUFBTSxTQUFTO0FBQ3RELFNBQU8sbUJBQVcsTUFBTSxJQUFJLGlCQUFTLFFBQVEsZ0JBQWdCLEdBQUcsT0FBTyxPQUFPO0FBQUEsSUFDNUUsU0FBUyxTQUFTLE9BQU8sS0FBS0MsT0FBTSxTQUFTO0FBQzNDLFVBQUksaUJBQVMsVUFBVSxjQUFNLFNBQVMsS0FBSyxHQUFHO0FBQzVDLGFBQUssT0FBTyxLQUFLLE1BQU0sU0FBUyxRQUFRLENBQUM7QUFDekMsZUFBTztBQUFBLE1BQ1Q7QUFFQSxhQUFPLFFBQVEsZUFBZSxNQUFNLE1BQU0sU0FBUztBQUFBLElBQ3JEO0FBQUEsRUFDRixHQUFHLE9BQU8sQ0FBQztBQUNiOzs7QUNOQSxTQUFTLGNBQWMsTUFBTTtBQUszQixTQUFPLGNBQU0sU0FBUyxpQkFBaUIsSUFBSSxFQUFFLElBQUksV0FBUztBQUN4RCxXQUFPLE1BQU0sQ0FBQyxNQUFNLE9BQU8sS0FBSyxNQUFNLENBQUMsS0FBSyxNQUFNLENBQUM7QUFBQSxFQUNyRCxDQUFDO0FBQ0g7QUFTQSxTQUFTLGNBQWMsS0FBSztBQUMxQixRQUFNLE1BQU0sQ0FBQztBQUNiLFFBQU0sT0FBTyxPQUFPLEtBQUssR0FBRztBQUM1QixNQUFJO0FBQ0osUUFBTSxNQUFNLEtBQUs7QUFDakIsTUFBSTtBQUNKLE9BQUssSUFBSSxHQUFHLElBQUksS0FBSyxLQUFLO0FBQ3hCLFVBQU0sS0FBSyxDQUFDO0FBQ1osUUFBSSxHQUFHLElBQUksSUFBSSxHQUFHO0FBQUEsRUFDcEI7QUFDQSxTQUFPO0FBQ1Q7QUFTQSxTQUFTLGVBQWUsVUFBVTtBQUNoQyxXQUFTLFVBQVVDLE9BQU0sT0FBTyxRQUFRLE9BQU87QUFDN0MsUUFBSSxPQUFPQSxNQUFLLE9BQU87QUFDdkIsVUFBTSxlQUFlLE9BQU8sU0FBUyxDQUFDLElBQUk7QUFDMUMsVUFBTSxTQUFTLFNBQVNBLE1BQUs7QUFDN0IsV0FBTyxDQUFDLFFBQVEsY0FBTSxRQUFRLE1BQU0sSUFBSSxPQUFPLFNBQVM7QUFFeEQsUUFBSSxRQUFRO0FBQ1YsVUFBSSxjQUFNLFdBQVcsUUFBUSxJQUFJLEdBQUc7QUFDbEMsZUFBTyxJQUFJLElBQUksQ0FBQyxPQUFPLElBQUksR0FBRyxLQUFLO0FBQUEsTUFDckMsT0FBTztBQUNMLGVBQU8sSUFBSSxJQUFJO0FBQUEsTUFDakI7QUFFQSxhQUFPLENBQUM7QUFBQSxJQUNWO0FBRUEsUUFBSSxDQUFDLE9BQU8sSUFBSSxLQUFLLENBQUMsY0FBTSxTQUFTLE9BQU8sSUFBSSxDQUFDLEdBQUc7QUFDbEQsYUFBTyxJQUFJLElBQUksQ0FBQztBQUFBLElBQ2xCO0FBRUEsVUFBTSxTQUFTLFVBQVVBLE9BQU0sT0FBTyxPQUFPLElBQUksR0FBRyxLQUFLO0FBRXpELFFBQUksVUFBVSxjQUFNLFFBQVEsT0FBTyxJQUFJLENBQUMsR0FBRztBQUN6QyxhQUFPLElBQUksSUFBSSxjQUFjLE9BQU8sSUFBSSxDQUFDO0FBQUEsSUFDM0M7QUFFQSxXQUFPLENBQUM7QUFBQSxFQUNWO0FBRUEsTUFBSSxjQUFNLFdBQVcsUUFBUSxLQUFLLGNBQU0sV0FBVyxTQUFTLE9BQU8sR0FBRztBQUNwRSxVQUFNLE1BQU0sQ0FBQztBQUViLGtCQUFNLGFBQWEsVUFBVSxDQUFDLE1BQU0sVUFBVTtBQUM1QyxnQkFBVSxjQUFjLElBQUksR0FBRyxPQUFPLEtBQUssQ0FBQztBQUFBLElBQzlDLENBQUM7QUFFRCxXQUFPO0FBQUEsRUFDVDtBQUVBLFNBQU87QUFDVDtBQUVBLElBQU8seUJBQVE7OztBQ3ZFZixTQUFTLGdCQUFnQixVQUFVLFFBQVEsU0FBUztBQUNsRCxNQUFJLGNBQU0sU0FBUyxRQUFRLEdBQUc7QUFDNUIsUUFBSTtBQUNGLE9BQUMsVUFBVSxLQUFLLE9BQU8sUUFBUTtBQUMvQixhQUFPLGNBQU0sS0FBSyxRQUFRO0FBQUEsSUFDNUIsU0FBUyxHQUFQO0FBQ0EsVUFBSSxFQUFFLFNBQVMsZUFBZTtBQUM1QixjQUFNO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBRUEsVUFBUSxXQUFXLEtBQUssV0FBVyxRQUFRO0FBQzdDO0FBRUEsSUFBTSxXQUFXO0FBQUEsRUFFZixjQUFjO0FBQUEsRUFFZCxTQUFTLENBQUMsT0FBTyxNQUFNO0FBQUEsRUFFdkIsa0JBQWtCLENBQUMsU0FBUyxpQkFBaUIsTUFBTSxTQUFTO0FBQzFELFVBQU0sY0FBYyxRQUFRLGVBQWUsS0FBSztBQUNoRCxVQUFNLHFCQUFxQixZQUFZLFFBQVEsa0JBQWtCLElBQUk7QUFDckUsVUFBTSxrQkFBa0IsY0FBTSxTQUFTLElBQUk7QUFFM0MsUUFBSSxtQkFBbUIsY0FBTSxXQUFXLElBQUksR0FBRztBQUM3QyxhQUFPLElBQUksU0FBUyxJQUFJO0FBQUEsSUFDMUI7QUFFQSxVQUFNQyxjQUFhLGNBQU0sV0FBVyxJQUFJO0FBRXhDLFFBQUlBLGFBQVk7QUFDZCxVQUFJLENBQUMsb0JBQW9CO0FBQ3ZCLGVBQU87QUFBQSxNQUNUO0FBQ0EsYUFBTyxxQkFBcUIsS0FBSyxVQUFVLHVCQUFlLElBQUksQ0FBQyxJQUFJO0FBQUEsSUFDckU7QUFFQSxRQUFJLGNBQU0sY0FBYyxJQUFJLEtBQzFCLGNBQU0sU0FBUyxJQUFJLEtBQ25CLGNBQU0sU0FBUyxJQUFJLEtBQ25CLGNBQU0sT0FBTyxJQUFJLEtBQ2pCLGNBQU0sT0FBTyxJQUFJLEdBQ2pCO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFDQSxRQUFJLGNBQU0sa0JBQWtCLElBQUksR0FBRztBQUNqQyxhQUFPLEtBQUs7QUFBQSxJQUNkO0FBQ0EsUUFBSSxjQUFNLGtCQUFrQixJQUFJLEdBQUc7QUFDakMsY0FBUSxlQUFlLG1EQUFtRCxLQUFLO0FBQy9FLGFBQU8sS0FBSyxTQUFTO0FBQUEsSUFDdkI7QUFFQSxRQUFJQztBQUVKLFFBQUksaUJBQWlCO0FBQ25CLFVBQUksWUFBWSxRQUFRLG1DQUFtQyxJQUFJLElBQUk7QUFDakUsZUFBTyxpQkFBaUIsTUFBTSxLQUFLLGNBQWMsRUFBRSxTQUFTO0FBQUEsTUFDOUQ7QUFFQSxXQUFLQSxjQUFhLGNBQU0sV0FBVyxJQUFJLE1BQU0sWUFBWSxRQUFRLHFCQUFxQixJQUFJLElBQUk7QUFDNUYsY0FBTSxZQUFZLEtBQUssT0FBTyxLQUFLLElBQUk7QUFFdkMsZUFBTztBQUFBLFVBQ0xBLGNBQWEsRUFBQyxXQUFXLEtBQUksSUFBSTtBQUFBLFVBQ2pDLGFBQWEsSUFBSSxVQUFVO0FBQUEsVUFDM0IsS0FBSztBQUFBLFFBQ1A7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUVBLFFBQUksbUJBQW1CLG9CQUFxQjtBQUMxQyxjQUFRLGVBQWUsb0JBQW9CLEtBQUs7QUFDaEQsYUFBTyxnQkFBZ0IsSUFBSTtBQUFBLElBQzdCO0FBRUEsV0FBTztBQUFBLEVBQ1QsQ0FBQztBQUFBLEVBRUQsbUJBQW1CLENBQUMsU0FBUyxrQkFBa0IsTUFBTTtBQUNuRCxVQUFNQyxnQkFBZSxLQUFLLGdCQUFnQixTQUFTO0FBQ25ELFVBQU0sb0JBQW9CQSxpQkFBZ0JBLGNBQWE7QUFDdkQsVUFBTSxnQkFBZ0IsS0FBSyxpQkFBaUI7QUFFNUMsUUFBSSxRQUFRLGNBQU0sU0FBUyxJQUFJLE1BQU8scUJBQXFCLENBQUMsS0FBSyxnQkFBaUIsZ0JBQWdCO0FBQ2hHLFlBQU0sb0JBQW9CQSxpQkFBZ0JBLGNBQWE7QUFDdkQsWUFBTSxvQkFBb0IsQ0FBQyxxQkFBcUI7QUFFaEQsVUFBSTtBQUNGLGVBQU8sS0FBSyxNQUFNLElBQUk7QUFBQSxNQUN4QixTQUFTLEdBQVA7QUFDQSxZQUFJLG1CQUFtQjtBQUNyQixjQUFJLEVBQUUsU0FBUyxlQUFlO0FBQzVCLGtCQUFNLG1CQUFXLEtBQUssR0FBRyxtQkFBVyxrQkFBa0IsTUFBTSxNQUFNLEtBQUssUUFBUTtBQUFBLFVBQ2pGO0FBQ0EsZ0JBQU07QUFBQSxRQUNSO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFFQSxXQUFPO0FBQUEsRUFDVCxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU1ELFNBQVM7QUFBQSxFQUVULGdCQUFnQjtBQUFBLEVBQ2hCLGdCQUFnQjtBQUFBLEVBRWhCLGtCQUFrQjtBQUFBLEVBQ2xCLGVBQWU7QUFBQSxFQUVmLEtBQUs7QUFBQSxJQUNILFVBQVUsaUJBQVMsUUFBUTtBQUFBLElBQzNCLE1BQU0saUJBQVMsUUFBUTtBQUFBLEVBQ3pCO0FBQUEsRUFFQSxnQkFBZ0IsU0FBUyxlQUFlLFFBQVE7QUFDOUMsV0FBTyxVQUFVLE9BQU8sU0FBUztBQUFBLEVBQ25DO0FBQUEsRUFFQSxTQUFTO0FBQUEsSUFDUCxRQUFRO0FBQUEsTUFDTixVQUFVO0FBQUEsTUFDVixnQkFBZ0I7QUFBQSxJQUNsQjtBQUFBLEVBQ0Y7QUFDRjtBQUVBLGNBQU0sUUFBUSxDQUFDLFVBQVUsT0FBTyxRQUFRLFFBQVEsT0FBTyxPQUFPLEdBQUcsQ0FBQyxXQUFXO0FBQzNFLFdBQVMsUUFBUSxNQUFNLElBQUksQ0FBQztBQUM5QixDQUFDO0FBRUQsSUFBTyxtQkFBUTs7O0FDeEpmLElBQU0sb0JBQW9CLGNBQU0sWUFBWTtBQUFBLEVBQzFDO0FBQUEsRUFBTztBQUFBLEVBQWlCO0FBQUEsRUFBa0I7QUFBQSxFQUFnQjtBQUFBLEVBQzFEO0FBQUEsRUFBVztBQUFBLEVBQVE7QUFBQSxFQUFRO0FBQUEsRUFBcUI7QUFBQSxFQUNoRDtBQUFBLEVBQWlCO0FBQUEsRUFBWTtBQUFBLEVBQWdCO0FBQUEsRUFDN0M7QUFBQSxFQUFXO0FBQUEsRUFBZTtBQUM1QixDQUFDO0FBZ0JELElBQU8sdUJBQVEsZ0JBQWM7QUFDM0IsUUFBTSxTQUFTLENBQUM7QUFDaEIsTUFBSTtBQUNKLE1BQUk7QUFDSixNQUFJO0FBRUosZ0JBQWMsV0FBVyxNQUFNLElBQUksRUFBRSxRQUFRLFNBQVMsT0FBTyxNQUFNO0FBQ2pFLFFBQUksS0FBSyxRQUFRLEdBQUc7QUFDcEIsVUFBTSxLQUFLLFVBQVUsR0FBRyxDQUFDLEVBQUUsS0FBSyxFQUFFLFlBQVk7QUFDOUMsVUFBTSxLQUFLLFVBQVUsSUFBSSxDQUFDLEVBQUUsS0FBSztBQUVqQyxRQUFJLENBQUMsT0FBUSxPQUFPLEdBQUcsS0FBSyxrQkFBa0IsR0FBRyxHQUFJO0FBQ25EO0FBQUEsSUFDRjtBQUVBLFFBQUksUUFBUSxjQUFjO0FBQ3hCLFVBQUksT0FBTyxHQUFHLEdBQUc7QUFDZixlQUFPLEdBQUcsRUFBRSxLQUFLLEdBQUc7QUFBQSxNQUN0QixPQUFPO0FBQ0wsZUFBTyxHQUFHLElBQUksQ0FBQyxHQUFHO0FBQUEsTUFDcEI7QUFBQSxJQUNGLE9BQU87QUFDTCxhQUFPLEdBQUcsSUFBSSxPQUFPLEdBQUcsSUFBSSxPQUFPLEdBQUcsSUFBSSxPQUFPLE1BQU07QUFBQSxJQUN6RDtBQUFBLEVBQ0YsQ0FBQztBQUVELFNBQU87QUFDVDs7O0FDakRBLElBQU0sYUFBYSxPQUFPLFdBQVc7QUFFckMsU0FBUyxnQkFBZ0IsUUFBUTtBQUMvQixTQUFPLFVBQVUsT0FBTyxNQUFNLEVBQUUsS0FBSyxFQUFFLFlBQVk7QUFDckQ7QUFFQSxTQUFTLGVBQWUsT0FBTztBQUM3QixNQUFJLFVBQVUsU0FBUyxTQUFTLE1BQU07QUFDcEMsV0FBTztBQUFBLEVBQ1Q7QUFFQSxTQUFPLGNBQU0sUUFBUSxLQUFLLElBQUksTUFBTSxJQUFJLGNBQWMsSUFBSSxPQUFPLEtBQUs7QUFDeEU7QUFFQSxTQUFTLFlBQVksS0FBSztBQUN4QixRQUFNLFNBQVMsdUJBQU8sT0FBTyxJQUFJO0FBQ2pDLFFBQU0sV0FBVztBQUNqQixNQUFJO0FBRUosU0FBUSxRQUFRLFNBQVMsS0FBSyxHQUFHLEdBQUk7QUFDbkMsV0FBTyxNQUFNLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQztBQUFBLEVBQzVCO0FBRUEsU0FBTztBQUNUO0FBRUEsSUFBTSxvQkFBb0IsQ0FBQyxRQUFRLGlDQUFpQyxLQUFLLElBQUksS0FBSyxDQUFDO0FBRW5GLFNBQVMsaUJBQWlCLFNBQVMsT0FBTyxRQUFRQyxTQUFRLG9CQUFvQjtBQUM1RSxNQUFJLGNBQU0sV0FBV0EsT0FBTSxHQUFHO0FBQzVCLFdBQU9BLFFBQU8sS0FBSyxNQUFNLE9BQU8sTUFBTTtBQUFBLEVBQ3hDO0FBRUEsTUFBSSxvQkFBb0I7QUFDdEIsWUFBUTtBQUFBLEVBQ1Y7QUFFQSxNQUFJLENBQUMsY0FBTSxTQUFTLEtBQUs7QUFBRztBQUU1QixNQUFJLGNBQU0sU0FBU0EsT0FBTSxHQUFHO0FBQzFCLFdBQU8sTUFBTSxRQUFRQSxPQUFNLE1BQU07QUFBQSxFQUNuQztBQUVBLE1BQUksY0FBTSxTQUFTQSxPQUFNLEdBQUc7QUFDMUIsV0FBT0EsUUFBTyxLQUFLLEtBQUs7QUFBQSxFQUMxQjtBQUNGO0FBRUEsU0FBUyxhQUFhLFFBQVE7QUFDNUIsU0FBTyxPQUFPLEtBQUssRUFDaEIsWUFBWSxFQUFFLFFBQVEsbUJBQW1CLENBQUMsR0FBRyxNQUFNLFFBQVE7QUFDMUQsV0FBTyxLQUFLLFlBQVksSUFBSTtBQUFBLEVBQzlCLENBQUM7QUFDTDtBQUVBLFNBQVMsZUFBZSxLQUFLLFFBQVE7QUFDbkMsUUFBTSxlQUFlLGNBQU0sWUFBWSxNQUFNLE1BQU07QUFFbkQsR0FBQyxPQUFPLE9BQU8sS0FBSyxFQUFFLFFBQVEsZ0JBQWM7QUFDMUMsV0FBTyxlQUFlLEtBQUssYUFBYSxjQUFjO0FBQUEsTUFDcEQsT0FBTyxTQUFTLE1BQU0sTUFBTSxNQUFNO0FBQ2hDLGVBQU8sS0FBSyxVQUFVLEVBQUUsS0FBSyxNQUFNLFFBQVEsTUFBTSxNQUFNLElBQUk7QUFBQSxNQUM3RDtBQUFBLE1BQ0EsY0FBYztBQUFBLElBQ2hCLENBQUM7QUFBQSxFQUNILENBQUM7QUFDSDtBQUVBLElBQU0sZUFBTixNQUFtQjtBQUFBLEVBQ2pCLFlBQVksU0FBUztBQUNuQixlQUFXLEtBQUssSUFBSSxPQUFPO0FBQUEsRUFDN0I7QUFBQSxFQUVBLElBQUksUUFBUSxnQkFBZ0IsU0FBUztBQUNuQyxVQUFNQyxRQUFPO0FBRWIsYUFBUyxVQUFVLFFBQVEsU0FBUyxVQUFVO0FBQzVDLFlBQU0sVUFBVSxnQkFBZ0IsT0FBTztBQUV2QyxVQUFJLENBQUMsU0FBUztBQUNaLGNBQU0sSUFBSSxNQUFNLHdDQUF3QztBQUFBLE1BQzFEO0FBRUEsWUFBTSxNQUFNLGNBQU0sUUFBUUEsT0FBTSxPQUFPO0FBRXZDLFVBQUcsQ0FBQyxPQUFPQSxNQUFLLEdBQUcsTUFBTSxVQUFhLGFBQWEsUUFBUyxhQUFhLFVBQWFBLE1BQUssR0FBRyxNQUFNLE9BQVE7QUFDMUcsUUFBQUEsTUFBSyxPQUFPLE9BQU8sSUFBSSxlQUFlLE1BQU07QUFBQSxNQUM5QztBQUFBLElBQ0Y7QUFFQSxVQUFNLGFBQWEsQ0FBQyxTQUFTLGFBQzNCLGNBQU0sUUFBUSxTQUFTLENBQUMsUUFBUSxZQUFZLFVBQVUsUUFBUSxTQUFTLFFBQVEsQ0FBQztBQUVsRixRQUFJLGNBQU0sY0FBYyxNQUFNLEtBQUssa0JBQWtCLEtBQUssYUFBYTtBQUNyRSxpQkFBVyxRQUFRLGNBQWM7QUFBQSxJQUNuQyxXQUFVLGNBQU0sU0FBUyxNQUFNLE1BQU0sU0FBUyxPQUFPLEtBQUssTUFBTSxDQUFDLGtCQUFrQixNQUFNLEdBQUc7QUFDMUYsaUJBQVcscUJBQWEsTUFBTSxHQUFHLGNBQWM7QUFBQSxJQUNqRCxPQUFPO0FBQ0wsZ0JBQVUsUUFBUSxVQUFVLGdCQUFnQixRQUFRLE9BQU87QUFBQSxJQUM3RDtBQUVBLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFFQSxJQUFJLFFBQVEsUUFBUTtBQUNsQixhQUFTLGdCQUFnQixNQUFNO0FBRS9CLFFBQUksUUFBUTtBQUNWLFlBQU0sTUFBTSxjQUFNLFFBQVEsTUFBTSxNQUFNO0FBRXRDLFVBQUksS0FBSztBQUNQLGNBQU0sUUFBUSxLQUFLLEdBQUc7QUFFdEIsWUFBSSxDQUFDLFFBQVE7QUFDWCxpQkFBTztBQUFBLFFBQ1Q7QUFFQSxZQUFJLFdBQVcsTUFBTTtBQUNuQixpQkFBTyxZQUFZLEtBQUs7QUFBQSxRQUMxQjtBQUVBLFlBQUksY0FBTSxXQUFXLE1BQU0sR0FBRztBQUM1QixpQkFBTyxPQUFPLEtBQUssTUFBTSxPQUFPLEdBQUc7QUFBQSxRQUNyQztBQUVBLFlBQUksY0FBTSxTQUFTLE1BQU0sR0FBRztBQUMxQixpQkFBTyxPQUFPLEtBQUssS0FBSztBQUFBLFFBQzFCO0FBRUEsY0FBTSxJQUFJLFVBQVUsd0NBQXdDO0FBQUEsTUFDOUQ7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBLEVBRUEsSUFBSSxRQUFRLFNBQVM7QUFDbkIsYUFBUyxnQkFBZ0IsTUFBTTtBQUUvQixRQUFJLFFBQVE7QUFDVixZQUFNLE1BQU0sY0FBTSxRQUFRLE1BQU0sTUFBTTtBQUV0QyxhQUFPLENBQUMsRUFBRSxPQUFPLEtBQUssR0FBRyxNQUFNLFdBQWMsQ0FBQyxXQUFXLGlCQUFpQixNQUFNLEtBQUssR0FBRyxHQUFHLEtBQUssT0FBTztBQUFBLElBQ3pHO0FBRUEsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVBLE9BQU8sUUFBUSxTQUFTO0FBQ3RCLFVBQU1BLFFBQU87QUFDYixRQUFJLFVBQVU7QUFFZCxhQUFTLGFBQWEsU0FBUztBQUM3QixnQkFBVSxnQkFBZ0IsT0FBTztBQUVqQyxVQUFJLFNBQVM7QUFDWCxjQUFNLE1BQU0sY0FBTSxRQUFRQSxPQUFNLE9BQU87QUFFdkMsWUFBSSxRQUFRLENBQUMsV0FBVyxpQkFBaUJBLE9BQU1BLE1BQUssR0FBRyxHQUFHLEtBQUssT0FBTyxJQUFJO0FBQ3hFLGlCQUFPQSxNQUFLLEdBQUc7QUFFZixvQkFBVTtBQUFBLFFBQ1o7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUVBLFFBQUksY0FBTSxRQUFRLE1BQU0sR0FBRztBQUN6QixhQUFPLFFBQVEsWUFBWTtBQUFBLElBQzdCLE9BQU87QUFDTCxtQkFBYSxNQUFNO0FBQUEsSUFDckI7QUFFQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsTUFBTSxTQUFTO0FBQ2IsVUFBTSxPQUFPLE9BQU8sS0FBSyxJQUFJO0FBQzdCLFFBQUksSUFBSSxLQUFLO0FBQ2IsUUFBSSxVQUFVO0FBRWQsV0FBTyxLQUFLO0FBQ1YsWUFBTSxNQUFNLEtBQUssQ0FBQztBQUNsQixVQUFHLENBQUMsV0FBVyxpQkFBaUIsTUFBTSxLQUFLLEdBQUcsR0FBRyxLQUFLLFNBQVMsSUFBSSxHQUFHO0FBQ3BFLGVBQU8sS0FBSyxHQUFHO0FBQ2Ysa0JBQVU7QUFBQSxNQUNaO0FBQUEsSUFDRjtBQUVBLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFFQSxVQUFVLFFBQVE7QUFDaEIsVUFBTUEsUUFBTztBQUNiLFVBQU0sVUFBVSxDQUFDO0FBRWpCLGtCQUFNLFFBQVEsTUFBTSxDQUFDLE9BQU8sV0FBVztBQUNyQyxZQUFNLE1BQU0sY0FBTSxRQUFRLFNBQVMsTUFBTTtBQUV6QyxVQUFJLEtBQUs7QUFDUCxRQUFBQSxNQUFLLEdBQUcsSUFBSSxlQUFlLEtBQUs7QUFDaEMsZUFBT0EsTUFBSyxNQUFNO0FBQ2xCO0FBQUEsTUFDRjtBQUVBLFlBQU0sYUFBYSxTQUFTLGFBQWEsTUFBTSxJQUFJLE9BQU8sTUFBTSxFQUFFLEtBQUs7QUFFdkUsVUFBSSxlQUFlLFFBQVE7QUFDekIsZUFBT0EsTUFBSyxNQUFNO0FBQUEsTUFDcEI7QUFFQSxNQUFBQSxNQUFLLFVBQVUsSUFBSSxlQUFlLEtBQUs7QUFFdkMsY0FBUSxVQUFVLElBQUk7QUFBQSxJQUN4QixDQUFDO0FBRUQsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVBLFVBQVUsU0FBUztBQUNqQixXQUFPLEtBQUssWUFBWSxPQUFPLE1BQU0sR0FBRyxPQUFPO0FBQUEsRUFDakQ7QUFBQSxFQUVBLE9BQU8sV0FBVztBQUNoQixVQUFNLE1BQU0sdUJBQU8sT0FBTyxJQUFJO0FBRTlCLGtCQUFNLFFBQVEsTUFBTSxDQUFDLE9BQU8sV0FBVztBQUNyQyxlQUFTLFFBQVEsVUFBVSxVQUFVLElBQUksTUFBTSxJQUFJLGFBQWEsY0FBTSxRQUFRLEtBQUssSUFBSSxNQUFNLEtBQUssSUFBSSxJQUFJO0FBQUEsSUFDNUcsQ0FBQztBQUVELFdBQU87QUFBQSxFQUNUO0FBQUEsRUFFQSxDQUFDLE9BQU8sUUFBUSxJQUFJO0FBQ2xCLFdBQU8sT0FBTyxRQUFRLEtBQUssT0FBTyxDQUFDLEVBQUUsT0FBTyxRQUFRLEVBQUU7QUFBQSxFQUN4RDtBQUFBLEVBRUEsV0FBVztBQUNULFdBQU8sT0FBTyxRQUFRLEtBQUssT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsUUFBUSxLQUFLLE1BQU0sU0FBUyxPQUFPLEtBQUssRUFBRSxLQUFLLElBQUk7QUFBQSxFQUNoRztBQUFBLEVBRUEsS0FBSyxPQUFPLFdBQVcsSUFBSTtBQUN6QixXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsT0FBTyxLQUFLLE9BQU87QUFDakIsV0FBTyxpQkFBaUIsT0FBTyxRQUFRLElBQUksS0FBSyxLQUFLO0FBQUEsRUFDdkQ7QUFBQSxFQUVBLE9BQU8sT0FBTyxVQUFVLFNBQVM7QUFDL0IsVUFBTSxXQUFXLElBQUksS0FBSyxLQUFLO0FBRS9CLFlBQVEsUUFBUSxDQUFDLFdBQVcsU0FBUyxJQUFJLE1BQU0sQ0FBQztBQUVoRCxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsT0FBTyxTQUFTLFFBQVE7QUFDdEIsVUFBTSxZQUFZLEtBQUssVUFBVSxJQUFLLEtBQUssVUFBVSxJQUFJO0FBQUEsTUFDdkQsV0FBVyxDQUFDO0FBQUEsSUFDZDtBQUVBLFVBQU0sWUFBWSxVQUFVO0FBQzVCLFVBQU1DLGFBQVksS0FBSztBQUV2QixhQUFTLGVBQWUsU0FBUztBQUMvQixZQUFNLFVBQVUsZ0JBQWdCLE9BQU87QUFFdkMsVUFBSSxDQUFDLFVBQVUsT0FBTyxHQUFHO0FBQ3ZCLHVCQUFlQSxZQUFXLE9BQU87QUFDakMsa0JBQVUsT0FBTyxJQUFJO0FBQUEsTUFDdkI7QUFBQSxJQUNGO0FBRUEsa0JBQU0sUUFBUSxNQUFNLElBQUksT0FBTyxRQUFRLGNBQWMsSUFBSSxlQUFlLE1BQU07QUFFOUUsV0FBTztBQUFBLEVBQ1Q7QUFDRjtBQUVBLGFBQWEsU0FBUyxDQUFDLGdCQUFnQixrQkFBa0IsVUFBVSxtQkFBbUIsY0FBYyxlQUFlLENBQUM7QUFHcEgsY0FBTSxrQkFBa0IsYUFBYSxXQUFXLENBQUMsRUFBQyxNQUFLLEdBQUcsUUFBUTtBQUNoRSxNQUFJLFNBQVMsSUFBSSxDQUFDLEVBQUUsWUFBWSxJQUFJLElBQUksTUFBTSxDQUFDO0FBQy9DLFNBQU87QUFBQSxJQUNMLEtBQUssTUFBTTtBQUFBLElBQ1gsSUFBSSxhQUFhO0FBQ2YsV0FBSyxNQUFNLElBQUk7QUFBQSxJQUNqQjtBQUFBLEVBQ0Y7QUFDRixDQUFDO0FBRUQsY0FBTSxjQUFjLFlBQVk7QUFFaEMsSUFBTyx1QkFBUTs7O0FDM1JBLFNBQVIsY0FBK0IsS0FBSyxVQUFVO0FBQ25ELFFBQU0sU0FBUyxRQUFRO0FBQ3ZCLFFBQU0sVUFBVSxZQUFZO0FBQzVCLFFBQU0sVUFBVSxxQkFBYSxLQUFLLFFBQVEsT0FBTztBQUNqRCxNQUFJLE9BQU8sUUFBUTtBQUVuQixnQkFBTSxRQUFRLEtBQUssU0FBUyxVQUFVLElBQUk7QUFDeEMsV0FBTyxHQUFHLEtBQUssUUFBUSxNQUFNLFFBQVEsVUFBVSxHQUFHLFdBQVcsU0FBUyxTQUFTLE1BQVM7QUFBQSxFQUMxRixDQUFDO0FBRUQsVUFBUSxVQUFVO0FBRWxCLFNBQU87QUFDVDs7O0FDekJlLFNBQVIsU0FBMEIsT0FBTztBQUN0QyxTQUFPLENBQUMsRUFBRSxTQUFTLE1BQU07QUFDM0I7OztBQ1VBLFNBQVMsY0FBYyxTQUFTLFFBQVEsU0FBUztBQUUvQyxxQkFBVyxLQUFLLE1BQU0sV0FBVyxPQUFPLGFBQWEsU0FBUyxtQkFBVyxjQUFjLFFBQVEsT0FBTztBQUN0RyxPQUFLLE9BQU87QUFDZDtBQUVBLGNBQU0sU0FBUyxlQUFlLG9CQUFZO0FBQUEsRUFDeEMsWUFBWTtBQUNkLENBQUM7QUFFRCxJQUFPLHdCQUFROzs7QUNYQSxTQUFSLE9BQXdCLFNBQVMsUUFBUSxVQUFVO0FBQ3hELFFBQU1DLGtCQUFpQixTQUFTLE9BQU87QUFDdkMsTUFBSSxDQUFDLFNBQVMsVUFBVSxDQUFDQSxtQkFBa0JBLGdCQUFlLFNBQVMsTUFBTSxHQUFHO0FBQzFFLFlBQVEsUUFBUTtBQUFBLEVBQ2xCLE9BQU87QUFDTCxXQUFPLElBQUk7QUFBQSxNQUNULHFDQUFxQyxTQUFTO0FBQUEsTUFDOUMsQ0FBQyxtQkFBVyxpQkFBaUIsbUJBQVcsZ0JBQWdCLEVBQUUsS0FBSyxNQUFNLFNBQVMsU0FBUyxHQUFHLElBQUksQ0FBQztBQUFBLE1BQy9GLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNUO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSDtBQUNGOzs7QUN2QkEsSUFBTyxrQkFBUSxpQkFBUztBQUFBO0FBQUEsRUFHdEI7QUFBQSxJQUNFLE1BQU0sTUFBTSxPQUFPLFNBQVNDLE9BQU0sUUFBUSxRQUFRO0FBQ2hELFlBQU0sU0FBUyxDQUFDLE9BQU8sTUFBTSxtQkFBbUIsS0FBSyxDQUFDO0FBRXRELG9CQUFNLFNBQVMsT0FBTyxLQUFLLE9BQU8sS0FBSyxhQUFhLElBQUksS0FBSyxPQUFPLEVBQUUsWUFBWSxDQUFDO0FBRW5GLG9CQUFNLFNBQVNBLEtBQUksS0FBSyxPQUFPLEtBQUssVUFBVUEsS0FBSTtBQUVsRCxvQkFBTSxTQUFTLE1BQU0sS0FBSyxPQUFPLEtBQUssWUFBWSxNQUFNO0FBRXhELGlCQUFXLFFBQVEsT0FBTyxLQUFLLFFBQVE7QUFFdkMsZUFBUyxTQUFTLE9BQU8sS0FBSyxJQUFJO0FBQUEsSUFDcEM7QUFBQSxJQUVBLEtBQUssTUFBTTtBQUNULFlBQU0sUUFBUSxTQUFTLE9BQU8sTUFBTSxJQUFJLE9BQU8sZUFBZSxPQUFPLFdBQVcsQ0FBQztBQUNqRixhQUFRLFFBQVEsbUJBQW1CLE1BQU0sQ0FBQyxDQUFDLElBQUk7QUFBQSxJQUNqRDtBQUFBLElBRUEsT0FBTyxNQUFNO0FBQ1gsV0FBSyxNQUFNLE1BQU0sSUFBSSxLQUFLLElBQUksSUFBSSxLQUFRO0FBQUEsSUFDNUM7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBLEVBS0E7QUFBQSxJQUNFLFFBQVE7QUFBQSxJQUFDO0FBQUEsSUFDVCxPQUFPO0FBQ0wsYUFBTztBQUFBLElBQ1Q7QUFBQSxJQUNBLFNBQVM7QUFBQSxJQUFDO0FBQUEsRUFDWjtBQUFBOzs7QUMvQmEsU0FBUixjQUErQixLQUFLO0FBSXpDLFNBQU8sOEJBQThCLEtBQUssR0FBRztBQUMvQzs7O0FDSmUsU0FBUixZQUE2QixTQUFTLGFBQWE7QUFDeEQsU0FBTyxjQUNILFFBQVEsUUFBUSxRQUFRLEVBQUUsSUFBSSxNQUFNLFlBQVksUUFBUSxRQUFRLEVBQUUsSUFDbEU7QUFDTjs7O0FDQ2UsU0FBUixjQUErQixTQUFTLGNBQWM7QUFDM0QsTUFBSSxXQUFXLENBQUMsY0FBYyxZQUFZLEdBQUc7QUFDM0MsV0FBTyxZQUFZLFNBQVMsWUFBWTtBQUFBLEVBQzFDO0FBQ0EsU0FBTztBQUNUOzs7QUNmQSxJQUFPLDBCQUFRLGlCQUFTO0FBQUE7QUFBQTtBQUFBLEVBSXJCLFNBQVMscUJBQXFCO0FBQzdCLFVBQU0sT0FBTyxrQkFBa0IsS0FBSyxVQUFVLFNBQVM7QUFDdkQsVUFBTSxpQkFBaUIsU0FBUyxjQUFjLEdBQUc7QUFDakQsUUFBSTtBQVFKLGFBQVMsV0FBVyxLQUFLO0FBQ3ZCLFVBQUksT0FBTztBQUVYLFVBQUksTUFBTTtBQUVSLHVCQUFlLGFBQWEsUUFBUSxJQUFJO0FBQ3hDLGVBQU8sZUFBZTtBQUFBLE1BQ3hCO0FBRUEscUJBQWUsYUFBYSxRQUFRLElBQUk7QUFHeEMsYUFBTztBQUFBLFFBQ0wsTUFBTSxlQUFlO0FBQUEsUUFDckIsVUFBVSxlQUFlLFdBQVcsZUFBZSxTQUFTLFFBQVEsTUFBTSxFQUFFLElBQUk7QUFBQSxRQUNoRixNQUFNLGVBQWU7QUFBQSxRQUNyQixRQUFRLGVBQWUsU0FBUyxlQUFlLE9BQU8sUUFBUSxPQUFPLEVBQUUsSUFBSTtBQUFBLFFBQzNFLE1BQU0sZUFBZSxPQUFPLGVBQWUsS0FBSyxRQUFRLE1BQU0sRUFBRSxJQUFJO0FBQUEsUUFDcEUsVUFBVSxlQUFlO0FBQUEsUUFDekIsTUFBTSxlQUFlO0FBQUEsUUFDckIsVUFBVyxlQUFlLFNBQVMsT0FBTyxDQUFDLE1BQU0sTUFDL0MsZUFBZSxXQUNmLE1BQU0sZUFBZTtBQUFBLE1BQ3pCO0FBQUEsSUFDRjtBQUVBLGdCQUFZLFdBQVcsT0FBTyxTQUFTLElBQUk7QUFRM0MsV0FBTyxTQUFTLGdCQUFnQixZQUFZO0FBQzFDLFlBQU0sU0FBVSxjQUFNLFNBQVMsVUFBVSxJQUFLLFdBQVcsVUFBVSxJQUFJO0FBQ3ZFLGFBQVEsT0FBTyxhQUFhLFVBQVUsWUFDbEMsT0FBTyxTQUFTLFVBQVU7QUFBQSxJQUNoQztBQUFBLEVBQ0YsRUFBRztBQUFBO0FBQUE7QUFBQSxFQUdGLFNBQVMsd0JBQXdCO0FBQ2hDLFdBQU8sU0FBUyxrQkFBa0I7QUFDaEMsYUFBTztBQUFBLElBQ1Q7QUFBQSxFQUNGLEVBQUc7QUFBQTs7O0FDaEVVLFNBQVIsY0FBK0IsS0FBSztBQUN6QyxRQUFNLFFBQVEsNEJBQTRCLEtBQUssR0FBRztBQUNsRCxTQUFPLFNBQVMsTUFBTSxDQUFDLEtBQUs7QUFDOUI7OztBQ0dBLFNBQVMsWUFBWSxjQUFjLEtBQUs7QUFDdEMsaUJBQWUsZ0JBQWdCO0FBQy9CLFFBQU0sUUFBUSxJQUFJLE1BQU0sWUFBWTtBQUNwQyxRQUFNLGFBQWEsSUFBSSxNQUFNLFlBQVk7QUFDekMsTUFBSSxPQUFPO0FBQ1gsTUFBSSxPQUFPO0FBQ1gsTUFBSTtBQUVKLFFBQU0sUUFBUSxTQUFZLE1BQU07QUFFaEMsU0FBTyxTQUFTLEtBQUssYUFBYTtBQUNoQyxVQUFNLE1BQU0sS0FBSyxJQUFJO0FBRXJCLFVBQU0sWUFBWSxXQUFXLElBQUk7QUFFakMsUUFBSSxDQUFDLGVBQWU7QUFDbEIsc0JBQWdCO0FBQUEsSUFDbEI7QUFFQSxVQUFNLElBQUksSUFBSTtBQUNkLGVBQVcsSUFBSSxJQUFJO0FBRW5CLFFBQUksSUFBSTtBQUNSLFFBQUksYUFBYTtBQUVqQixXQUFPLE1BQU0sTUFBTTtBQUNqQixvQkFBYyxNQUFNLEdBQUc7QUFDdkIsVUFBSSxJQUFJO0FBQUEsSUFDVjtBQUVBLFlBQVEsT0FBTyxLQUFLO0FBRXBCLFFBQUksU0FBUyxNQUFNO0FBQ2pCLGNBQVEsT0FBTyxLQUFLO0FBQUEsSUFDdEI7QUFFQSxRQUFJLE1BQU0sZ0JBQWdCLEtBQUs7QUFDN0I7QUFBQSxJQUNGO0FBRUEsVUFBTSxTQUFTLGFBQWEsTUFBTTtBQUVsQyxXQUFPLFNBQVMsS0FBSyxNQUFNLGFBQWEsTUFBTyxNQUFNLElBQUk7QUFBQSxFQUMzRDtBQUNGO0FBRUEsSUFBTyxzQkFBUTs7O0FDdENmLFNBQVMscUJBQXFCLFVBQVUsa0JBQWtCO0FBQ3hELE1BQUksZ0JBQWdCO0FBQ3BCLFFBQU0sZUFBZSxvQkFBWSxJQUFJLEdBQUc7QUFFeEMsU0FBTyxPQUFLO0FBQ1YsVUFBTSxTQUFTLEVBQUU7QUFDakIsVUFBTSxRQUFRLEVBQUUsbUJBQW1CLEVBQUUsUUFBUTtBQUM3QyxVQUFNLGdCQUFnQixTQUFTO0FBQy9CLFVBQU0sT0FBTyxhQUFhLGFBQWE7QUFDdkMsVUFBTSxVQUFVLFVBQVU7QUFFMUIsb0JBQWdCO0FBRWhCLFVBQU0sT0FBTztBQUFBLE1BQ1g7QUFBQSxNQUNBO0FBQUEsTUFDQSxVQUFVLFFBQVMsU0FBUyxRQUFTO0FBQUEsTUFDckMsT0FBTztBQUFBLE1BQ1AsTUFBTSxPQUFPLE9BQU87QUFBQSxNQUNwQixXQUFXLFFBQVEsU0FBUyxXQUFXLFFBQVEsVUFBVSxPQUFPO0FBQUEsTUFDaEUsT0FBTztBQUFBLElBQ1Q7QUFFQSxTQUFLLG1CQUFtQixhQUFhLFFBQVEsSUFBSTtBQUVqRCxhQUFTLElBQUk7QUFBQSxFQUNmO0FBQ0Y7QUFFQSxJQUFNLHdCQUF3QixPQUFPLG1CQUFtQjtBQUV4RCxJQUFPLGNBQVEseUJBQXlCLFNBQVUsUUFBUTtBQUN4RCxTQUFPLElBQUksUUFBUSxTQUFTLG1CQUFtQixTQUFTLFFBQVE7QUFDOUQsUUFBSSxjQUFjLE9BQU87QUFDekIsVUFBTSxpQkFBaUIscUJBQWEsS0FBSyxPQUFPLE9BQU8sRUFBRSxVQUFVO0FBQ25FLFFBQUksRUFBQyxjQUFjLGNBQWEsSUFBSTtBQUNwQyxRQUFJO0FBQ0osYUFBUyxPQUFPO0FBQ2QsVUFBSSxPQUFPLGFBQWE7QUFDdEIsZUFBTyxZQUFZLFlBQVksVUFBVTtBQUFBLE1BQzNDO0FBRUEsVUFBSSxPQUFPLFFBQVE7QUFDakIsZUFBTyxPQUFPLG9CQUFvQixTQUFTLFVBQVU7QUFBQSxNQUN2RDtBQUFBLElBQ0Y7QUFFQSxRQUFJO0FBRUosUUFBSSxjQUFNLFdBQVcsV0FBVyxHQUFHO0FBQ2pDLFVBQUksaUJBQVMseUJBQXlCLGlCQUFTLGdDQUFnQztBQUM3RSx1QkFBZSxlQUFlLEtBQUs7QUFBQSxNQUNyQyxZQUFZLGNBQWMsZUFBZSxlQUFlLE9BQU8sT0FBTztBQUVwRSxjQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sSUFBSSxjQUFjLFlBQVksTUFBTSxHQUFHLEVBQUUsSUFBSSxXQUFTLE1BQU0sS0FBSyxDQUFDLEVBQUUsT0FBTyxPQUFPLElBQUksQ0FBQztBQUM3Ryx1QkFBZSxlQUFlLENBQUMsUUFBUSx1QkFBdUIsR0FBRyxNQUFNLEVBQUUsS0FBSyxJQUFJLENBQUM7QUFBQSxNQUNyRjtBQUFBLElBQ0Y7QUFFQSxRQUFJLFVBQVUsSUFBSSxlQUFlO0FBR2pDLFFBQUksT0FBTyxNQUFNO0FBQ2YsWUFBTSxXQUFXLE9BQU8sS0FBSyxZQUFZO0FBQ3pDLFlBQU0sV0FBVyxPQUFPLEtBQUssV0FBVyxTQUFTLG1CQUFtQixPQUFPLEtBQUssUUFBUSxDQUFDLElBQUk7QUFDN0YscUJBQWUsSUFBSSxpQkFBaUIsV0FBVyxLQUFLLFdBQVcsTUFBTSxRQUFRLENBQUM7QUFBQSxJQUNoRjtBQUVBLFVBQU0sV0FBVyxjQUFjLE9BQU8sU0FBUyxPQUFPLEdBQUc7QUFFekQsWUFBUSxLQUFLLE9BQU8sT0FBTyxZQUFZLEdBQUcsU0FBUyxVQUFVLE9BQU8sUUFBUSxPQUFPLGdCQUFnQixHQUFHLElBQUk7QUFHMUcsWUFBUSxVQUFVLE9BQU87QUFFekIsYUFBUyxZQUFZO0FBQ25CLFVBQUksQ0FBQyxTQUFTO0FBQ1o7QUFBQSxNQUNGO0FBRUEsWUFBTSxrQkFBa0IscUJBQWE7QUFBQSxRQUNuQywyQkFBMkIsV0FBVyxRQUFRLHNCQUFzQjtBQUFBLE1BQ3RFO0FBQ0EsWUFBTSxlQUFlLENBQUMsZ0JBQWdCLGlCQUFpQixVQUFVLGlCQUFpQixTQUNoRixRQUFRLGVBQWUsUUFBUTtBQUNqQyxZQUFNLFdBQVc7QUFBQSxRQUNmLE1BQU07QUFBQSxRQUNOLFFBQVEsUUFBUTtBQUFBLFFBQ2hCLFlBQVksUUFBUTtBQUFBLFFBQ3BCLFNBQVM7QUFBQSxRQUNUO0FBQUEsUUFDQTtBQUFBLE1BQ0Y7QUFFQSxhQUFPLFNBQVMsU0FBUyxPQUFPO0FBQzlCLGdCQUFRLEtBQUs7QUFDYixhQUFLO0FBQUEsTUFDUCxHQUFHLFNBQVMsUUFBUSxLQUFLO0FBQ3ZCLGVBQU8sR0FBRztBQUNWLGFBQUs7QUFBQSxNQUNQLEdBQUcsUUFBUTtBQUdYLGdCQUFVO0FBQUEsSUFDWjtBQUVBLFFBQUksZUFBZSxTQUFTO0FBRTFCLGNBQVEsWUFBWTtBQUFBLElBQ3RCLE9BQU87QUFFTCxjQUFRLHFCQUFxQixTQUFTLGFBQWE7QUFDakQsWUFBSSxDQUFDLFdBQVcsUUFBUSxlQUFlLEdBQUc7QUFDeEM7QUFBQSxRQUNGO0FBTUEsWUFBSSxRQUFRLFdBQVcsS0FBSyxFQUFFLFFBQVEsZUFBZSxRQUFRLFlBQVksUUFBUSxPQUFPLE1BQU0sSUFBSTtBQUNoRztBQUFBLFFBQ0Y7QUFHQSxtQkFBVyxTQUFTO0FBQUEsTUFDdEI7QUFBQSxJQUNGO0FBR0EsWUFBUSxVQUFVLFNBQVMsY0FBYztBQUN2QyxVQUFJLENBQUMsU0FBUztBQUNaO0FBQUEsTUFDRjtBQUVBLGFBQU8sSUFBSSxtQkFBVyxtQkFBbUIsbUJBQVcsY0FBYyxRQUFRLE9BQU8sQ0FBQztBQUdsRixnQkFBVTtBQUFBLElBQ1o7QUFHQSxZQUFRLFVBQVUsU0FBUyxjQUFjO0FBR3ZDLGFBQU8sSUFBSSxtQkFBVyxpQkFBaUIsbUJBQVcsYUFBYSxRQUFRLE9BQU8sQ0FBQztBQUcvRSxnQkFBVTtBQUFBLElBQ1o7QUFHQSxZQUFRLFlBQVksU0FBUyxnQkFBZ0I7QUFDM0MsVUFBSSxzQkFBc0IsT0FBTyxVQUFVLGdCQUFnQixPQUFPLFVBQVUsZ0JBQWdCO0FBQzVGLFlBQU1DLGdCQUFlLE9BQU8sZ0JBQWdCO0FBQzVDLFVBQUksT0FBTyxxQkFBcUI7QUFDOUIsOEJBQXNCLE9BQU87QUFBQSxNQUMvQjtBQUNBLGFBQU8sSUFBSTtBQUFBLFFBQ1Q7QUFBQSxRQUNBQSxjQUFhLHNCQUFzQixtQkFBVyxZQUFZLG1CQUFXO0FBQUEsUUFDckU7QUFBQSxRQUNBO0FBQUEsTUFBTyxDQUFDO0FBR1YsZ0JBQVU7QUFBQSxJQUNaO0FBS0EsUUFBRyxpQkFBUyx1QkFBdUI7QUFDakMsdUJBQWlCLGNBQU0sV0FBVyxhQUFhLE1BQU0sZ0JBQWdCLGNBQWMsTUFBTTtBQUV6RixVQUFJLGlCQUFrQixrQkFBa0IsU0FBUyx3QkFBZ0IsUUFBUSxHQUFJO0FBRTNFLGNBQU0sWUFBWSxPQUFPLGtCQUFrQixPQUFPLGtCQUFrQixnQkFBUSxLQUFLLE9BQU8sY0FBYztBQUV0RyxZQUFJLFdBQVc7QUFDYix5QkFBZSxJQUFJLE9BQU8sZ0JBQWdCLFNBQVM7QUFBQSxRQUNyRDtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBR0Esb0JBQWdCLFVBQWEsZUFBZSxlQUFlLElBQUk7QUFHL0QsUUFBSSxzQkFBc0IsU0FBUztBQUNqQyxvQkFBTSxRQUFRLGVBQWUsT0FBTyxHQUFHLFNBQVMsaUJBQWlCLEtBQUssS0FBSztBQUN6RSxnQkFBUSxpQkFBaUIsS0FBSyxHQUFHO0FBQUEsTUFDbkMsQ0FBQztBQUFBLElBQ0g7QUFHQSxRQUFJLENBQUMsY0FBTSxZQUFZLE9BQU8sZUFBZSxHQUFHO0FBQzlDLGNBQVEsa0JBQWtCLENBQUMsQ0FBQyxPQUFPO0FBQUEsSUFDckM7QUFHQSxRQUFJLGdCQUFnQixpQkFBaUIsUUFBUTtBQUMzQyxjQUFRLGVBQWUsT0FBTztBQUFBLElBQ2hDO0FBR0EsUUFBSSxPQUFPLE9BQU8sdUJBQXVCLFlBQVk7QUFDbkQsY0FBUSxpQkFBaUIsWUFBWSxxQkFBcUIsT0FBTyxvQkFBb0IsSUFBSSxDQUFDO0FBQUEsSUFDNUY7QUFHQSxRQUFJLE9BQU8sT0FBTyxxQkFBcUIsY0FBYyxRQUFRLFFBQVE7QUFDbkUsY0FBUSxPQUFPLGlCQUFpQixZQUFZLHFCQUFxQixPQUFPLGdCQUFnQixDQUFDO0FBQUEsSUFDM0Y7QUFFQSxRQUFJLE9BQU8sZUFBZSxPQUFPLFFBQVE7QUFHdkMsbUJBQWEsWUFBVTtBQUNyQixZQUFJLENBQUMsU0FBUztBQUNaO0FBQUEsUUFDRjtBQUNBLGVBQU8sQ0FBQyxVQUFVLE9BQU8sT0FBTyxJQUFJLHNCQUFjLE1BQU0sUUFBUSxPQUFPLElBQUksTUFBTTtBQUNqRixnQkFBUSxNQUFNO0FBQ2Qsa0JBQVU7QUFBQSxNQUNaO0FBRUEsYUFBTyxlQUFlLE9BQU8sWUFBWSxVQUFVLFVBQVU7QUFDN0QsVUFBSSxPQUFPLFFBQVE7QUFDakIsZUFBTyxPQUFPLFVBQVUsV0FBVyxJQUFJLE9BQU8sT0FBTyxpQkFBaUIsU0FBUyxVQUFVO0FBQUEsTUFDM0Y7QUFBQSxJQUNGO0FBRUEsVUFBTSxXQUFXLGNBQWMsUUFBUTtBQUV2QyxRQUFJLFlBQVksaUJBQVMsVUFBVSxRQUFRLFFBQVEsTUFBTSxJQUFJO0FBQzNELGFBQU8sSUFBSSxtQkFBVywwQkFBMEIsV0FBVyxLQUFLLG1CQUFXLGlCQUFpQixNQUFNLENBQUM7QUFDbkc7QUFBQSxJQUNGO0FBSUEsWUFBUSxLQUFLLGVBQWUsSUFBSTtBQUFBLEVBQ2xDLENBQUM7QUFDSDs7O0FDOVBBLElBQU0sZ0JBQWdCO0FBQUEsRUFDcEIsTUFBTTtBQUFBLEVBQ04sS0FBSztBQUNQO0FBRUEsY0FBTSxRQUFRLGVBQWUsQ0FBQyxJQUFJLFVBQVU7QUFDMUMsTUFBSSxJQUFJO0FBQ04sUUFBSTtBQUNGLGFBQU8sZUFBZSxJQUFJLFFBQVEsRUFBQyxNQUFLLENBQUM7QUFBQSxJQUMzQyxTQUFTLEdBQVA7QUFBQSxJQUVGO0FBQ0EsV0FBTyxlQUFlLElBQUksZUFBZSxFQUFDLE1BQUssQ0FBQztBQUFBLEVBQ2xEO0FBQ0YsQ0FBQztBQUVELElBQU0sZUFBZSxDQUFDLFdBQVcsS0FBSztBQUV0QyxJQUFNLG1CQUFtQixDQUFDLFlBQVksY0FBTSxXQUFXLE9BQU8sS0FBSyxZQUFZLFFBQVEsWUFBWTtBQUVuRyxJQUFPLG1CQUFRO0FBQUEsRUFDYixZQUFZLENBQUMsYUFBYTtBQUN4QixlQUFXLGNBQU0sUUFBUSxRQUFRLElBQUksV0FBVyxDQUFDLFFBQVE7QUFFekQsVUFBTSxFQUFDLE9BQU0sSUFBSTtBQUNqQixRQUFJO0FBQ0osUUFBSTtBQUVKLFVBQU0sa0JBQWtCLENBQUM7QUFFekIsYUFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEtBQUs7QUFDL0Isc0JBQWdCLFNBQVMsQ0FBQztBQUMxQixVQUFJO0FBRUosZ0JBQVU7QUFFVixVQUFJLENBQUMsaUJBQWlCLGFBQWEsR0FBRztBQUNwQyxrQkFBVSxlQUFlLEtBQUssT0FBTyxhQUFhLEdBQUcsWUFBWSxDQUFDO0FBRWxFLFlBQUksWUFBWSxRQUFXO0FBQ3pCLGdCQUFNLElBQUksbUJBQVcsb0JBQW9CLEtBQUs7QUFBQSxRQUNoRDtBQUFBLE1BQ0Y7QUFFQSxVQUFJLFNBQVM7QUFDWDtBQUFBLE1BQ0Y7QUFFQSxzQkFBZ0IsTUFBTSxNQUFNLENBQUMsSUFBSTtBQUFBLElBQ25DO0FBRUEsUUFBSSxDQUFDLFNBQVM7QUFFWixZQUFNLFVBQVUsT0FBTyxRQUFRLGVBQWUsRUFDM0M7QUFBQSxRQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssTUFBTSxXQUFXLFNBQzlCLFVBQVUsUUFBUSx3Q0FBd0M7QUFBQSxNQUM3RDtBQUVGLFVBQUksSUFBSSxTQUNMLFFBQVEsU0FBUyxJQUFJLGNBQWMsUUFBUSxJQUFJLFlBQVksRUFBRSxLQUFLLElBQUksSUFBSSxNQUFNLGFBQWEsUUFBUSxDQUFDLENBQUMsSUFDeEc7QUFFRixZQUFNLElBQUk7QUFBQSxRQUNSLDBEQUEwRDtBQUFBLFFBQzFEO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFFQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBQ0EsVUFBVTtBQUNaOzs7QUM1REEsU0FBUyw2QkFBNkIsUUFBUTtBQUM1QyxNQUFJLE9BQU8sYUFBYTtBQUN0QixXQUFPLFlBQVksaUJBQWlCO0FBQUEsRUFDdEM7QUFFQSxNQUFJLE9BQU8sVUFBVSxPQUFPLE9BQU8sU0FBUztBQUMxQyxVQUFNLElBQUksc0JBQWMsTUFBTSxNQUFNO0FBQUEsRUFDdEM7QUFDRjtBQVNlLFNBQVIsZ0JBQWlDLFFBQVE7QUFDOUMsK0JBQTZCLE1BQU07QUFFbkMsU0FBTyxVQUFVLHFCQUFhLEtBQUssT0FBTyxPQUFPO0FBR2pELFNBQU8sT0FBTyxjQUFjO0FBQUEsSUFDMUI7QUFBQSxJQUNBLE9BQU87QUFBQSxFQUNUO0FBRUEsTUFBSSxDQUFDLFFBQVEsT0FBTyxPQUFPLEVBQUUsUUFBUSxPQUFPLE1BQU0sTUFBTSxJQUFJO0FBQzFELFdBQU8sUUFBUSxlQUFlLHFDQUFxQyxLQUFLO0FBQUEsRUFDMUU7QUFFQSxRQUFNLFVBQVUsaUJBQVMsV0FBVyxPQUFPLFdBQVcsaUJBQVMsT0FBTztBQUV0RSxTQUFPLFFBQVEsTUFBTSxFQUFFLEtBQUssU0FBUyxvQkFBb0IsVUFBVTtBQUNqRSxpQ0FBNkIsTUFBTTtBQUduQyxhQUFTLE9BQU8sY0FBYztBQUFBLE1BQzVCO0FBQUEsTUFDQSxPQUFPO0FBQUEsTUFDUDtBQUFBLElBQ0Y7QUFFQSxhQUFTLFVBQVUscUJBQWEsS0FBSyxTQUFTLE9BQU87QUFFckQsV0FBTztBQUFBLEVBQ1QsR0FBRyxTQUFTLG1CQUFtQixRQUFRO0FBQ3JDLFFBQUksQ0FBQyxTQUFTLE1BQU0sR0FBRztBQUNyQixtQ0FBNkIsTUFBTTtBQUduQyxVQUFJLFVBQVUsT0FBTyxVQUFVO0FBQzdCLGVBQU8sU0FBUyxPQUFPLGNBQWM7QUFBQSxVQUNuQztBQUFBLFVBQ0EsT0FBTztBQUFBLFVBQ1AsT0FBTztBQUFBLFFBQ1Q7QUFDQSxlQUFPLFNBQVMsVUFBVSxxQkFBYSxLQUFLLE9BQU8sU0FBUyxPQUFPO0FBQUEsTUFDckU7QUFBQSxJQUNGO0FBRUEsV0FBTyxRQUFRLE9BQU8sTUFBTTtBQUFBLEVBQzlCLENBQUM7QUFDSDs7O0FDM0VBLElBQU0sa0JBQWtCLENBQUMsVUFBVSxpQkFBaUIsdUJBQWUsTUFBTSxPQUFPLElBQUk7QUFXckUsU0FBUixZQUE2QixTQUFTLFNBQVM7QUFFcEQsWUFBVSxXQUFXLENBQUM7QUFDdEIsUUFBTSxTQUFTLENBQUM7QUFFaEIsV0FBUyxlQUFlLFFBQVEsUUFBUSxVQUFVO0FBQ2hELFFBQUksY0FBTSxjQUFjLE1BQU0sS0FBSyxjQUFNLGNBQWMsTUFBTSxHQUFHO0FBQzlELGFBQU8sY0FBTSxNQUFNLEtBQUssRUFBQyxTQUFRLEdBQUcsUUFBUSxNQUFNO0FBQUEsSUFDcEQsV0FBVyxjQUFNLGNBQWMsTUFBTSxHQUFHO0FBQ3RDLGFBQU8sY0FBTSxNQUFNLENBQUMsR0FBRyxNQUFNO0FBQUEsSUFDL0IsV0FBVyxjQUFNLFFBQVEsTUFBTSxHQUFHO0FBQ2hDLGFBQU8sT0FBTyxNQUFNO0FBQUEsSUFDdEI7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUdBLFdBQVMsb0JBQW9CLEdBQUcsR0FBRyxVQUFVO0FBQzNDLFFBQUksQ0FBQyxjQUFNLFlBQVksQ0FBQyxHQUFHO0FBQ3pCLGFBQU8sZUFBZSxHQUFHLEdBQUcsUUFBUTtBQUFBLElBQ3RDLFdBQVcsQ0FBQyxjQUFNLFlBQVksQ0FBQyxHQUFHO0FBQ2hDLGFBQU8sZUFBZSxRQUFXLEdBQUcsUUFBUTtBQUFBLElBQzlDO0FBQUEsRUFDRjtBQUdBLFdBQVMsaUJBQWlCLEdBQUcsR0FBRztBQUM5QixRQUFJLENBQUMsY0FBTSxZQUFZLENBQUMsR0FBRztBQUN6QixhQUFPLGVBQWUsUUFBVyxDQUFDO0FBQUEsSUFDcEM7QUFBQSxFQUNGO0FBR0EsV0FBUyxpQkFBaUIsR0FBRyxHQUFHO0FBQzlCLFFBQUksQ0FBQyxjQUFNLFlBQVksQ0FBQyxHQUFHO0FBQ3pCLGFBQU8sZUFBZSxRQUFXLENBQUM7QUFBQSxJQUNwQyxXQUFXLENBQUMsY0FBTSxZQUFZLENBQUMsR0FBRztBQUNoQyxhQUFPLGVBQWUsUUFBVyxDQUFDO0FBQUEsSUFDcEM7QUFBQSxFQUNGO0FBR0EsV0FBUyxnQkFBZ0IsR0FBRyxHQUFHLE1BQU07QUFDbkMsUUFBSSxRQUFRLFNBQVM7QUFDbkIsYUFBTyxlQUFlLEdBQUcsQ0FBQztBQUFBLElBQzVCLFdBQVcsUUFBUSxTQUFTO0FBQzFCLGFBQU8sZUFBZSxRQUFXLENBQUM7QUFBQSxJQUNwQztBQUFBLEVBQ0Y7QUFFQSxRQUFNLFdBQVc7QUFBQSxJQUNmLEtBQUs7QUFBQSxJQUNMLFFBQVE7QUFBQSxJQUNSLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxJQUNULGtCQUFrQjtBQUFBLElBQ2xCLG1CQUFtQjtBQUFBLElBQ25CLGtCQUFrQjtBQUFBLElBQ2xCLFNBQVM7QUFBQSxJQUNULGdCQUFnQjtBQUFBLElBQ2hCLGlCQUFpQjtBQUFBLElBQ2pCLGVBQWU7QUFBQSxJQUNmLFNBQVM7QUFBQSxJQUNULGNBQWM7QUFBQSxJQUNkLGdCQUFnQjtBQUFBLElBQ2hCLGdCQUFnQjtBQUFBLElBQ2hCLGtCQUFrQjtBQUFBLElBQ2xCLG9CQUFvQjtBQUFBLElBQ3BCLFlBQVk7QUFBQSxJQUNaLGtCQUFrQjtBQUFBLElBQ2xCLGVBQWU7QUFBQSxJQUNmLGdCQUFnQjtBQUFBLElBQ2hCLFdBQVc7QUFBQSxJQUNYLFdBQVc7QUFBQSxJQUNYLFlBQVk7QUFBQSxJQUNaLGFBQWE7QUFBQSxJQUNiLFlBQVk7QUFBQSxJQUNaLGtCQUFrQjtBQUFBLElBQ2xCLGdCQUFnQjtBQUFBLElBQ2hCLFNBQVMsQ0FBQyxHQUFHLE1BQU0sb0JBQW9CLGdCQUFnQixDQUFDLEdBQUcsZ0JBQWdCLENBQUMsR0FBRyxJQUFJO0FBQUEsRUFDckY7QUFFQSxnQkFBTSxRQUFRLE9BQU8sS0FBSyxPQUFPLE9BQU8sQ0FBQyxHQUFHLFNBQVMsT0FBTyxDQUFDLEdBQUcsU0FBUyxtQkFBbUIsTUFBTTtBQUNoRyxVQUFNQyxTQUFRLFNBQVMsSUFBSSxLQUFLO0FBQ2hDLFVBQU0sY0FBY0EsT0FBTSxRQUFRLElBQUksR0FBRyxRQUFRLElBQUksR0FBRyxJQUFJO0FBQzVELElBQUMsY0FBTSxZQUFZLFdBQVcsS0FBS0EsV0FBVSxvQkFBcUIsT0FBTyxJQUFJLElBQUk7QUFBQSxFQUNuRixDQUFDO0FBRUQsU0FBTztBQUNUOzs7QUN6R08sSUFBTSxVQUFVOzs7QUNLdkIsSUFBTSxhQUFhLENBQUM7QUFHcEIsQ0FBQyxVQUFVLFdBQVcsVUFBVSxZQUFZLFVBQVUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxNQUFNLE1BQU07QUFDbkYsYUFBVyxJQUFJLElBQUksU0FBUyxVQUFVLE9BQU87QUFDM0MsV0FBTyxPQUFPLFVBQVUsUUFBUSxPQUFPLElBQUksSUFBSSxPQUFPLE9BQU87QUFBQSxFQUMvRDtBQUNGLENBQUM7QUFFRCxJQUFNLHFCQUFxQixDQUFDO0FBVzVCLFdBQVcsZUFBZSxTQUFTLGFBQWEsV0FBVyxTQUFTLFNBQVM7QUFDM0UsV0FBUyxjQUFjLEtBQUssTUFBTTtBQUNoQyxXQUFPLGFBQWEsVUFBVSw0QkFBNkIsTUFBTSxNQUFPLFFBQVEsVUFBVSxPQUFPLFVBQVU7QUFBQSxFQUM3RztBQUdBLFNBQU8sQ0FBQyxPQUFPLEtBQUssU0FBUztBQUMzQixRQUFJLGNBQWMsT0FBTztBQUN2QixZQUFNLElBQUk7QUFBQSxRQUNSLGNBQWMsS0FBSyx1QkFBdUIsVUFBVSxTQUFTLFVBQVUsR0FBRztBQUFBLFFBQzFFLG1CQUFXO0FBQUEsTUFDYjtBQUFBLElBQ0Y7QUFFQSxRQUFJLFdBQVcsQ0FBQyxtQkFBbUIsR0FBRyxHQUFHO0FBQ3ZDLHlCQUFtQixHQUFHLElBQUk7QUFFMUIsY0FBUTtBQUFBLFFBQ047QUFBQSxVQUNFO0FBQUEsVUFDQSxpQ0FBaUMsVUFBVTtBQUFBLFFBQzdDO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFFQSxXQUFPLFlBQVksVUFBVSxPQUFPLEtBQUssSUFBSSxJQUFJO0FBQUEsRUFDbkQ7QUFDRjtBQVlBLFNBQVMsY0FBYyxTQUFTLFFBQVEsY0FBYztBQUNwRCxNQUFJLE9BQU8sWUFBWSxVQUFVO0FBQy9CLFVBQU0sSUFBSSxtQkFBVyw2QkFBNkIsbUJBQVcsb0JBQW9CO0FBQUEsRUFDbkY7QUFDQSxRQUFNLE9BQU8sT0FBTyxLQUFLLE9BQU87QUFDaEMsTUFBSSxJQUFJLEtBQUs7QUFDYixTQUFPLE1BQU0sR0FBRztBQUNkLFVBQU0sTUFBTSxLQUFLLENBQUM7QUFDbEIsVUFBTSxZQUFZLE9BQU8sR0FBRztBQUM1QixRQUFJLFdBQVc7QUFDYixZQUFNLFFBQVEsUUFBUSxHQUFHO0FBQ3pCLFlBQU0sU0FBUyxVQUFVLFVBQWEsVUFBVSxPQUFPLEtBQUssT0FBTztBQUNuRSxVQUFJLFdBQVcsTUFBTTtBQUNuQixjQUFNLElBQUksbUJBQVcsWUFBWSxNQUFNLGNBQWMsUUFBUSxtQkFBVyxvQkFBb0I7QUFBQSxNQUM5RjtBQUNBO0FBQUEsSUFDRjtBQUNBLFFBQUksaUJBQWlCLE1BQU07QUFDekIsWUFBTSxJQUFJLG1CQUFXLG9CQUFvQixLQUFLLG1CQUFXLGNBQWM7QUFBQSxJQUN6RTtBQUFBLEVBQ0Y7QUFDRjtBQUVBLElBQU8sb0JBQVE7QUFBQSxFQUNiO0FBQUEsRUFDQTtBQUNGOzs7QUMvRUEsSUFBTUMsY0FBYSxrQkFBVTtBQVM3QixJQUFNLFFBQU4sTUFBWTtBQUFBLEVBQ1YsWUFBWSxnQkFBZ0I7QUFDMUIsU0FBSyxXQUFXO0FBQ2hCLFNBQUssZUFBZTtBQUFBLE1BQ2xCLFNBQVMsSUFBSSwyQkFBbUI7QUFBQSxNQUNoQyxVQUFVLElBQUksMkJBQW1CO0FBQUEsSUFDbkM7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBVUEsUUFBUSxhQUFhLFFBQVE7QUFHM0IsUUFBSSxPQUFPLGdCQUFnQixVQUFVO0FBQ25DLGVBQVMsVUFBVSxDQUFDO0FBQ3BCLGFBQU8sTUFBTTtBQUFBLElBQ2YsT0FBTztBQUNMLGVBQVMsZUFBZSxDQUFDO0FBQUEsSUFDM0I7QUFFQSxhQUFTLFlBQVksS0FBSyxVQUFVLE1BQU07QUFFMUMsVUFBTSxFQUFDLGNBQUFDLGVBQWMsa0JBQWtCLFFBQU8sSUFBSTtBQUVsRCxRQUFJQSxrQkFBaUIsUUFBVztBQUM5Qix3QkFBVSxjQUFjQSxlQUFjO0FBQUEsUUFDcEMsbUJBQW1CRCxZQUFXLGFBQWFBLFlBQVcsT0FBTztBQUFBLFFBQzdELG1CQUFtQkEsWUFBVyxhQUFhQSxZQUFXLE9BQU87QUFBQSxRQUM3RCxxQkFBcUJBLFlBQVcsYUFBYUEsWUFBVyxPQUFPO0FBQUEsTUFDakUsR0FBRyxLQUFLO0FBQUEsSUFDVjtBQUVBLFFBQUksb0JBQW9CLE1BQU07QUFDNUIsVUFBSSxjQUFNLFdBQVcsZ0JBQWdCLEdBQUc7QUFDdEMsZUFBTyxtQkFBbUI7QUFBQSxVQUN4QixXQUFXO0FBQUEsUUFDYjtBQUFBLE1BQ0YsT0FBTztBQUNMLDBCQUFVLGNBQWMsa0JBQWtCO0FBQUEsVUFDeEMsUUFBUUEsWUFBVztBQUFBLFVBQ25CLFdBQVdBLFlBQVc7QUFBQSxRQUN4QixHQUFHLElBQUk7QUFBQSxNQUNUO0FBQUEsSUFDRjtBQUdBLFdBQU8sVUFBVSxPQUFPLFVBQVUsS0FBSyxTQUFTLFVBQVUsT0FBTyxZQUFZO0FBRzdFLFFBQUksaUJBQWlCLFdBQVcsY0FBTTtBQUFBLE1BQ3BDLFFBQVE7QUFBQSxNQUNSLFFBQVEsT0FBTyxNQUFNO0FBQUEsSUFDdkI7QUFFQSxlQUFXLGNBQU07QUFBQSxNQUNmLENBQUMsVUFBVSxPQUFPLFFBQVEsUUFBUSxPQUFPLFNBQVMsUUFBUTtBQUFBLE1BQzFELENBQUMsV0FBVztBQUNWLGVBQU8sUUFBUSxNQUFNO0FBQUEsTUFDdkI7QUFBQSxJQUNGO0FBRUEsV0FBTyxVQUFVLHFCQUFhLE9BQU8sZ0JBQWdCLE9BQU87QUFHNUQsVUFBTSwwQkFBMEIsQ0FBQztBQUNqQyxRQUFJLGlDQUFpQztBQUNyQyxTQUFLLGFBQWEsUUFBUSxRQUFRLFNBQVMsMkJBQTJCLGFBQWE7QUFDakYsVUFBSSxPQUFPLFlBQVksWUFBWSxjQUFjLFlBQVksUUFBUSxNQUFNLE1BQU0sT0FBTztBQUN0RjtBQUFBLE1BQ0Y7QUFFQSx1Q0FBaUMsa0NBQWtDLFlBQVk7QUFFL0UsOEJBQXdCLFFBQVEsWUFBWSxXQUFXLFlBQVksUUFBUTtBQUFBLElBQzdFLENBQUM7QUFFRCxVQUFNLDJCQUEyQixDQUFDO0FBQ2xDLFNBQUssYUFBYSxTQUFTLFFBQVEsU0FBUyx5QkFBeUIsYUFBYTtBQUNoRiwrQkFBeUIsS0FBSyxZQUFZLFdBQVcsWUFBWSxRQUFRO0FBQUEsSUFDM0UsQ0FBQztBQUVELFFBQUk7QUFDSixRQUFJLElBQUk7QUFDUixRQUFJO0FBRUosUUFBSSxDQUFDLGdDQUFnQztBQUNuQyxZQUFNLFFBQVEsQ0FBQyxnQkFBZ0IsS0FBSyxJQUFJLEdBQUcsTUFBUztBQUNwRCxZQUFNLFFBQVEsTUFBTSxPQUFPLHVCQUF1QjtBQUNsRCxZQUFNLEtBQUssTUFBTSxPQUFPLHdCQUF3QjtBQUNoRCxZQUFNLE1BQU07QUFFWixnQkFBVSxRQUFRLFFBQVEsTUFBTTtBQUVoQyxhQUFPLElBQUksS0FBSztBQUNkLGtCQUFVLFFBQVEsS0FBSyxNQUFNLEdBQUcsR0FBRyxNQUFNLEdBQUcsQ0FBQztBQUFBLE1BQy9DO0FBRUEsYUFBTztBQUFBLElBQ1Q7QUFFQSxVQUFNLHdCQUF3QjtBQUU5QixRQUFJLFlBQVk7QUFFaEIsUUFBSTtBQUVKLFdBQU8sSUFBSSxLQUFLO0FBQ2QsWUFBTSxjQUFjLHdCQUF3QixHQUFHO0FBQy9DLFlBQU0sYUFBYSx3QkFBd0IsR0FBRztBQUM5QyxVQUFJO0FBQ0Ysb0JBQVksWUFBWSxTQUFTO0FBQUEsTUFDbkMsU0FBUyxPQUFQO0FBQ0EsbUJBQVcsS0FBSyxNQUFNLEtBQUs7QUFDM0I7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUVBLFFBQUk7QUFDRixnQkFBVSxnQkFBZ0IsS0FBSyxNQUFNLFNBQVM7QUFBQSxJQUNoRCxTQUFTLE9BQVA7QUFDQSxhQUFPLFFBQVEsT0FBTyxLQUFLO0FBQUEsSUFDN0I7QUFFQSxRQUFJO0FBQ0osVUFBTSx5QkFBeUI7QUFFL0IsV0FBTyxJQUFJLEtBQUs7QUFDZCxnQkFBVSxRQUFRLEtBQUsseUJBQXlCLEdBQUcsR0FBRyx5QkFBeUIsR0FBRyxDQUFDO0FBQUEsSUFDckY7QUFFQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsT0FBTyxRQUFRO0FBQ2IsYUFBUyxZQUFZLEtBQUssVUFBVSxNQUFNO0FBQzFDLFVBQU0sV0FBVyxjQUFjLE9BQU8sU0FBUyxPQUFPLEdBQUc7QUFDekQsV0FBTyxTQUFTLFVBQVUsT0FBTyxRQUFRLE9BQU8sZ0JBQWdCO0FBQUEsRUFDbEU7QUFDRjtBQUdBLGNBQU0sUUFBUSxDQUFDLFVBQVUsT0FBTyxRQUFRLFNBQVMsR0FBRyxTQUFTLG9CQUFvQixRQUFRO0FBRXZGLFFBQU0sVUFBVSxNQUFNLElBQUksU0FBUyxLQUFLLFFBQVE7QUFDOUMsV0FBTyxLQUFLLFFBQVEsWUFBWSxVQUFVLENBQUMsR0FBRztBQUFBLE1BQzVDO0FBQUEsTUFDQTtBQUFBLE1BQ0EsT0FBTyxVQUFVLENBQUMsR0FBRztBQUFBLElBQ3ZCLENBQUMsQ0FBQztBQUFBLEVBQ0o7QUFDRixDQUFDO0FBRUQsY0FBTSxRQUFRLENBQUMsUUFBUSxPQUFPLE9BQU8sR0FBRyxTQUFTLHNCQUFzQixRQUFRO0FBRzdFLFdBQVMsbUJBQW1CLFFBQVE7QUFDbEMsV0FBTyxTQUFTLFdBQVcsS0FBSyxNQUFNLFFBQVE7QUFDNUMsYUFBTyxLQUFLLFFBQVEsWUFBWSxVQUFVLENBQUMsR0FBRztBQUFBLFFBQzVDO0FBQUEsUUFDQSxTQUFTLFNBQVM7QUFBQSxVQUNoQixnQkFBZ0I7QUFBQSxRQUNsQixJQUFJLENBQUM7QUFBQSxRQUNMO0FBQUEsUUFDQTtBQUFBLE1BQ0YsQ0FBQyxDQUFDO0FBQUEsSUFDSjtBQUFBLEVBQ0Y7QUFFQSxRQUFNLFVBQVUsTUFBTSxJQUFJLG1CQUFtQjtBQUU3QyxRQUFNLFVBQVUsU0FBUyxNQUFNLElBQUksbUJBQW1CLElBQUk7QUFDNUQsQ0FBQztBQUVELElBQU8sZ0JBQVE7OztBQzdMZixJQUFNLGNBQU4sTUFBa0I7QUFBQSxFQUNoQixZQUFZLFVBQVU7QUFDcEIsUUFBSSxPQUFPLGFBQWEsWUFBWTtBQUNsQyxZQUFNLElBQUksVUFBVSw4QkFBOEI7QUFBQSxJQUNwRDtBQUVBLFFBQUk7QUFFSixTQUFLLFVBQVUsSUFBSSxRQUFRLFNBQVMsZ0JBQWdCLFNBQVM7QUFDM0QsdUJBQWlCO0FBQUEsSUFDbkIsQ0FBQztBQUVELFVBQU0sUUFBUTtBQUdkLFNBQUssUUFBUSxLQUFLLFlBQVU7QUFDMUIsVUFBSSxDQUFDLE1BQU07QUFBWTtBQUV2QixVQUFJLElBQUksTUFBTSxXQUFXO0FBRXpCLGFBQU8sTUFBTSxHQUFHO0FBQ2QsY0FBTSxXQUFXLENBQUMsRUFBRSxNQUFNO0FBQUEsTUFDNUI7QUFDQSxZQUFNLGFBQWE7QUFBQSxJQUNyQixDQUFDO0FBR0QsU0FBSyxRQUFRLE9BQU8saUJBQWU7QUFDakMsVUFBSTtBQUVKLFlBQU0sVUFBVSxJQUFJLFFBQVEsYUFBVztBQUNyQyxjQUFNLFVBQVUsT0FBTztBQUN2QixtQkFBVztBQUFBLE1BQ2IsQ0FBQyxFQUFFLEtBQUssV0FBVztBQUVuQixjQUFRLFNBQVMsU0FBUyxTQUFTO0FBQ2pDLGNBQU0sWUFBWSxRQUFRO0FBQUEsTUFDNUI7QUFFQSxhQUFPO0FBQUEsSUFDVDtBQUVBLGFBQVMsU0FBUyxPQUFPLFNBQVMsUUFBUSxTQUFTO0FBQ2pELFVBQUksTUFBTSxRQUFRO0FBRWhCO0FBQUEsTUFDRjtBQUVBLFlBQU0sU0FBUyxJQUFJLHNCQUFjLFNBQVMsUUFBUSxPQUFPO0FBQ3pELHFCQUFlLE1BQU0sTUFBTTtBQUFBLElBQzdCLENBQUM7QUFBQSxFQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxtQkFBbUI7QUFDakIsUUFBSSxLQUFLLFFBQVE7QUFDZixZQUFNLEtBQUs7QUFBQSxJQUNiO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBTUEsVUFBVSxVQUFVO0FBQ2xCLFFBQUksS0FBSyxRQUFRO0FBQ2YsZUFBUyxLQUFLLE1BQU07QUFDcEI7QUFBQSxJQUNGO0FBRUEsUUFBSSxLQUFLLFlBQVk7QUFDbkIsV0FBSyxXQUFXLEtBQUssUUFBUTtBQUFBLElBQy9CLE9BQU87QUFDTCxXQUFLLGFBQWEsQ0FBQyxRQUFRO0FBQUEsSUFDN0I7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxZQUFZLFVBQVU7QUFDcEIsUUFBSSxDQUFDLEtBQUssWUFBWTtBQUNwQjtBQUFBLElBQ0Y7QUFDQSxVQUFNLFFBQVEsS0FBSyxXQUFXLFFBQVEsUUFBUTtBQUM5QyxRQUFJLFVBQVUsSUFBSTtBQUNoQixXQUFLLFdBQVcsT0FBTyxPQUFPLENBQUM7QUFBQSxJQUNqQztBQUFBLEVBQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBTUEsT0FBTyxTQUFTO0FBQ2QsUUFBSTtBQUNKLFVBQU0sUUFBUSxJQUFJLFlBQVksU0FBUyxTQUFTLEdBQUc7QUFDakQsZUFBUztBQUFBLElBQ1gsQ0FBQztBQUNELFdBQU87QUFBQSxNQUNMO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0Y7QUFFQSxJQUFPLHNCQUFROzs7QUNqR0EsU0FBUixPQUF3QixVQUFVO0FBQ3ZDLFNBQU8sU0FBUyxLQUFLLEtBQUs7QUFDeEIsV0FBTyxTQUFTLE1BQU0sTUFBTSxHQUFHO0FBQUEsRUFDakM7QUFDRjs7O0FDaEJlLFNBQVIsYUFBOEIsU0FBUztBQUM1QyxTQUFPLGNBQU0sU0FBUyxPQUFPLEtBQU0sUUFBUSxpQkFBaUI7QUFDOUQ7OztBQ2JBLElBQU0saUJBQWlCO0FBQUEsRUFDckIsVUFBVTtBQUFBLEVBQ1Ysb0JBQW9CO0FBQUEsRUFDcEIsWUFBWTtBQUFBLEVBQ1osWUFBWTtBQUFBLEVBQ1osSUFBSTtBQUFBLEVBQ0osU0FBUztBQUFBLEVBQ1QsVUFBVTtBQUFBLEVBQ1YsNkJBQTZCO0FBQUEsRUFDN0IsV0FBVztBQUFBLEVBQ1gsY0FBYztBQUFBLEVBQ2QsZ0JBQWdCO0FBQUEsRUFDaEIsYUFBYTtBQUFBLEVBQ2IsaUJBQWlCO0FBQUEsRUFDakIsUUFBUTtBQUFBLEVBQ1IsaUJBQWlCO0FBQUEsRUFDakIsa0JBQWtCO0FBQUEsRUFDbEIsT0FBTztBQUFBLEVBQ1AsVUFBVTtBQUFBLEVBQ1YsYUFBYTtBQUFBLEVBQ2IsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsbUJBQW1CO0FBQUEsRUFDbkIsbUJBQW1CO0FBQUEsRUFDbkIsWUFBWTtBQUFBLEVBQ1osY0FBYztBQUFBLEVBQ2QsaUJBQWlCO0FBQUEsRUFDakIsV0FBVztBQUFBLEVBQ1gsVUFBVTtBQUFBLEVBQ1Ysa0JBQWtCO0FBQUEsRUFDbEIsZUFBZTtBQUFBLEVBQ2YsNkJBQTZCO0FBQUEsRUFDN0IsZ0JBQWdCO0FBQUEsRUFDaEIsVUFBVTtBQUFBLEVBQ1YsTUFBTTtBQUFBLEVBQ04sZ0JBQWdCO0FBQUEsRUFDaEIsb0JBQW9CO0FBQUEsRUFDcEIsaUJBQWlCO0FBQUEsRUFDakIsWUFBWTtBQUFBLEVBQ1osc0JBQXNCO0FBQUEsRUFDdEIscUJBQXFCO0FBQUEsRUFDckIsbUJBQW1CO0FBQUEsRUFDbkIsV0FBVztBQUFBLEVBQ1gsb0JBQW9CO0FBQUEsRUFDcEIscUJBQXFCO0FBQUEsRUFDckIsUUFBUTtBQUFBLEVBQ1Isa0JBQWtCO0FBQUEsRUFDbEIsVUFBVTtBQUFBLEVBQ1YsaUJBQWlCO0FBQUEsRUFDakIsc0JBQXNCO0FBQUEsRUFDdEIsaUJBQWlCO0FBQUEsRUFDakIsNkJBQTZCO0FBQUEsRUFDN0IsNEJBQTRCO0FBQUEsRUFDNUIscUJBQXFCO0FBQUEsRUFDckIsZ0JBQWdCO0FBQUEsRUFDaEIsWUFBWTtBQUFBLEVBQ1osb0JBQW9CO0FBQUEsRUFDcEIsZ0JBQWdCO0FBQUEsRUFDaEIseUJBQXlCO0FBQUEsRUFDekIsdUJBQXVCO0FBQUEsRUFDdkIscUJBQXFCO0FBQUEsRUFDckIsY0FBYztBQUFBLEVBQ2QsYUFBYTtBQUFBLEVBQ2IsK0JBQStCO0FBQ2pDO0FBRUEsT0FBTyxRQUFRLGNBQWMsRUFBRSxRQUFRLENBQUMsQ0FBQyxLQUFLLEtBQUssTUFBTTtBQUN2RCxpQkFBZSxLQUFLLElBQUk7QUFDMUIsQ0FBQztBQUVELElBQU8seUJBQVE7OztBQzNDZixTQUFTLGVBQWUsZUFBZTtBQUNyQyxRQUFNLFVBQVUsSUFBSSxjQUFNLGFBQWE7QUFDdkMsUUFBTSxXQUFXLEtBQUssY0FBTSxVQUFVLFNBQVMsT0FBTztBQUd0RCxnQkFBTSxPQUFPLFVBQVUsY0FBTSxXQUFXLFNBQVMsRUFBQyxZQUFZLEtBQUksQ0FBQztBQUduRSxnQkFBTSxPQUFPLFVBQVUsU0FBUyxNQUFNLEVBQUMsWUFBWSxLQUFJLENBQUM7QUFHeEQsV0FBUyxTQUFTLFNBQVMsT0FBTyxnQkFBZ0I7QUFDaEQsV0FBTyxlQUFlLFlBQVksZUFBZSxjQUFjLENBQUM7QUFBQSxFQUNsRTtBQUVBLFNBQU87QUFDVDtBQUdBLElBQU0sUUFBUSxlQUFlLGdCQUFRO0FBR3JDLE1BQU0sUUFBUTtBQUdkLE1BQU0sZ0JBQWdCO0FBQ3RCLE1BQU0sY0FBYztBQUNwQixNQUFNLFdBQVc7QUFDakIsTUFBTSxVQUFVO0FBQ2hCLE1BQU0sYUFBYTtBQUduQixNQUFNLGFBQWE7QUFHbkIsTUFBTSxTQUFTLE1BQU07QUFHckIsTUFBTSxNQUFNLFNBQVMsSUFBSSxVQUFVO0FBQ2pDLFNBQU8sUUFBUSxJQUFJLFFBQVE7QUFDN0I7QUFFQSxNQUFNLFNBQVM7QUFHZixNQUFNLGVBQWU7QUFHckIsTUFBTSxjQUFjO0FBRXBCLE1BQU0sZUFBZTtBQUVyQixNQUFNLGFBQWEsV0FBUyx1QkFBZSxjQUFNLFdBQVcsS0FBSyxJQUFJLElBQUksU0FBUyxLQUFLLElBQUksS0FBSztBQUVoRyxNQUFNLGFBQWEsaUJBQVM7QUFFNUIsTUFBTSxpQkFBaUI7QUFFdkIsTUFBTSxVQUFVO0FBR2hCLElBQU8sZ0JBQVE7OztBQ25GZixJQUFNO0FBQUEsRUFDSixPQUFBRTtBQUFBLEVBQ0EsWUFBQUM7QUFBQSxFQUNBLGVBQUFDO0FBQUEsRUFDQSxVQUFBQztBQUFBLEVBQ0EsYUFBQUM7QUFBQSxFQUNBLFNBQUFDO0FBQUEsRUFDQSxLQUFBQztBQUFBLEVBQ0E7QUFBQSxFQUNBLGNBQUFDO0FBQUEsRUFDQSxRQUFBQztBQUFBLEVBQ0EsWUFBQUM7QUFBQSxFQUNBLGNBQUFDO0FBQUEsRUFDQSxnQkFBQUM7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0EsYUFBQUM7QUFDRixJQUFJOzs7QTVDbURKLElBQU0sV0FBVyxJQUFJLFNBQTJCO0FBQzlDLFFBQU1DLFFBQU8sS0FBSyxLQUFLLEdBQUc7QUFDMUIsUUFBTSxNQUFNQSxNQUFLLE1BQU1BLE1BQUssWUFBWSxHQUFHLENBQUM7QUFDNUMsUUFBTSxRQUFRQSxNQUFLLE1BQU0sR0FBR0EsTUFBSyxZQUFZLEdBQUcsQ0FBQyxFQUFFLFFBQVEsUUFBUSxLQUFLO0FBQ3hFLFVBQVEsUUFBUSxLQUFLLFFBQVEsUUFBUSxLQUFLO0FBQzVDO0FBQ0EsU0FBUyxvQkFBb0IsUUFBZ0I7QUFDM0MsTUFBSSxlQUFlLEtBQUssTUFBTTtBQUM5QixNQUFJLFFBQVEsSUFBSSxXQUFXLGFBQWEsTUFBTTtBQUM5QyxXQUFTLElBQUksR0FBRyxJQUFJLGFBQWEsUUFBUSxLQUFLO0FBQzVDLFVBQU0sQ0FBQyxJQUFJLGFBQWEsV0FBVyxDQUFDO0FBQUEsRUFDdEM7QUFDQSxTQUFPLE1BQU07QUFDZjtBQUdBLElBQU0sUUFBUSxDQUFDLE1BQWMsYUFBcUIsT0FBTztBQUFBLEVBQ3ZELE1BQU0sQ0FBQyxRQUFnQixNQUFNLE9BQU8sS0FBSyxVQUFVO0FBQUEsRUFDbkQsS0FBSyxDQUFDLEtBQWEsVUFBa0IsTUFBTSxRQUFRLGNBQWMsSUFBSSxNQUFNLE9BQU8sR0FBRyxPQUFPLFNBQVMsYUFBYSxDQUFDO0FBQUEsRUFDbkgsUUFBUSxDQUFDLEtBQWEsVUFBa0IsTUFBTSxLQUFLLFFBQVEsSUFBSSxPQUFPLEtBQUssR0FBRyxVQUFVO0FBQUEsRUFDeEYsT0FBTztBQUNUO0FBSU8sSUFBTSxZQUFOLE1BQWdCO0FBQUEsRUFFckIsY0FBYztBQUtkLGNBQUssTUFBTSxTQUFTLEtBQUssUUFBUSxTQUFTLEtBQUssUUFBUSxVQUFVO0FBQ2pFLGtCQUFTLE1BQU07QUFDYixhQUFPO0FBQUEsUUFDTCxpQkFBaUIsS0FBSyxRQUFRO0FBQUEsUUFDOUIsZ0JBQWdCO0FBQUEsTUFDbEI7QUFBQSxJQUNGO0FBQ0EsZUFBTTtBQUFBLE1BQ0osU0FBUyxNQUFNLE1BQU0sR0FBRyxLQUFLLFFBQVEsZ0JBQWdCLEtBQUssR0FBRyxzQkFBc0I7QUFBQSxNQUNuRixVQUFVLE1BQU0sTUFBTSxHQUFHLEtBQUssUUFBUSxnQkFBZ0IsS0FBSyxHQUFHLHVCQUF1QjtBQUFBLE1BQ3JGLE9BQU8sTUFBTSxNQUFNLEdBQUcsS0FBSyxRQUFRLGdCQUFnQixLQUFLLEdBQUcsb0JBQW9CO0FBQUEsSUFDakY7QUFBQSxFQWZBO0FBQUEsRUFDQSxXQUFXLFNBQXdCO0FBQ2pDLFNBQUssVUFBVTtBQUFBLEVBQ2pCO0FBQUEsRUFhQSxNQUFNLHVCQUF1QkEsT0FBK0I7QUFDMUQsVUFBTSxlQUFlLE1BQU0sSUFBSSxNQUFNLFFBQVEsV0FBV0EsS0FBSTtBQUM1RCxlQUFPLHFDQUFvQixZQUFZO0FBQUEsRUFDekM7QUFBQSxFQUNBLE1BQU0sZ0JBQWdCLGFBQXFCLFlBQXFCLHNCQUErQixPQUFzQjtBQUNuSCxRQUFJLENBQUM7QUFBWSxtQkFBYTtBQUM5QixVQUFNLGNBQWMsTUFBTSxLQUFLLEtBQUssV0FBVztBQUMvQyxRQUFJLENBQUMsYUFBYTtBQUNoQixVQUFJO0FBQ0YsYUFBSyxPQUFPLFdBQVc7QUFBQSxJQUMzQjtBQUVFLFVBQUksTUFBTSxRQUFRLFlBQVksWUFBWSxvQkFBb0IsWUFBWSxLQUFLLE9BQU8sQ0FBQztBQUFBLEVBQzNGO0FBQUEsRUFDQSxNQUFNLGVBQWU7QUFDbkIsVUFBTSxNQUFNLEtBQUssSUFBSSxTQUFTLEVBQzNCLElBQUksTUFBTSxNQUFNO0FBRW5CLFVBQU0sTUFBYSxDQUFDO0FBQ3BCLFFBQUk7QUFDRixZQUFNLEtBQUssV0FBVyxHQUFHLEtBQUssT0FBTyxhQUFhO0FBQ2hELFlBQUksS0FBSyxHQUFHLFNBQVMsS0FBSyxJQUFJLENBQUMsU0FBYyxLQUFLLElBQUksQ0FBQztBQUFBLE1BQ3pELENBQUM7QUFBQSxJQUNILFNBQVMsR0FBUDtBQUNBLFVBQUksdUJBQU87QUFBQSxFQUF3QixJQUFJLE9BQU87QUFBQSxJQUNoRDtBQUNBLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxNQUFNLGNBQWMsUUFBZ0IsZUFBdUI7QUFDekQsVUFBTSxNQUFNLEtBQUssSUFBSSxTQUFTLEVBQzNCLElBQUksVUFBVSxTQUFTLE1BQU0sQ0FBQyxFQUM5QixJQUFJLE9BQU8sU0FBUyxhQUFhLENBQUMsRUFDbEM7QUFFSCxVQUFNLE1BQWEsQ0FBQztBQUNwQixRQUFJO0FBQ0YsWUFBTSxjQUFNLEtBQUssS0FBSyxNQUFNO0FBQUEsUUFDMUIsU0FBUyxLQUFLLE9BQU87QUFBQSxNQUN2QixDQUFDO0FBQUEsSUFDSCxTQUFTLEdBQVA7QUFDQSxVQUFJLHVCQUFPO0FBQUEsRUFBZ0MsS0FBSztBQUFBLElBQ2xEO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLE1BQU0sbUJBQW1CO0FBQ3ZCLFVBQU0sTUFBTSxLQUFLLElBQUksUUFBUSxFQUMxQixJQUFJLGNBQWMsTUFBTSxFQUN4QixJQUFJLE9BQU8sTUFBTSxFQUNqQixJQUFJLFlBQVksR0FBRyxFQUNuQjtBQUNILFVBQU0sTUFBTSxNQUFNLGNBQU0sSUFBSSxLQUFLO0FBQUEsTUFDL0IsU0FBUyxLQUFLLE9BQU87QUFBQSxJQUN2QixDQUFDO0FBQ0QsVUFBTSxjQUFjLElBQUksS0FBSyxJQUFJO0FBQ2pDLFdBQU8sSUFBSSxrQkFBa0IsWUFBWSxFQUFFO0FBQzNDLFdBQU8sSUFBSSxvQkFBb0IsWUFBWSxjQUFjO0FBQUEsRUFDM0Q7QUFBQSxFQUNBLHNCQUFzQixNQUF5QjtBQUM3QyxXQUFPO0FBQUEsTUFDTCxHQUFHO0FBQUEsTUFDSCxZQUFZLElBQUksS0FBSyxLQUFLLFVBQVU7QUFBQSxNQUNwQyxlQUFlLElBQUksS0FBSyxLQUFLLGFBQWE7QUFBQSxNQUMxQyxnQkFBZ0IsSUFBSSxLQUFLLEtBQUssY0FBYztBQUFBLElBQzlDO0FBQUEsRUFDRjtBQUFBLEVBQ0EsTUFBTSxXQUFXLEtBQTJDO0FBQzFELFVBQU0sTUFBTSxLQUFLLElBQUksUUFBUSxFQUMxQixLQUFLLE1BQU0sR0FBRztBQUNqQixRQUFJO0FBQ0YsWUFBTSxNQUFNLE1BQU0sY0FBTSxJQUFJLElBQUksT0FBTztBQUFBLFFBQ3JDLFNBQVMsS0FBSyxPQUFPO0FBQUEsTUFDdkIsQ0FBQztBQUNELGFBQU8sS0FBSyxzQkFBc0IsSUFBSSxJQUFJO0FBQUEsSUFDNUMsU0FBUyxHQUFQO0FBQ0EsVUFBSSx1QkFBTztBQUFBLEVBQXNCLElBQUksT0FBTztBQUFBLElBQzlDO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLE1BQU0sY0FBYztBQUNsQixVQUFNLE1BQU0sS0FBSyxJQUFJLFFBQVEsRUFDMUIsSUFBSSxjQUFjLE1BQU0sRUFDeEIsSUFBSSxPQUFPLE1BQU0sRUFDakIsSUFBSSxZQUFZLEtBQUssUUFBUSxNQUFNLEVBQ25DLElBQUksU0FBUyxPQUFPLElBQUksa0JBQWtCLEtBQUssSUFBSSxLQUFLLEVBQUUsWUFBWSxDQUFDO0FBRzFFLFVBQU0sTUFBYSxDQUFDO0FBQ3BCLFFBQUk7QUFDRixZQUFNLEtBQUssV0FBVyxHQUFHLEtBQUssQ0FBQyxhQUFhO0FBQzFDLFlBQUksS0FBSyxHQUFHLFNBQVMsSUFBSTtBQUFBLE1BQzNCLENBQUM7QUFBQSxJQUNILFNBQVMsR0FBUDtBQUNBLFVBQUksdUJBQU87QUFBQSxFQUF1QixJQUFJLE9BQU87QUFBQSxJQUMvQztBQUNBLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxNQUFNLGtCQUFrQjtBQUN0QixVQUFNLE1BQU0sS0FBSyxJQUFJLFFBQVEsRUFDMUIsSUFBSSxjQUFjLE1BQU0sRUFDeEIsSUFBSSxZQUFZLEtBQUssUUFBUSxNQUFNLEVBQ25DLElBQUksT0FBTyxNQUFNO0FBRXBCLFVBQU0sTUFBYSxDQUFDO0FBQ3BCLFFBQUk7QUFDRixZQUFNLEtBQUssV0FBVyxHQUFHLEtBQUssQ0FBQyxhQUFhO0FBQzFDLFlBQUksS0FBSyxHQUFHLFNBQVMsSUFBSTtBQUFBLE1BQzNCLENBQUM7QUFBQSxJQUNILFNBQVMsR0FBUDtBQUNBLFVBQUksdUJBQU87QUFBQSxFQUF1QixJQUFJLE9BQU87QUFBQSxJQUMvQztBQUNBLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxNQUFNLG1CQUFtQkEsT0FBYztBQUNyQyxVQUFNLE1BQU0sS0FBSyxJQUFJLE1BQU0sRUFBRSxLQUFLLElBQUksU0FBU0EsS0FBSSxHQUFHLEVBQ25ELElBQUksT0FBTyxLQUFLLFFBQVEsTUFBTTtBQUVqQyxRQUFJO0FBQ0YsYUFBTyxNQUFNLGNBQU0sS0FBSyxJQUFJLE9BQU87QUFBQSxRQUNqQyxTQUFTLEtBQUssT0FBTztBQUFBLE1BQ3ZCLENBQUM7QUFBQSxJQUNILFNBQVMsR0FBUDtBQUNBLFVBQUksdUJBQU87QUFBQSxFQUEyQixJQUFJLE9BQU87QUFBQSxJQUNuRDtBQUNBLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxNQUFNLFdBQVcsWUFBb0IsS0FBWSxVQUE4QixXQUFtQixLQUFLO0FBbFB6RztBQW1QSSxVQUFNLFdBQVcsSUFBSSxJQUFJLFlBQVksU0FBUyxTQUFTLENBQUMsRUFBRSxJQUFJLFFBQVEsV0FBVyxTQUFTLENBQUM7QUFDM0YsVUFBTSxNQUFNLE1BQU0sY0FBTSxJQUFJLFNBQVMsT0FBTyxFQUFFLFNBQVMsS0FBSyxPQUFPLEVBQUUsQ0FBQztBQUN0RSxVQUFJLFNBQUksU0FBSixtQkFBVSxXQUFVO0FBQUc7QUFDM0IsVUFBTSxTQUFTLEdBQUc7QUFDbEIsVUFBTSxLQUFLLFdBQVcsYUFBYSxHQUFHLEtBQUssVUFBVSxRQUFRO0FBQUEsRUFDL0Q7QUFBQSxFQUNBLE1BQU0sTUFBTUEsT0FBWTtBQUN0QixVQUFNLE1BQU0sS0FBSyxJQUFJLE1BQU0sRUFDMUIsS0FBSyxJQUFJLFNBQVNBLEtBQUksU0FBUyxFQUMvQixJQUFJLE9BQU8sS0FBSyxRQUFRLE1BQU0sRUFDOUI7QUFDRCxRQUFJO0FBQ0YsWUFBTSxNQUFNLE1BQU0sY0FBTSxJQUFJLEtBQUs7QUFBQSxRQUMvQixTQUFTLEtBQUssT0FBTztBQUFBLE1BQ3ZCLENBQUM7QUFDRCxhQUFPLElBQUk7QUFBQSxJQUNiLFNBQVMsR0FBUDtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQUEsRUFDQSxNQUFNLFVBQVUsV0FBbUI7QUFDakMsVUFBTSxNQUFNLEtBQUssSUFBSSxRQUFRLEVBQzFCLEtBQUssSUFBSSxnQkFBZ0IsRUFDekI7QUFDSCxRQUFJLE1BQU07QUFDVixRQUFJO0FBQ0YsWUFBTSxNQUFNLGNBQU0sSUFBSSxLQUFLLEVBQUUsU0FBUyxLQUFLLE9BQU8sRUFBRSxDQUFDO0FBQUEsSUFDdkQsU0FBUyxHQUFQO0FBQ0EsVUFBSSx1QkFBTywrQkFBK0IsV0FBVztBQUFBLElBQ3ZEO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLE1BQU0sT0FBT0EsT0FBYyxTQUE4QixDQUFDLEdBQUcsZ0JBQXlCLE1BQU0sa0JBQTJCLE1BQU07QUFDM0gsVUFBTSxlQUFlLE1BQU0sS0FBSyx1QkFBdUJBLEtBQUk7QUFFM0QsVUFBTSxPQUFPO0FBQUEsTUFDWCxRQUFRLE9BQU8sVUFBVSxLQUFLLFFBQVE7QUFBQSxNQUN0QyxVQUFVLE9BQU8sWUFBWTtBQUFBLE1BQzdCLGNBQWMsT0FBTyxnQkFBZ0IsS0FBSyxRQUFRO0FBQUEsTUFDbEQsYUFBYSxPQUFPLGVBQWUsS0FBSyxRQUFRO0FBQUEsTUFDaEQsZ0JBQWdCLE9BQU8sa0JBQWtCO0FBQUEsTUFDekMsU0FBUztBQUFBLElBQ1g7QUFDQSxVQUFNLFdBQVcsR0FBRyxLQUFLLFFBQVEsZ0JBQWdCLEtBQUssR0FBRyxzQkFBc0IsU0FBU0EsS0FBSSxTQUFTLEtBQUs7QUFDMUcsUUFBSSxNQUFNO0FBQ1YsUUFBSTtBQUNGLFlBQU0sTUFBTSxjQUFNO0FBQUEsUUFDaEI7QUFBQSxRQUNBO0FBQUEsUUFBTTtBQUFBLFVBQ04sU0FBUyxLQUFLLE9BQU87QUFBQSxRQUN2QjtBQUFBLE1BQUM7QUFDRCxnQkFBVSxJQUFJLGtCQUFrQkEsUUFBTztBQUFBLElBQ3pDLFNBQVMsR0FBUDtBQUNBLGdCQUFVLElBQUksd0JBQXdCQSxRQUFPO0FBQzdDLFVBQUk7QUFDRixZQUFJLGlCQUFpQixLQUFLLFFBQVE7QUFDaEMsY0FBSSx1QkFBTyx3Q0FBd0M7QUFBQTtBQUN2RCxVQUFJO0FBQ0YsY0FBTSxLQUFLLE9BQU9BLE9BQU0sUUFBUSxlQUFlLEtBQUs7QUFBQSxNQUN0RCxTQUFRQyxJQUFOO0FBQ0EsWUFBSSxLQUFLLFFBQVE7QUFDZixjQUFJLHVCQUFPLG9CQUFvQjtBQUFBLE1BQ25DO0FBQUEsSUFDRjtBQUNBLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxNQUFNLE9BQU9ELE9BQWMsU0FBOEIsQ0FBQyxHQUFHLGdCQUF5QixNQUFNLHNCQUErQixNQUFNO0FBQy9ILFVBQU0sZUFBZSxNQUFNLEtBQUssdUJBQXVCQSxLQUFJO0FBQzNELFVBQU0sT0FBTztBQUFBLE1BQ1gsUUFBUSxPQUFPLFVBQVUsS0FBSyxRQUFRO0FBQUEsTUFDdEMsVUFBVSxPQUFPLFlBQVk7QUFBQSxNQUM3QixjQUFjLE9BQU8sZ0JBQWdCLEtBQUssUUFBUTtBQUFBLE1BQ2xELGFBQWEsT0FBTyxlQUFlLEtBQUssUUFBUTtBQUFBLE1BQ2hELGdCQUFnQixPQUFPLGtCQUFrQjtBQUFBLE1BQ3pDLFNBQVM7QUFBQSxJQUNYO0FBQ0EsVUFBTSxXQUFXLEdBQUcsS0FBSyxRQUFRLGdCQUFnQixLQUFLLEdBQUcsc0JBQXNCLFNBQVNBLEtBQUksU0FBUyxLQUFLO0FBQzFHLFFBQUksTUFBTTtBQUVWLFFBQUk7QUFDRixZQUFNLE1BQU0sY0FBTTtBQUFBLFFBQ2hCO0FBQUEsUUFDQTtBQUFBLFFBQU07QUFBQSxVQUNOLFNBQVMsS0FBSyxPQUFPO0FBQUEsUUFDdkI7QUFBQSxNQUFDO0FBQ0QsZ0JBQVUsSUFBSSxtQkFBbUJBLFFBQU87QUFBQSxJQUMxQyxTQUFTLEdBQVA7QUFDQSxnQkFBVSxJQUFJLHlCQUF5QkEsUUFBTztBQUM5QyxVQUFJO0FBQ0YsWUFBSSxpQkFBaUIsS0FBSyxRQUFRO0FBQ2hDLGNBQUksdUJBQU8sd0NBQXdDO0FBQUE7QUFDdkQsVUFBSTtBQUNGLGNBQU0sS0FBSyxPQUFPQSxPQUFNLFFBQVEsZUFBZSxLQUFLO0FBQUEsTUFDdEQsU0FBUUMsSUFBTjtBQUNBLFlBQUksS0FBSyxRQUFRO0FBQ2YsY0FBSSx1QkFBTyxvQkFBb0I7QUFBQSxNQUNuQztBQUFBLElBRUY7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBQ0EsTUFBTSxPQUFPRCxPQUFjLFNBQThCLENBQUMsR0FBRyxnQkFBeUIsTUFBTTtBQUMxRixVQUFNLE9BQU87QUFBQSxNQUNYLFFBQVEsT0FBTyxVQUFVLEtBQUssUUFBUTtBQUFBLE1BQ3RDLGNBQWMsT0FBTyxnQkFBZ0IsS0FBSyxRQUFRO0FBQUEsTUFDbEQsYUFBYSxPQUFPLGVBQWUsS0FBSyxRQUFRO0FBQUEsTUFDaEQsZ0JBQWdCLE9BQU8sa0JBQWtCO0FBQUEsSUFDM0M7QUFDQSxVQUFNLFdBQVcsR0FBRyxLQUFLLFFBQVEsZ0JBQWdCLEtBQUssR0FBRyxzQkFBc0IsU0FBU0EsS0FBSSxTQUFTLEtBQUs7QUFDMUcsUUFBSSxNQUFNO0FBQ1YsUUFBSTtBQUNGLFlBQU0sTUFBTSxjQUFNO0FBQUEsUUFDaEIsUUFBUTtBQUFBLFFBQ1IsS0FBSztBQUFBLFFBQ0w7QUFBQSxRQUNBLFNBQVMsS0FBSyxPQUFPO0FBQUEsTUFDdkIsQ0FBQztBQUNELGdCQUFVLElBQUksa0JBQWtCQSxRQUFPO0FBQUEsSUFDekMsU0FBUyxHQUFQO0FBQ0EsZ0JBQVUsSUFBSSx3QkFBd0JBLFFBQU87QUFDN0MsVUFBSSxpQkFBaUIsS0FBSyxRQUFRO0FBQ2hDLFlBQUksdUJBQU8sb0JBQW9CO0FBQUEsSUFDbkM7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBQ0EsTUFBTSxPQUFPQSxPQUFjLFVBQWtCLFNBQThCLENBQUMsR0FBRyxnQkFBeUIsTUFBTTtBQUM1RyxRQUFJO0FBQ0YsWUFBTSxLQUFLLE9BQU9BLE9BQU0sUUFBUSxhQUFhO0FBQzdDLFlBQU0sS0FBSyxPQUFPLFVBQVUsUUFBUSxhQUFhO0FBQ2pELGdCQUFVLElBQUksa0JBQWtCLGlCQUFpQkEsUUFBTztBQUFBLElBQzFELFNBQVEsR0FBTjtBQUNBLGdCQUFVLElBQUksd0JBQXdCLGlCQUFpQkEsUUFBTztBQUFBLElBQ2hFO0FBQUEsRUFDRjtBQUFBLEVBQ0EsTUFBTSxLQUFLQSxPQUFjLFNBQWlCLEtBQUssUUFBUSxRQUFRO0FBQzdELFVBQU0sV0FBVyxHQUFHLEtBQUssUUFBUSxnQkFBZ0IsS0FBSyxHQUFHLHNCQUFzQixTQUFTQSxLQUFJLFNBQVM7QUFDckcsUUFBSSxNQUFNO0FBQ1YsUUFBSTtBQUNGLFlBQU0sTUFBTSxjQUFNO0FBQUEsUUFDaEI7QUFBQSxRQUFVO0FBQUEsVUFDVixTQUFTLEtBQUssT0FBTztBQUFBLFFBQ3ZCO0FBQUEsTUFBQztBQUNELGdCQUFVLElBQUksaUJBQWlCQSxRQUFPO0FBQUEsSUFDeEMsU0FBUyxHQUFQO0FBQ0EsZ0JBQVUsSUFBSSx1QkFBdUJBLFFBQU87QUFDNUMsVUFBSSxLQUFLLFFBQVE7QUFDZixZQUFJLHVCQUFPLGtCQUFrQjtBQUFBLElBQ2pDO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLE1BQU0sZUFBZUEsUUFBZSxJQUFJLFFBQWdCLEdBQUcsY0FBc0IsSUFBSSxnQkFBeUIsTUFBTTtBQUNsSCxVQUFNLE1BQU0sTUFBTSxHQUFHLEtBQUssUUFBUSxnQkFBZ0IsS0FBSyxHQUFHLG1CQUFtQixFQUMxRSxJQUFJLFFBQVEsU0FBU0EsS0FBSSxDQUFDLEVBQzFCLElBQUksT0FBTyxLQUFLLFFBQVEsTUFBTSxFQUM5QixJQUFJLGFBQWEsTUFBTTtBQUUxQixVQUFNLE9BQW1CLENBQUM7QUFDMUIsVUFBTSxRQUFlLENBQUM7QUFDdEIsVUFBTSxLQUFLLFdBQVcsR0FBRyxLQUFLLENBQUMsUUFBUTtBQUNyQyxZQUFNLEtBQUssR0FBRyxJQUFJLElBQUk7QUFBQSxJQUN4QixDQUFDO0FBQ0QsZUFBVyxRQUFRLE9BQU87QUFDeEIsV0FBSyxLQUFLLENBQUMsS0FBSyxJQUFJLEtBQUssTUFBTSxLQUFLLFFBQVEsTUFBTSxDQUFDO0FBRW5ELFVBQUksS0FBSyxRQUFRLGlCQUFpQixpQkFBaUIsS0FBSyxRQUFRO0FBQzlELFlBQUksdUJBQU8sY0FBYyxLQUFLLE9BQU87QUFBQSxJQUN6QztBQUNBLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxRQUFRLE9BQWUsY0FBc0IsSUFBSSxhQUFxQixXQUFXO0FBQy9FLFVBQU0sVUFBVSxJQUFJLGlCQUFpQixJQUFJO0FBQ3pDLFlBQVEsU0FBUyxFQUFFLE9BQU8sYUFBYSxXQUFXLENBQUM7QUFDbkQsV0FBTztBQUFBLEVBQ1Q7QUFDRjtBQUVPLElBQU0sbUJBQU4sY0FBK0IsVUFBVTtBQUFBLEVBTzlDLFlBQVlFLFNBQW1CO0FBQzdCLFVBQU07QUFIUixnQkFBZ0I7QUFDaEIsaUJBQTZCLENBQUM7QUFHNUIsU0FBSyxXQUFXQSxRQUFPLE9BQU87QUFBQSxFQUNoQztBQUFBLEVBQ0EsT0FBeUI7QUFDdkIsV0FBTztBQUFBLE1BQ0wsT0FBTyxLQUFLO0FBQUEsTUFDWixhQUFhLEtBQUs7QUFBQSxNQUNsQixZQUFZLEtBQUs7QUFBQSxNQUNqQixPQUFPLENBQUM7QUFBQSxJQUNWO0FBQUEsRUFDRjtBQUFBLEVBQ0EsU0FBUyxTQUFjO0FBQ3JCLFNBQUssUUFBUSxRQUFRO0FBQ3JCLFNBQUssY0FBYyxRQUFRO0FBQzNCLFNBQUssYUFBYSxRQUFRO0FBQUEsRUFDNUI7QUFBQSxFQUNBLE1BQU0sYUFBYSxPQUE0QjtBQUM3QyxlQUFXLFFBQVEsT0FBTztBQUN4QixXQUFLLFNBQVMsS0FBSyxVQUFVO0FBQzdCLFdBQUssTUFBTSxLQUFLLElBQUk7QUFBQSxJQUN0QjtBQUNBLFFBQUksS0FBSyxNQUFNO0FBQ2IsVUFBSSxLQUFLO0FBQ1AsY0FBTSxLQUFLLGVBQWUsRUFBRSxNQUFhLENBQUM7QUFBQTtBQUUxQyxjQUFNLEtBQUssZUFBZSxFQUFFLE1BQWEsQ0FBQztBQUFBLElBQzlDO0FBQUEsRUFDRjtBQUFBLEVBQ0EsTUFBTSxnQkFBZ0IsT0FBNEI7QUFDaEQsZUFBVyxRQUFRLE9BQU87QUFDeEIsV0FBSyxTQUFTLEtBQUssVUFBVTtBQUM3QixVQUFJLENBQUMsQ0FBQyxLQUFLO0FBQ1QsYUFBSyxTQUFTO0FBRWhCLGVBQVMsU0FBUyxLQUFLLE9BQU87QUFDNUIsY0FBTSxPQUFPLEtBQUssTUFBTSxLQUFLO0FBQzdCLFlBQUksS0FBSyxhQUFhLEtBQUssYUFBYSxLQUFLLGlCQUFpQixLQUFLO0FBQ2pFLGVBQUssTUFBTSxLQUFLLElBQUk7QUFBQSxNQUN4QjtBQUFBLElBQ0Y7QUFDQSxRQUFJLEtBQUs7QUFDUCxZQUFNLEtBQUssZUFBZSxFQUFFLE1BQWEsQ0FBQztBQUFBLEVBQzlDO0FBQUEsRUFDQSxNQUFNLGdCQUFnQixPQUFvQztBQUN4RCxlQUFXLFFBQVEsT0FBTztBQUN4QixXQUFLLFNBQVM7QUFDZCxVQUFJLENBQUMsS0FBSztBQUFXO0FBQ3JCLFdBQUssVUFBVTtBQUNmLFdBQUssZ0JBQWdCO0FBQ3JCLGVBQVMsUUFBUSxHQUFHLFFBQVEsS0FBSyxNQUFNLFFBQVEsU0FBUztBQUN0RCxjQUFNLE9BQU8sS0FBSyxNQUFNLEtBQUs7QUFDN0IsWUFBSSxLQUFLLGFBQWEsS0FBSyxhQUFhLEtBQUssaUJBQWlCLEtBQUs7QUFDakUsZUFBSyxNQUFNLE9BQU8sT0FBTyxDQUFDO0FBQUEsTUFDOUI7QUFBQSxJQUNGO0FBQ0EsUUFBSSxLQUFLO0FBQ1AsWUFBTSxLQUFLLGVBQWUsRUFBRSxNQUFvQyxDQUFDO0FBQUEsRUFDckU7QUFBQSxFQUNBLE1BQU0sUUFBUSxJQUFZO0FBQ3hCLFVBQU0sVUFBVSxNQUFNLGNBQU07QUFBQSxNQUMxQixHQUFHLEtBQUssUUFBUSxnQkFBZ0IsS0FBSyxHQUFHLGNBQWM7QUFBQSxNQUN0RCxFQUFFLFNBQVMsS0FBSyxPQUFPLEVBQUU7QUFBQSxJQUFDO0FBQzVCLFlBQVEsSUFBSSxPQUFPO0FBQ25CLFFBQUksV0FBVyxRQUFRLE1BQU07QUFDM0IsV0FBSyxhQUFhO0FBQ2xCLFdBQUssUUFBUSxRQUFRLEtBQUs7QUFBQSxJQUM1QjtBQUNBLFdBQU8sUUFBUTtBQUFBLEVBQ2pCO0FBQUEsRUFDQSxNQUFNLGVBQWUsT0FBaUMsQ0FBQyxHQUFHO0FBQ3hELFVBQU0sU0FBUyxNQUFNLGNBQU07QUFBQSxNQUN6QixHQUFHLEtBQUssUUFBUSxnQkFBZ0IsS0FBSyxHQUFHO0FBQUEsTUFDeEMsRUFBRSxHQUFHLEtBQUssS0FBSyxHQUFHLEdBQUcsS0FBSztBQUFBLE1BQzFCLEVBQUUsU0FBUyxLQUFLLE9BQU8sRUFBRTtBQUFBLElBQUM7QUFDNUIsU0FBSyxhQUFhLE9BQU8sS0FBSztBQUFBLEVBQ2hDO0FBQUEsRUFDQSxNQUFNLGVBQWUsT0FBaUMsQ0FBQyxHQUFHO0FBQ3hELFFBQUksQ0FBQyxLQUFLO0FBQVk7QUFDdEIsVUFBTSxjQUFNO0FBQUEsTUFDVixHQUFHLEtBQUssUUFBUSxnQkFBZ0IsS0FBSyxHQUFHLGNBQWMsS0FBSztBQUFBLE1BQzNELEVBQUUsR0FBRyxLQUFLLEtBQUssR0FBRyxHQUFHLEtBQUs7QUFBQSxNQUMxQixFQUFFLFNBQVMsS0FBSyxPQUFPLEVBQUU7QUFBQSxJQUFDO0FBQUEsRUFDOUI7QUFBQSxFQUNBLE1BQU0saUJBQWlCO0FBQ3JCLFFBQUksQ0FBQyxLQUFLO0FBQVk7QUFDdEIsV0FBTyxNQUFNLGNBQU07QUFBQSxNQUNqQixHQUFHLEtBQUssUUFBUSxnQkFBZ0IsS0FBSyxHQUFHLGNBQWMsS0FBSztBQUFBLE1BQzNELEVBQUUsU0FBUyxLQUFLLE9BQU8sRUFBRTtBQUFBLElBQUM7QUFBQSxFQUM5QjtBQUFBLEVBQ0EsTUFBTSxTQUFTRixPQUFjO0FBQzNCLFFBQUksQ0FBQyxLQUFLO0FBQVk7QUFFdEIsVUFBTSxNQUFNLE1BQU0sY0FBTTtBQUFBLE1BQ3RCLEdBQUcsS0FBSyxRQUFRLGdCQUFnQixLQUFLLEdBQUcsY0FBYyxLQUFLLHlCQUF5QixTQUFTQSxLQUFJO0FBQUEsTUFDakcsRUFBRSxTQUFTLEtBQUssT0FBTyxFQUFFO0FBQUEsSUFBQztBQUU1QixVQUFNLFVBQVUsSUFBSTtBQUVwQixhQUFTLFFBQVEsS0FBSyxPQUFPO0FBQzNCLFVBQUksS0FBSyxhQUFhQSxTQUFRLEtBQUssaUJBQWlCQTtBQUNsRCxhQUFLLFVBQVU7QUFBQSxJQUNuQjtBQUVBLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxNQUFNLGNBQWM7QUFDbEIsUUFBSSxDQUFDLEtBQUs7QUFBWTtBQUN0QixXQUFPLE1BQU0sY0FBTTtBQUFBLE1BQ2pCLEdBQUcsS0FBSyxRQUFRLGdCQUFnQixLQUFLLEdBQUcsY0FBYyxLQUFLO0FBQUEsTUFDM0QsRUFBRSxTQUFTLEtBQUssT0FBTyxFQUFFO0FBQUEsSUFBQztBQUFBLEVBQzlCO0FBQ0Y7OztBNkN6aEJBLFdBQXNCOzs7QUNFZixJQUFNLG1CQUFzQztBQUFBLEVBQ2xELE9BQU87QUFBQSxFQUNQLFVBQVU7QUFBQSxFQUNWLFdBQVc7QUFBQSxFQUNYLGNBQWM7QUFBQSxFQUNkLE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFDUjtBQUVPLElBQU0seUJBQXlCO0FBRS9CLElBQU0sY0FBYztBQUNwQixJQUFNLGVBQWU7QUFDckIsSUFBTSxtQkFBbUI7QUFDekIsSUFBTSxlQUFlO0FBRXJCLElBQU0saUJBQWlCO0FBRXZCLElBQU0sY0FBYzs7O0FEbEJwQixJQUFNLFNBQU4sTUFBYTtBQUFBLEVBRWxCLFlBQVksVUFBMkI7QUFEdkMsa0JBQWlCO0FBRWYsU0FBSyxVQUFTLHFDQUFVLFdBQVUsS0FBSztBQUFBLEVBQ3pDO0FBQUEsRUFDQSxJQUFJLEtBQTRCO0FBQzlCLFdBQU8sYUFBYSxRQUFRLEtBQUssU0FBUyxHQUFHO0FBQUEsRUFDL0M7QUFBQSxFQUNBLElBQUksS0FBYSxPQUErQjtBQUM5QyxpQkFBYSxRQUFRLEtBQUssU0FBUyxLQUFLLEdBQUcsT0FBTztBQUFBLEVBQ3BEO0FBQUEsRUFDQSxNQUFNLEtBQWE7QUFDakIsaUJBQWEsV0FBVyxLQUFLLFNBQVMsR0FBRztBQUFBLEVBQzNDO0FBQUEsRUFDQSxZQUFZO0FBQ1YsYUFBUyxJQUFJLEdBQUcsSUFBSSxhQUFhLFFBQVEsS0FBSztBQUM1QyxZQUFNLE1BQU0sYUFBYSxJQUFJLENBQUM7QUFDOUIsVUFBSSwyQkFBSyxXQUFXLEtBQUs7QUFDdkIscUJBQWEsV0FBVyxHQUFHO0FBQUEsSUFDL0I7QUFBQSxFQUNGO0FBQ0Y7QUFFTyxJQUFNLGVBQU4sTUFBbUI7QUFBQSxFQVF4QixZQUFZLFVBQWtCLGFBQXFCLGFBQWE7QUFQaEUsZ0JBQWU7QUFDZixzQkFBcUI7QUFDckIsb0JBQXlCLE1BQU0sR0FBRyxLQUFLLHNCQUFzQjtBQUU3RCx1QkFBc0I7QUFDdEIsaUNBQWdDO0FBRzlCLFNBQUssV0FBVztBQUNoQixTQUFLLGFBQWE7QUFDbEIsUUFBSSxPQUFPLFlBQVk7QUFDckIsV0FBSyxPQUFZLFVBQUssS0FBSyxTQUFTLEdBQUcsS0FBSyxRQUFRO0FBQUE7QUFFcEQsV0FBSyxPQUFPLENBQUMsS0FBSyxTQUFTLEdBQUcsS0FBSyxRQUFRLEVBQUUsS0FBSyxHQUFHO0FBQUEsRUFDekQ7QUFBQSxFQUNBLGdCQUFnQjtBQUNkLFFBQUksT0FBTyxZQUFZO0FBQ3JCLFdBQUssT0FBWSxVQUFLLEtBQUssU0FBUyxHQUFHLEtBQUssUUFBUTtBQUFBO0FBRXBELFdBQUssT0FBTyxDQUFDLEtBQUssU0FBUyxHQUFHLEtBQUssUUFBUSxFQUFFLEtBQUssR0FBRztBQUFBLEVBQ3pEO0FBQUEsRUFDQSxVQUFVLE9BQWU7QUFDdkIsU0FBSyxjQUFjO0FBQUEsRUFDckI7QUFBQSxFQUNBLGFBQWEsVUFBb0M7QUFDL0MsU0FBSyxXQUFXO0FBQUEsRUFDbEI7QUFBQSxFQUNBLGVBQWUsWUFBb0I7QUFDakMsU0FBSyxhQUFhO0FBQUEsRUFDcEI7QUFBQSxFQUNBLFNBQVM7QUFDUCxRQUFJO0FBQ0YsVUFBSSxNQUFNLFFBQVEsTUFBTSxLQUFLLE1BQU0sRUFBRTtBQUFBLElBQ3ZDLFNBQVEsR0FBTjtBQUNBLGNBQVEsSUFBSSxtQkFBbUI7QUFBQSxJQUNqQztBQUFBLEVBQ0Y7QUFBQSxFQUNBLE1BQU0sSUFBSSxPQUFlO0FBQ3ZCLFFBQUk7QUFDRixZQUFNLElBQUksTUFBTSxRQUFRLE1BQU0sS0FBSyxNQUFNLEtBQUs7QUFBQSxJQUNoRCxTQUFRLEdBQU47QUFDQSxjQUFRLElBQUksd0JBQXdCO0FBQUEsSUFDdEM7QUFBQSxFQUNGO0FBQUEsRUFDQSxNQUFNLElBQUksT0FBZTtBQUN2QixRQUFJO0FBQ0YsWUFBTSxJQUFJLE1BQU0sUUFBUSxPQUFPLEtBQUssTUFBTSxLQUFLO0FBQUEsSUFDakQsU0FBUSxHQUFOO0FBQ0EsY0FBUSxJQUFJLHlCQUF5QjtBQUFBLElBQ3ZDO0FBQUEsRUFDRjtBQUFBLEVBQ0EsTUFBTSxNQUFNO0FBQ1YsUUFBSTtBQUNGLGFBQU8sTUFBTSxJQUFJLE1BQU0sUUFBUSxLQUFLLEtBQUssSUFBSTtBQUFBLElBQy9DLFNBQVMsS0FBUDtBQUNBLGNBQVEsSUFBSSw2QkFBNkIsSUFBSSxPQUFPO0FBQ3BELGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVNBLE1BQU0sbUJBQW1CLE9BQWUsT0FBZ0I7QUFDdEQsVUFBTSxPQUFPLE1BQU0sS0FBSyxJQUFJO0FBQzVCLFVBQU0sUUFBUSxLQUFLLFNBQVMsRUFBRSxNQUFNLElBQUk7QUFDeEMsVUFBTSxNQUFNLE1BQU07QUFDbEIsUUFBSSxRQUFRO0FBQUssYUFBTyxDQUFDO0FBQ3pCLFFBQUksQ0FBQztBQUFPLGNBQVE7QUFDcEIsUUFBSSxRQUFRO0FBQ1YsY0FBUSxNQUFNO0FBQ2hCLFFBQUksUUFBUTtBQUNWLGNBQVE7QUFDVixRQUFJLFFBQVEsU0FBUztBQUNuQixjQUFRO0FBQUE7QUFFUixjQUFRLFFBQVE7QUFDbEIsU0FBSyx3QkFBd0I7QUFFN0IsV0FBTyxNQUFNLE1BQU0sT0FBTyxLQUFLLEVBQUUsT0FBTyxVQUFRLENBQUMsQ0FBQyxJQUFJO0FBQUEsRUFDeEQ7QUFBQSxFQUNBLE1BQU0seUJBQXlCLFFBQWdCLFFBQWdCLEdBQUcsaUJBQWlCLE9BQU8sVUFBbUIsTUFBTTtBQUNqSCxVQUFNLE9BQU8sTUFBTSxLQUFLLElBQUk7QUFDNUIsVUFBTSxRQUFRLEtBQUssU0FBUyxFQUFFLE1BQU0sSUFBSSxFQUFFLFFBQVE7QUFDbEQsVUFBTSxNQUFNLE1BQU07QUFDbEIsVUFBTSxrQkFBa0IsQ0FBQztBQUN6QixhQUFTLFFBQVEsT0FBTztBQUN0QixVQUFJLEtBQUssU0FBUyxNQUFNLEdBQUc7QUFDekIsWUFBSTtBQUNGLDBCQUFnQixLQUFLLElBQUk7QUFDM0I7QUFBQSxNQUNGLE9BQU87QUFDTCx3QkFBZ0IsS0FBSyxJQUFJO0FBQUEsTUFDM0I7QUFFQSxVQUFJLFNBQVM7QUFDWDtBQUFBLElBQ0o7QUFDQSxTQUFLLHdCQUF3QjtBQUU3QixXQUFPLGdCQUFnQixPQUFPLFVBQVEsQ0FBQyxDQUFDLElBQUk7QUFBQSxFQUM5QztBQUNGO0FBRU8sSUFBTSxTQUFOLGNBQXFCLGFBQWE7QUFBQSxFQUN2QyxZQUFZLFVBQWtCLGFBQXFCLGFBQWE7QUFDOUQsVUFBTSxVQUFVLFVBQVU7QUFBQSxFQUM1QjtBQUFBLEVBQ0EsTUFBTSxjQUFjO0FBQ2xCLFFBQUksS0FBSyx3QkFBd0IsTUFBTSxLQUFLLGFBQWE7QUFDdkQsWUFBTSxRQUFRLE1BQU0sS0FBSztBQUN6QixZQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssbUJBQW1CLENBQUMsS0FBSyxHQUFHLEtBQUssSUFBSSxDQUFDO0FBQ2pFLFdBQUssd0JBQXdCO0FBQUEsSUFDL0I7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFNLElBQUksU0FBaUI7QUFDekIsVUFBTSxPQUFPLElBQUksS0FBSztBQUN0QixVQUFNLGNBQWM7QUFBQSxHQUFNLEtBQUssZUFBZSxFQUFFLFFBQVEsTUFBTSxHQUFHLE9BQVE7QUFDekUsVUFBTSxLQUFLLElBQUksV0FBVztBQUMxQixRQUFJLEtBQUs7QUFDUCxXQUFLLFNBQVMsV0FBVztBQUMzQixTQUFLO0FBQ0wsVUFBTSxLQUFLLFlBQVk7QUFBQSxFQUN6QjtBQUNGO0FBRU8sSUFBTSxVQUFOLGNBQXNCLGFBQWE7QUFBQSxFQUl4QyxZQUFZLFVBQWtCLGFBQXFCLGFBQWE7QUFDOUQsVUFBTSxVQUFVLFVBQVU7QUFKNUIsdUJBQXNCO0FBQ3RCLGlDQUFnQztBQUFBLEVBSWhDO0FBQUEsRUFDQSxNQUFNLGNBQWM7QUFDbEIsUUFBSSxLQUFLLHdCQUF3QixNQUFNLEtBQUssYUFBYTtBQUN2RCxZQUFNLFFBQVEsTUFBTSxLQUFLO0FBQ3pCLFlBQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxtQkFBbUIsQ0FBQyxLQUFLLEdBQUcsS0FBSyxJQUFJLENBQUM7QUFDakUsV0FBSyx3QkFBd0I7QUFBQSxJQUMvQjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE9BQU8sTUFBYztBQUNuQixVQUFNLENBQUMsTUFBTSxRQUFRRyxPQUFNLFFBQVEsSUFBSSxLQUFLLE1BQU0sR0FBSTtBQUN0RCxXQUFPO0FBQUEsTUFDTDtBQUFBLE1BQU07QUFBQSxNQUFRLE1BQUFBO0FBQUEsTUFBTTtBQUFBLElBQ3RCO0FBQUEsRUFDRjtBQUFBLEVBQ0EsTUFBTSxRQUFRO0FBQ1osVUFBTSxLQUFLLElBQUksRUFBRTtBQUNqQixTQUFLLHdCQUF3QjtBQUFBLEVBQy9CO0FBQUEsRUFDQSxNQUFNLHFCQUFxQixTQUFpQixPQUFlO0FBQ3pELFVBQU0sZUFBZSxNQUFNLEtBQUssbUJBQW1CLElBQUk7QUFFdkQsZUFBVyxRQUFRLGFBQWEsUUFBUSxHQUFHO0FBQ3pDLFlBQU0sRUFBRSxRQUFRLE1BQUFBLE1BQUssSUFBSSxLQUFLLE9BQU8sSUFBSTtBQUN6QyxVQUFHLE9BQU8sV0FBVyxlQUFlO0FBQUcsZUFBTztBQUM5QyxVQUFJLFVBQVUsWUFBWSxXQUFXLFVBQVVBLFNBQVE7QUFDckQsZUFBTztBQUFBLElBQ1g7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBQ0EsTUFBTSxXQUFXLFFBQStCQSxPQUFjLFVBQW1CO0FBQy9FLFVBQU0sT0FBTyxJQUFJLEtBQUs7QUFDdEIsUUFBSyxNQUFNLEtBQUsscUJBQXFCLFFBQVFBLEtBQUk7QUFBSTtBQUNyRCxVQUFNLGNBQWM7QUFBQSxHQUFNLEtBQUssZUFBZSxNQUFPLFVBQVdBLFNBQVMsWUFBWTtBQUNyRixVQUFNLEtBQUssSUFBSSxXQUFXO0FBQzFCLFFBQUksS0FBSztBQUNQLFdBQUssU0FBUyxXQUFXO0FBQzNCLFNBQUs7QUFDTCxVQUFNLEtBQUssWUFBWTtBQUFBLEVBQ3pCO0FBQ0Y7OztBRTlNTyxJQUFNLFFBQU4sTUFBWTtBQUFBLEVBRWxCLGNBQWM7QUFEZCxtQkFBa0MsQ0FBQztBQUFBLEVBQ25CO0FBQUEsRUFDaEIsT0FBTyxRQUE0QjtBQUNsQyxTQUFLLFFBQVEsS0FBSyxNQUFNO0FBQ3hCLFFBQUksS0FBSyxRQUFRLFVBQVU7QUFDMUIsV0FBSyxjQUFjO0FBQUEsRUFDckI7QUFBQSxFQUNBLE1BQU0sZ0JBQWdCO0FBQ3JCLFFBQUksS0FBSyxRQUFRLFVBQVUsR0FBRztBQUM3QixZQUFNLFNBQVMsS0FBSyxRQUFRLENBQUM7QUFDN0IsVUFBSTtBQUNILGNBQU0sT0FBTztBQUNkLFdBQUssUUFBUSxNQUFNO0FBQ25CLFdBQUssY0FBYztBQUFBLElBQ3BCO0FBQUEsRUFDRDtBQUNEOzs7QUNoQkEsSUFBQUMsbUJBQXVEO0FBRWhELElBQU0sb0JBQU4sY0FBZ0Msa0NBQWlCO0FBQUEsRUFHdkQsWUFBWUMsTUFBVSxRQUF1QjtBQUM1QyxVQUFNQSxNQUFLLE1BQU07QUFDakIsU0FBSyxTQUFTO0FBQUEsRUFDZjtBQUFBLEVBRUEsVUFBZ0I7QUFDZixVQUFNLEVBQUUsWUFBWSxJQUFJO0FBQ3hCLGdCQUFZLE1BQU07QUFDbEIsVUFBTSxNQUFNLE1BQU0sSUFBSSx5QkFBUSxXQUFXO0FBQ3pDLFFBQUksRUFBRSxRQUFRLE9BQU8sRUFDbkIsUUFBUSxzQkFBc0IsRUFDOUIsUUFBUSxVQUFLO0FBakJqQjtBQWlCb0Isa0JBQ2YsZUFBZSxtQkFBbUIsRUFDbEMsU0FBUyxJQUFJLFNBQU8sWUFBTyxJQUFJLGFBQWEsTUFBeEIsbUJBQTJCLFdBQVUsQ0FBQyxDQUFDLEVBQzNELFNBQVMsT0FBTyxVQUFVO0FBQzFCLGVBQU8sSUFBSSxlQUFlLEtBQUs7QUFDL0IsY0FBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLE1BQ2hDLENBQUM7QUFBQSxLQUFDO0FBQ0osUUFBSSxFQUFFLFFBQVEsT0FBTyxFQUNuQixRQUFRLDRCQUE0QixFQUNwQyxRQUFRLFVBQVEsS0FDZixlQUFlLGtCQUFrQixFQUNqQyxTQUFTLEtBQUssT0FBTyxTQUFTLEtBQUssRUFDbkMsU0FBUyxPQUFPLFVBQVU7QUFDMUIsV0FBSyxPQUFPLFNBQVMsUUFBUTtBQUM3QixZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDaEMsQ0FBQyxDQUFDO0FBQ0osUUFBSSxFQUFFLFFBQVEsVUFBVSxFQUN0QixRQUFRLHNDQUFzQyxFQUM5QyxRQUFRLFVBQVEsS0FDZixlQUFlLHFCQUFxQixFQUNwQyxTQUFTLEtBQUssT0FBTyxTQUFTLFFBQVEsRUFDdEMsU0FBUyxPQUFPLFVBQVU7QUFDMUIsV0FBSyxPQUFPLFNBQVMsV0FBVztBQUNoQyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDaEMsQ0FBQyxDQUFDO0FBQ0osUUFBSSxFQUFFLFFBQVEsU0FBUyxFQUNyQixRQUFRLDZCQUE2QixFQUNyQyxRQUFRLFVBQVEsS0FDZixlQUFlLG9CQUFvQixFQUNuQyxTQUFTLEtBQUssT0FBTyxTQUFTLFlBQVksRUFDMUMsU0FBUyxPQUFPLFVBQVU7QUFDMUIsV0FBSyxPQUFPLFNBQVMsZUFBZTtBQUNwQyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDaEMsQ0FBQyxDQUFDO0FBQ0osUUFBSSxFQUFFLFFBQVEsTUFBTSxFQUNsQixRQUFRLGdDQUFnQyxFQUN4QyxRQUFRLFVBQVEsS0FDZixlQUFlLHVCQUF1QixFQUN0QyxTQUFTLEtBQUssT0FBTyxTQUFTLFNBQVMsRUFDdkMsU0FBUyxPQUFPLFVBQVU7QUFDMUIsV0FBSyxPQUFPLFNBQVMsWUFBWTtBQUNqQyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDaEMsQ0FBQyxDQUFDO0FBQ0osUUFBSSxFQUFFLFFBQVEsYUFBYSxFQUN6QixRQUFRLGlDQUFpQyxFQUN6QyxRQUFRLFVBQVEsS0FDZixlQUFlLHdCQUF3QixFQUN2QyxTQUFTLEtBQUssT0FBTyxTQUFTLE1BQU0sRUFDcEMsU0FBUyxPQUFPLFVBQVU7QUFDMUIsV0FBSyxPQUFPLFNBQVMsU0FBUztBQUM5QixZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDaEMsQ0FBQyxDQUFDO0FBQ0osUUFBSSxFQUFFLFFBQVEsV0FBVyxFQUN2QixRQUFRLHFEQUFxRCxFQUM3RCxVQUFVLFFBQU0sR0FBRyxTQUFTLEtBQUssT0FBTyxTQUFTLElBQUksRUFDcEQsU0FBUyxPQUFPLFVBQVU7QUFDMUIsV0FBSyxPQUFPLFNBQVMsT0FBTztBQUM1QixZQUFNLEtBQUssT0FBTyxhQUFhO0FBQy9CLFVBQUksd0JBQU8sY0FBYyxRQUFRLE9BQU8sT0FBTztBQUFBLElBQ2hELENBQUMsQ0FBQztBQUNKLFFBQUksRUFBRSxRQUFRLGdCQUFnQixFQUM1QixRQUFRLGdEQUFnRCxFQUN4RCxVQUFVLFFBQU0sR0FBRyxTQUFTLEtBQUssT0FBTyxTQUFTLEtBQUssRUFDckQsU0FBUyxPQUFPLFVBQVU7QUFDMUIsV0FBSyxPQUFPLFNBQVMsUUFBUTtBQUM3QixZQUFNLEtBQUssT0FBTyxhQUFhO0FBQy9CLFVBQUksd0JBQU8sZUFBZSxRQUFRLE9BQU8sT0FBTztBQUFBLElBQ2pELENBQUMsQ0FBQztBQUNKLFFBQUksRUFBRSxRQUFRLGVBQWUsRUFDM0IsUUFBUSxrQ0FBa0MsRUFDMUMsVUFBVSxRQUFNLEdBQUcsU0FBUyxLQUFLLE9BQU8sU0FBUyxLQUFLLEVBQ3JELFNBQVMsT0FBTyxVQUFVO0FBQzFCLFdBQUssT0FBTyxTQUFTLFFBQVE7QUFDN0IsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUMvQixVQUFJLHdCQUFPLGtCQUFrQixRQUFRLE9BQU8sT0FBTztBQUFBLElBQ3BELENBQUMsQ0FBQztBQUNKLFFBQUksRUFBRSxRQUFRLGlCQUFpQixFQUM3QixRQUFRLGtDQUFrQyxFQUMxQyxVQUFVLFFBQU0sR0FBRyxjQUFjLFFBQVEsRUFBRSxRQUFRLFlBQVksRUFBRSxRQUFRLE1BQU07QUFDL0UsV0FBSyxPQUFPLGFBQWE7QUFDekIsVUFBSSx3QkFBTyxrQkFBa0I7QUFBQSxJQUM5QixDQUFDLENBQUM7QUFBQSxFQUNKO0FBQ0Q7OztBQ25HQSxJQUFBQyxtQkFBd0M7QUFLakMsSUFBTSxjQUFOLGNBQTBCLDBCQUFTO0FBQUEsRUFHeEMsWUFBWSxNQUFxQjtBQUMvQixVQUFNLElBQUk7QUFFWixnQkFBZTtBQUFBLEVBRGY7QUFBQSxFQUVBLGNBQXNCO0FBQ3BCLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxpQkFBeUI7QUFDdkIsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLE1BQU0sWUFBWSxTQUFzQixNQUFvQjtBQUMxRCxVQUFNLE9BQU8sTUFBTSxLQUFLLG1CQUFtQixJQUFJO0FBQy9DLFlBQVEsTUFBTTtBQUNkLFNBQUssUUFBUSxFQUFFLFFBQVEsVUFBUTtBQUMzQixjQUFRLFNBQVMsUUFBUTtBQUFBLFFBQ3ZCLE1BQU0sS0FBSyxRQUFRLFFBQVEsS0FBSztBQUFBLE1BQ3BDLENBQUM7QUFBQSxJQUNILENBQUM7QUFBQSxFQUNIO0FBQUEsRUFDQSxjQUFjLFFBQWlCLE1BQWMsVUFBc0I7QUFDakUsVUFBTSxTQUFTLE9BQU8sU0FBUyxVQUFVO0FBQUEsTUFDdkMsTUFBTTtBQUFBLElBQ1IsQ0FBQztBQUNELFdBQU8sTUFBTSxTQUFTO0FBQ3RCLFdBQU8saUJBQWlCLFNBQVMsTUFBTTtBQUNyQyxlQUFTO0FBQUEsSUFDWCxDQUFDO0FBQUEsRUFFSDtBQUFBLEVBQ0EsTUFBTSxTQUFTO0FBQ2IsVUFBTSxZQUFZLEtBQUssWUFBWSxTQUFTLENBQUM7QUFDN0MsY0FBVSxNQUFNO0FBQ2hCLGNBQVUsU0FBUyxNQUFNLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUN0RCxjQUFVLFNBQVMsTUFBTSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFFNUQsU0FBSyxhQUFhLFVBQVUsU0FBUyxLQUFLO0FBQzFDLGNBQVUsU0FBUyxNQUFNLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUV4RCxTQUFLLFlBQVksVUFBVSxTQUFTLEtBQUs7QUFDekMsS0FBQyxLQUFLLFlBQVksS0FBSyxTQUFTLEVBQUUsUUFBUSxVQUFRO0FBQ2hELFdBQUssTUFBTSxXQUFXO0FBQ3RCLFdBQUssTUFBTSxhQUFhO0FBQ3hCLFdBQUssTUFBTSxZQUFZO0FBQ3ZCLFdBQUssTUFBTSxZQUFZO0FBQ3ZCLFdBQUssTUFBTSxVQUFVO0FBQ3JCLFdBQUssTUFBTSxnQkFBZ0I7QUFBQSxJQUM3QixDQUFDO0FBQUEsRUFDSDtBQUFBLEVBQ0EsTUFBTSxTQUF3QjtBQUM1QixVQUFNLEtBQUssWUFBWSxLQUFLLFlBQVksa0JBQWtCO0FBQzFELFVBQU0sS0FBSyxZQUFZLEtBQUssV0FBVyxTQUFTO0FBQUEsRUFDbEQ7QUFBQSxFQUNBLE1BQU0sU0FBd0I7QUFDNUIsVUFBTSxLQUFLLE9BQU87QUFDbEIsVUFBTSxLQUFLLFlBQVksS0FBSyxZQUFZLGtCQUFrQjtBQUMxRCxVQUFNLEtBQUssWUFBWSxLQUFLLFdBQVcsU0FBUztBQUFBLEVBQ2xEO0FBQ0Y7OztBQzNETyxJQUFPLHdCQUF3QixZQUFZO0FBQ2hELFFBQU0sRUFBRSxVQUFVLElBQUk7QUFFdEIsTUFBSSxPQUE2QjtBQUNqQyxRQUFNLFNBQVMsVUFBVSxnQkFBZ0IsWUFBWTtBQUNyRCxNQUFJLE9BQU8sU0FBUyxHQUFHO0FBQ3JCLFdBQU8sT0FBTyxDQUFDO0FBQUEsRUFDakIsT0FBTztBQUNMLFdBQU8sVUFBVSxhQUFhLEtBQUs7QUFDbkMsVUFBTSxLQUFLLGFBQWEsRUFBRSxNQUFNLGNBQWMsUUFBUSxNQUFNLENBQUM7QUFBQSxFQUMvRDtBQUNBLFlBQVUsYUFBYSxNQUFNO0FBQzNCLFFBQUk7QUFDRixNQUFDLEtBQUssS0FBcUIsT0FBTztBQUFBLEVBQ3RDLENBQUM7QUFDRCxxQkFBbUIsYUFBYSxNQUFNO0FBQ3BDLFFBQUk7QUFDRixNQUFDLEtBQUssS0FBcUIsT0FBTztBQUFBLEVBQ3RDLENBQUM7QUFDSDs7O0FDeEJPLElBQU0sYUFBYTtBQUFBLEVBQ3hCLElBQUk7QUFBQSxFQUNKLE1BQU07QUFBQSxFQUNOLFVBQVUsWUFBWTtBQUNwQiwwQkFBc0I7QUFBQSxFQUN4QjtBQUNGOzs7QUNQQSxJQUFBQyxtQkFBNkI7QUFFdEIsSUFBTSxtQkFBTixjQUErQiw4QkFBb0I7QUFBQSxFQU16RCxZQUFZLFFBQW9DO0FBQy9DLFVBQU0sR0FBRztBQUNULFNBQUssU0FBUyxFQUFFLEdBQUcsT0FBTztBQUMxQixTQUFLLGVBQWUsS0FBSyxPQUFPLGVBQWUsRUFBRTtBQUFBLEVBQ2xEO0FBQUEsRUFFQSxPQUF3QjtBQUN2QixVQUFNLEtBQUs7QUFFWCxRQUFJLEtBQUssT0FBTyxnQkFBZ0IsUUFBVztBQUMxQyxXQUFLLFFBQVEsUUFBUSxLQUFLLE9BQU87QUFDakMsV0FBSyxRQUFRLGNBQWMsSUFBSSxNQUFNLE9BQU8sQ0FBQztBQUFBLElBQzlDO0FBRUEsV0FBTyxJQUFJLFFBQVEsQ0FBQyxZQUFZO0FBQy9CLFdBQUssVUFBVTtBQUFBLElBQ2hCLENBQUM7QUFBQSxFQUNGO0FBQUEsRUFDQSxpQkFBaUIsT0FBZSxLQUF1QztBQUN0RSxRQUFJLEtBQUssU0FBUztBQUNqQixVQUFJO0FBQ0osVUFBSSxLQUFLLE9BQU8sY0FBYyxVQUFVO0FBQUssY0FBTTtBQUFBLGVBQzFDLFVBQVU7QUFBTyxjQUFNO0FBQUE7QUFDM0IsY0FBTTtBQUNYLFdBQUssUUFBUSxHQUFHO0FBQUEsSUFDakI7QUFDQSxVQUFNLGlCQUFpQixPQUFPLEdBQUc7QUFBQSxFQUNsQztBQUFBLEVBQ0EsVUFBVTtBQUNULFFBQUksS0FBSztBQUFTLFdBQUssUUFBUSxNQUFTO0FBQUEsRUFDekM7QUFBQSxFQUNBLGVBQWUsT0FBeUI7QUFDdkMsUUFBSSxLQUFLLE9BQU8sZUFBZTtBQUM5QixhQUFPLEtBQUssT0FBTyxXQUFXLENBQUM7QUFBQSxJQUNoQyxXQUFXLEtBQUssT0FBTyxZQUFZO0FBQ2xDLGFBQU8sQ0FBQyxNQUFNLFNBQVMsSUFBSSxRQUFRLEtBQUssR0FBRyxLQUFLLE9BQU8sV0FBVyxDQUFDLENBQUM7QUFBQSxJQUNyRSxPQUFPO0FBQ04sYUFBTyxDQUFDLE1BQU0sU0FBUyxJQUFJLFFBQVEsT0FBTyxHQUFHLEtBQUssT0FBTyxXQUFXLENBQUMsQ0FBQztBQUFBLElBQ3ZFO0FBQUEsRUFDRDtBQUFBLEVBQ0EsaUJBQWlCLE9BQWUsSUFBdUI7QUFDdEQsT0FBRyxRQUFRLEtBQUs7QUFBQSxFQUNqQjtBQUFBLEVBQ0EsbUJBQW1CLE1BQWMsS0FBaUM7QUFBQSxFQUFFO0FBQ3JFOzs7QUNuREEsSUFBQUMsbUJBQXVCOzs7QUNGaEIsSUFBTUMsdUJBQXNCLENBQUMsV0FBbUI7QUFDdEQsTUFBSSxlQUFlLEtBQUssTUFBTTtBQUM5QixNQUFJLFFBQVEsSUFBSSxXQUFXLGFBQWEsTUFBTTtBQUM5QyxXQUFTLElBQUksR0FBRyxJQUFJLGFBQWEsUUFBUSxLQUFLO0FBQzdDLFVBQU0sQ0FBQyxJQUFJLGFBQWEsV0FBVyxDQUFDO0FBQUEsRUFDckM7QUFDQSxTQUFPLE1BQU07QUFDZDtBQUNPLElBQU0sdUJBQXVCLENBQUMsVUFBMkMsVUFBVTtBQUFBLEVBQ3pGLG1CQUFtQixDQUFDLFVBQXNCLFlBQW9CO0FBQzdELFVBQU0sb0JBQW9CLFdBQVcsVUFBVSxPQUFPO0FBQ3RELFdBQU8scUJBQXFCLGlCQUFpQjtBQUFBLEVBQzlDO0FBQUEsRUFDQSw4QkFBOEIsQ0FBQyxVQUFzQixZQUFvQjtBQUN4RSxRQUFHO0FBQ0Ysb0JBQWMsT0FBTztBQUN0QixXQUFPLHFCQUFxQixFQUFFLGtCQUFrQixVQUFVLE9BQU87QUFBQSxFQUNsRTtBQUNEOzs7QURWTyxJQUFNLG9CQUFvQixZQUFZO0FBQzNDLFFBQU0sS0FBSyxJQUFJLHdCQUFPLGNBQWMsQ0FBQztBQUNyQyxRQUFNLFNBQVMsQ0FBQyxHQUFHLENBQUM7QUFDcEIsUUFBTSxjQUFjLE9BQU8sUUFBZ0I7QUFDekMsUUFBSSxJQUFJLFNBQVMsTUFBTSxLQUFLLElBQUksU0FBUyxjQUFjO0FBQ3JEO0FBQ0YsVUFBTSxVQUFVLE1BQU0sSUFBSSxNQUFNLFFBQVEsS0FBSyxHQUFHO0FBQ2hELGVBQVdDLFNBQVEsUUFBUSxPQUFPO0FBQ2hDLFNBQUcsV0FBV0EsS0FBSTtBQUNsQixhQUFPLENBQUMsS0FBSztBQUNiLFlBQU0sT0FBTyxPQUFPQSxPQUFNLENBQUMsR0FBRyxLQUFLO0FBQUEsSUFDckM7QUFDQSxlQUFXQSxTQUFRLFFBQVEsU0FBUztBQUNsQyxTQUFHLFdBQVdBLEtBQUk7QUFDbEIsYUFBTyxDQUFDLEtBQUs7QUFDYixZQUFNLFlBQVlBLEtBQUk7QUFBQSxJQUN4QjtBQUFBLEVBQ0Y7QUFDQSxRQUFNLFlBQVksR0FBRztBQUNyQixRQUFNLE9BQU8saUJBQWlCO0FBQzlCLEtBQUcsV0FBVyxZQUFZLE9BQU8sQ0FBQyxjQUFjLE9BQU8sQ0FBQyxXQUFXO0FBQ25FLGFBQVcsTUFBTSxHQUFHLEtBQUssR0FBRyxNQUFPLENBQUM7QUFDdEM7QUFFTyxJQUFNLHdCQUF3QixZQUFZO0FBQy9DLFFBQU0saUNBQWlDLE1BQU0sbUJBQW1CLHlCQUF5QixlQUFlO0FBQ3hHLFFBQU0sZUFBK0Ysb0JBQUksSUFBSTtBQUM3RyxNQUFJLDhCQUE2RyxDQUFDO0FBQ2xILGlDQUErQixRQUFRLEVBQUU7QUFBQSxJQUFRLFVBQVE7QUFDdkQsWUFBTSxnQkFBZ0IsbUJBQW1CLE9BQU8sSUFBSTtBQUNwRCxVQUFJLENBQUMsQ0FBQyxjQUFjO0FBQ2xCLHFCQUFhLE9BQU8sY0FBYyxRQUFRO0FBRTVDLFVBQUksYUFBYSxJQUFJLGNBQWMsSUFBSSxLQUFLLGNBQWMsVUFBVTtBQUNsRSxxQkFBYSxPQUFPLGNBQWMsSUFBSTtBQUV4QyxVQUFJLGFBQWEsSUFBSSxjQUFjLElBQUksS0FBSyxjQUFjLFVBQVUsVUFBVTtBQUM1RSxxQkFBYSxJQUFJLGNBQWMsTUFBTSxFQUFFLEdBQUcsZUFBZSxRQUFRLFNBQVMsQ0FBQztBQUMzRTtBQUFBLE1BQ0Y7QUFFQSxtQkFBYSxJQUFJLGNBQWMsTUFBTSxhQUFhO0FBQ2xELG9DQUE4QixNQUFNLEtBQUssYUFBYSxRQUFRLENBQUM7QUFBQSxJQUNqRTtBQUFBLEVBQ0E7QUFFQSw4QkFBNEIsUUFBUSxDQUFDLFNBQWM7QUFDakQsVUFBTSxTQUFTLEtBQUssQ0FBQztBQUNyQixRQUFJLE9BQU8sVUFBVTtBQUNuQixnQkFBVSxPQUFPLFlBQVk7QUFDM0IsWUFBSTtBQUNGLGdCQUFNLE9BQU87QUFBQSxZQUFPLE9BQU87QUFBQSxZQUN6QixFQUFFLGdCQUFnQixrQkFBa0IsT0FBTyxXQUFXLE9BQU8sT0FBTztBQUFBLFlBQ2xFO0FBQUEsVUFBSztBQUNULG9CQUFVLElBQUksa0JBQWtCLE9BQU8sT0FBTztBQUFBLFFBQ2hELFNBQ00sR0FBTjtBQUNFLG9CQUFVLElBQUksd0JBQXdCLE9BQU8sT0FBTztBQUFBLFFBQ3REO0FBQUEsTUFDRixDQUFDO0FBQ0gsUUFBSSxPQUFPLFVBQVU7QUFDbkIsZ0JBQVUsT0FBTyxZQUFZO0FBQzNCLFlBQUk7QUFFRixnQkFBTSxPQUFPO0FBQUEsWUFBTyxPQUFPO0FBQUEsWUFDekIsRUFBRSxnQkFBZ0IsbUJBQW1CLE9BQU8sV0FBVyxPQUFPLE9BQU87QUFBQSxZQUFHO0FBQUEsVUFBSztBQUMvRSxvQkFBVSxJQUFJLG1CQUFtQixPQUFPLE9BQU87QUFBQSxRQUVqRCxTQUFRLEdBQU47QUFDQSxvQkFBVSxJQUFJLHlCQUF5QixPQUFPLE9BQU87QUFBQSxRQUN2RDtBQUFBLE1BQ0YsQ0FBQztBQUNILFFBQUksT0FBTyxVQUFVO0FBQ25CLGdCQUFVLE9BQU8sWUFBWTtBQUMzQixZQUFJO0FBQ0YsZ0JBQU0sT0FBTztBQUFBLFlBQU8sT0FBTztBQUFBLFlBQ3pCLEVBQUUsZ0JBQWdCLGtCQUFrQixPQUFPLFdBQVcsT0FBTyxPQUFPO0FBQUEsWUFBRztBQUFBLFVBQUs7QUFDOUUsb0JBQVUsSUFBSSxrQkFBa0IsT0FBTyxPQUFPO0FBQUEsUUFDaEQsU0FBUSxHQUFOO0FBQ0Esb0JBQVUsSUFBSSx3QkFBd0IsT0FBTyxPQUFPO0FBQUEsUUFDdEQ7QUFBQSxNQUNGLENBQUM7QUFDSCxRQUFJLE9BQU8sVUFBVTtBQUNuQixnQkFBVSxPQUFPLFlBQVk7QUFDM0IsWUFBSTtBQUNGLGdCQUFNLE9BQU87QUFBQSxZQUFPLE9BQU87QUFBQSxZQUN6QixFQUFFLGdCQUFnQixxQkFBcUIsT0FBTyxpQkFBaUIsT0FBTyxXQUFXLE9BQU8sT0FBTztBQUFBLFlBQUc7QUFBQSxVQUFLO0FBQ3pHLGdCQUFNLE9BQU87QUFBQSxZQUFPLE9BQU87QUFBQSxZQUN6QixFQUFFLGdCQUFnQixxQkFBcUIsT0FBTyxpQkFBaUIsT0FBTyxXQUFXLE9BQU8sT0FBTztBQUFBLFlBQUc7QUFBQSxVQUFLO0FBQ3pHLG9CQUFVLElBQUksa0JBQWtCLE9BQU8saUJBQWlCLE9BQU8sT0FBTztBQUFBLFFBQ3hFLFNBQVEsR0FBTjtBQUNBLG9CQUFVLElBQUksd0JBQXdCLE9BQU8saUJBQWlCLE9BQU8sT0FBTztBQUFBLFFBQzlFO0FBQUEsTUFDRixDQUFDO0FBQUEsRUFDTCxDQUFDO0FBQ0QsUUFBTSxPQUFPLGlCQUFpQjtBQUM5QixxQkFBbUIsV0FBVyx3QkFBd0IsR0FBRyw0QkFBNEIsZ0JBQWdCO0FBQ3JHLHFCQUFtQixTQUFTO0FBQzlCO0FBRU8sSUFBTSx3QkFBd0IsWUFBWTtBQUMvQyxRQUFNLGlCQUFpQixNQUFNLElBQUksaUJBQWlCO0FBQUEsSUFDaEQsYUFBYTtBQUFBLElBQ2IsU0FBUyxDQUFDLE9BQU8sSUFBSTtBQUFBLEVBQ3ZCLENBQUMsRUFBRSxLQUFLO0FBRVIsUUFBTSxrQkFBa0IsT0FBTyxhQUFxQixPQUF3QjtBQUMxRSxVQUFNQyxRQUFPLE1BQU0sT0FBTyxlQUFlLFlBQVksR0FBRyxHQUFHLEtBQUs7QUFDaEUsVUFBTSxVQUFVQSxNQUFLLE9BQU8sVUFBUSxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksVUFBUSxLQUFLLENBQUMsQ0FBQztBQUNoRSxRQUFJLFFBQVEsVUFBVTtBQUNwQixhQUFPO0FBQ1QsVUFBTSxZQUFZLE1BQU0sSUFBSSxpQkFBaUI7QUFBQSxNQUMzQyxhQUFhO0FBQUEsTUFDYixTQUFTO0FBQUEsSUFDWCxDQUFDLEVBQUUsS0FBSztBQUVSLFFBQUksQ0FBQztBQUNILGFBQU87QUFDVCxRQUFJLGFBQWE7QUFDZixhQUFPLGdCQUFnQixFQUFFO0FBQzNCLFdBQU8sZ0JBQWdCLFNBQVM7QUFBQSxFQUNsQztBQUVBLFFBQU1ELFFBQU8sTUFBTSxnQkFBZ0IsRUFBRTtBQUNyQyxRQUFNLE9BQU8sTUFBTSxPQUFPLGVBQWVBLEtBQUk7QUFDN0MsT0FBSyxRQUFRLFVBQVE7QUFDbkIsUUFBSSxLQUFLLENBQUM7QUFDUixVQUFJLE1BQU0sUUFBUSxNQUFNLEtBQUssQ0FBQyxDQUFDO0FBQUEsRUFDbkMsQ0FBQztBQUNELFFBQU0sY0FBYyxJQUFJLHdCQUFPLFVBQVUsQ0FBQztBQUMxQyxhQUFXLFFBQVEsTUFBTTtBQUN2QixRQUFJLGtCQUFrQixTQUFTLEtBQUssQ0FBQyxFQUFFLFdBQVcsV0FBVztBQUFHO0FBQ2hFLFFBQUksS0FBSyxDQUFDO0FBQUc7QUFDYixVQUFNLE1BQU0sTUFBTSxPQUFPLEtBQUssS0FBSyxDQUFDLENBQUM7QUFDckMsUUFBSSxPQUFPO0FBQU07QUFDakIsZ0JBQVksV0FBVyxXQUFXLEtBQUssQ0FBQyxDQUFDO0FBQ3pDLFFBQUksTUFBTSxRQUFRLFlBQVksS0FBSyxDQUFDLEdBQUdFLHFCQUFvQixJQUFJLEtBQUssT0FBTyxDQUFDO0FBQUEsRUFDOUU7QUFDQSxRQUFNLE9BQU8saUJBQWlCO0FBRTlCLGNBQVksS0FBSztBQUNqQixNQUFJLHdCQUFPLE1BQU07QUFDbkI7QUFFTyxJQUFNLHlCQUF5QixZQUFZO0FBQ2hELFFBQU0sS0FBSyxJQUFJLHdCQUFPLGVBQWUsQ0FBQztBQUN0QyxRQUFNLE1BQU0sTUFBTSxPQUFPLFlBQVk7QUFDckMsUUFBTSxjQUFjLElBQUksSUFBSSxTQUFTLENBQUM7QUFDdEMsTUFBSSxDQUFDO0FBQ0gsV0FBTyxNQUFNLE9BQU8saUJBQWlCO0FBRXZDLE1BQUksWUFBWSxNQUFNLE9BQU8sSUFBSSxnQkFBZ0I7QUFDL0MsV0FBTyxHQUFHLFdBQVcsMEJBQTBCO0FBQ2pELE1BQUkseUJBQXlCO0FBQzdCLFlBQVUsT0FBTyxZQUFZO0FBQzNCLGVBQVcsVUFBVSxLQUFLO0FBQ3hCLFlBQU1DLE9BQU0sTUFBTSxPQUFPLFVBQVUsT0FBTyxFQUFFO0FBQzVDLE1BQUFBLFFBQUEsZ0JBQUFBLEtBQUssS0FBSyxRQUFRLE9BQU8sU0FBYztBQUNyQztBQUNBLGtCQUFVLE9BQU8sWUFBWTtBQUMzQixjQUFJO0FBQ0YsZ0JBQUksS0FBSyxZQUFhLENBQUMsS0FBSyxnQkFBZ0IsQ0FBQyxLQUFLLFlBQVksQ0FBQyxLQUFLO0FBQ2xFLG9CQUFNLE9BQU8sZ0JBQWdCLEtBQUssUUFBUTtBQUM1QyxnQkFBSSxLQUFLO0FBQ1Asb0JBQU0sSUFBSSxNQUFNLFFBQVEsT0FBTyxLQUFLLFVBQVUsS0FBSyxRQUFRO0FBQzdELGdCQUFJLEtBQUs7QUFDUCxvQkFBTSxJQUFJLE1BQU0sUUFBUSxPQUFPLEtBQUssUUFBUTtBQUFBLFVBQ2hELFNBQVEsR0FBTjtBQUNBLG9CQUFRLElBQUksaUJBQWlCO0FBQUEsVUFDL0I7QUFBQSxRQUNGLENBQUM7QUFBQSxNQUNIO0FBQUEsSUFDRjtBQUFBLEVBQ0YsQ0FBQztBQUNELFFBQU0sT0FBTyxpQkFBaUI7QUFDOUIsWUFBVSxPQUFPLE1BQU0sbUJBQW1CLFdBQVcsd0JBQXdCLEdBQUcsZ0NBQWdDLENBQUM7QUFFakgsS0FBRyxXQUFXLDRDQUE0QyxPQUFPLElBQUksZ0JBQWdCLENBQUM7QUFDeEY7QUFHTyxJQUFNLHFCQUFxQjtBQUFBLEVBQ2hDLElBQUk7QUFBQSxFQUNKLE1BQU07QUFBQSxFQUNOLFVBQVUsWUFBWTtBQUNwQiwwQkFBc0I7QUFBQSxFQUN4QjtBQUNGO0FBQ08sSUFBTSxnQkFBZ0I7QUFBQSxFQUMzQixJQUFJO0FBQUEsRUFDSixNQUFNO0FBQUEsRUFDTixVQUFVLFlBQVk7QUFDcEIsMkJBQXVCO0FBQUEsRUFDekI7QUFDRjtBQUVPLElBQU0sa0JBQWtCO0FBQUEsRUFDN0IsSUFBSTtBQUFBLEVBQ0osTUFBTTtBQUFBLEVBQ04sVUFBVSxZQUFZO0FBQ3BCLHNCQUFrQjtBQUFBLEVBQ3BCO0FBQ0Y7QUFFTyxJQUFNLHNCQUFzQjtBQUFBLEVBQ2pDLElBQUk7QUFBQSxFQUNKLE1BQU07QUFBQSxFQUNOLFVBQVUsWUFBWTtBQUNwQiwwQkFBc0I7QUFBQSxFQUN4QjtBQUNGOzs7QUV2TkEsSUFBTSxXQUFXO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDRjtBQUNBLElBQU8saUJBQVE7OztBQ1RmLElBQUFDLG1CQUFxRDtBQUc5QyxJQUFNLHNCQUFzQixDQUFDLE1BQVksU0FBd0I7QUFDdEUsT0FBSyxRQUFRLENBQUMsU0FBUztBQUNyQixTQUNHLFNBQVMsbUJBQW1CLEVBQzVCLFFBQVEsTUFBTSxFQUNkLFFBQVEsWUFBWTtBQUNuQixZQUFNLEtBQUssSUFBSSx3QkFBTyxjQUFjLENBQUM7QUFDckMsZ0JBQVUsT0FBTyxZQUFZO0FBQzNCLFlBQUssS0FBaUIsVUFBVTtBQUM5QixnQkFBTSxjQUFjLE9BQU8sUUFBZ0I7QUFDekMsa0JBQU0sVUFBVSxNQUFNLElBQUksTUFBTSxRQUFRLEtBQUssR0FBRztBQUNoRCx1QkFBV0MsU0FBUSxRQUFRLE9BQU87QUFDaEMsaUJBQUcsV0FBV0EsS0FBSTtBQUNsQixvQkFBTSxPQUFPLE9BQU9BLEtBQUk7QUFBQSxZQUMxQjtBQUNBLHVCQUFXQSxTQUFRLFFBQVEsU0FBUztBQUNsQyxpQkFBRyxXQUFXQSxLQUFJO0FBQ2xCLG9CQUFNLFlBQVlBLEtBQUk7QUFBQSxZQUN4QjtBQUFBLFVBQ0Y7QUFDQSxnQkFBTSxZQUFZLEtBQUssSUFBSTtBQUFBLFFBQzdCLE9BQU87QUFDTCxnQkFBTSxPQUFPLE9BQU8sS0FBSyxJQUFJO0FBQUEsUUFDL0I7QUFDQSxXQUFHLFdBQVcsTUFBTTtBQUFBLE1BQ3RCLENBQUM7QUFDRCxpQkFBVyxNQUFNLEdBQUcsS0FBSyxHQUFHLE1BQU8sQ0FBQztBQUFBLElBQ3RDLENBQUM7QUFBQSxFQUNMLENBQUM7QUFDSDtBQUVPLElBQU0sc0JBQXNCLENBQUMsTUFBWSxTQUF3QjtBQUN0RSxPQUFLLFFBQVEsQ0FBQyxTQUFTO0FBQ3JCLFNBQ0csU0FBUyxtQkFBbUIsRUFDNUIsUUFBUSxXQUFXLEVBQ25CLFFBQVEsWUFBWTtBQUNuQixZQUFNLEtBQUssSUFBSSx3QkFBTyxjQUFjLENBQUM7QUFDckMsZ0JBQVUsT0FBTyxZQUFZO0FBQzNCLFlBQUssS0FBaUIsVUFBVTtBQUM5QixnQkFBTSxPQUFPLE1BQU0sT0FBTyxlQUFlLEtBQUssSUFBSTtBQUNsRCxlQUFLLFFBQVEsQ0FBQUMsVUFBUTtBQUNuQixnQkFBSUEsTUFBSyxDQUFDO0FBQ1Isa0JBQUksTUFBTSxRQUFRLE1BQU1BLE1BQUssQ0FBQyxDQUFDO0FBQUEsVUFDbkMsQ0FBQztBQUNELHFCQUFXQyxTQUFRLE1BQU07QUFDdkIsZ0JBQUlBLE1BQUssQ0FBQztBQUFHO0FBQ2Isa0JBQU0sTUFBTSxNQUFNLE9BQU8sS0FBS0EsTUFBSyxDQUFDLENBQUM7QUFDckMsZ0JBQUksT0FBTztBQUFNO0FBQ2pCLGdCQUFJLE1BQU0sUUFBUSxZQUFZQSxNQUFLLENBQUMsR0FBR0MscUJBQW9CLElBQUksS0FBSyxPQUFPLENBQUM7QUFBQSxVQUM5RTtBQUFBLFFBQ0YsT0FBTztBQUNMLGdCQUFNLE1BQU0sTUFBTSxPQUFPLEtBQUssS0FBSyxJQUFJO0FBQ3ZDLGNBQUksT0FBTztBQUFNO0FBQ2pCLGNBQUksTUFBTSxRQUFRLFlBQVksS0FBSyxNQUFNQSxxQkFBb0IsSUFBSSxLQUFLLE9BQU8sQ0FBQztBQUFBLFFBQ2hGO0FBQ0EsV0FBRyxXQUFXLE1BQU07QUFBQSxNQUN0QixDQUFDO0FBQ0QsaUJBQVcsTUFBTSxHQUFHLEtBQUssR0FBRyxNQUFPLENBQUM7QUFBQSxJQUV0QyxDQUFDO0FBQUEsRUFDTCxDQUFDO0FBQ0g7QUFFTyxJQUFNLHdCQUF3QixDQUFDLE1BQVksU0FBd0I7QUFDeEUsT0FBSyxRQUFRLENBQUMsU0FBUztBQUNyQixTQUNHLFNBQVMscUJBQXFCLEVBQzlCLFFBQVEsU0FBUyxFQUNqQixRQUFRLFlBQVk7QUFDbkIsWUFBTSxLQUFLLElBQUksd0JBQU8sZUFBZSxDQUFDO0FBQ3RDLGdCQUFVLE9BQU8sWUFBWTtBQUMzQixZQUFLLEtBQWEsVUFBVTtBQUMxQixnQkFBTSxjQUFjLE9BQU8sUUFBZ0I7QUFDekMsa0JBQU0sVUFBVSxNQUFNLElBQUksTUFBTSxRQUFRLEtBQUssR0FBRztBQUNoRCx1QkFBV0gsU0FBUSxRQUFRLE9BQU87QUFDaEMsaUJBQUcsV0FBV0EsS0FBSTtBQUNsQixvQkFBTSxPQUFPLE9BQU9BLEtBQUk7QUFBQSxZQUMxQjtBQUNBLHVCQUFXQSxTQUFRLFFBQVEsU0FBUztBQUNsQyxpQkFBRyxXQUFXQSxLQUFJO0FBQ2xCLG9CQUFNLFlBQVlBLEtBQUk7QUFBQSxZQUN4QjtBQUFBLFVBQ0Y7QUFDQSxnQkFBTSxZQUFZLEtBQUssSUFBSTtBQUFBLFFBQzdCLE9BQU87QUFDTCxnQkFBTSxPQUFPLE9BQU8sS0FBSyxJQUFJO0FBQUEsUUFDL0I7QUFDQSxXQUFHLFdBQVcsTUFBTTtBQUFBLE1BQ3RCLENBQUM7QUFDRCxpQkFBVyxNQUFNLEdBQUcsS0FBSyxHQUFHLE1BQU8sQ0FBQztBQUFBLElBQ3RDLENBQUM7QUFBQSxFQUNMLENBQUM7QUFDSDs7O0F6RGpGTyxJQUFNLFNBQVMsSUFBSSxVQUFVO0FBQzdCLElBQU0sU0FBUyxJQUFJLE9BQU87QUFDMUIsSUFBTSxZQUFZLElBQUksTUFBTTtBQUU1QixJQUFNLFlBQVksSUFBSSxPQUFPLFdBQVc7QUFDeEMsSUFBTSxxQkFBcUIsSUFBSSxRQUFRLFlBQVk7QUFFMUQsSUFBcUJJLGlCQUFyQixjQUEyQyx3QkFBTztBQUFBLEVBQWxEO0FBQUE7QUFFQywyQkFBa0IsTUFBcUI7QUFDdEMsYUFBTztBQUFBLFFBQ04sS0FBSztBQUFBLFFBQ0wsT0FBTyxPQUFPLElBQUksZ0JBQWdCLEtBQUs7QUFBQSxRQUN2QyxTQUFTLEtBQUssU0FBUztBQUFBLFFBQ3ZCLFlBQVksS0FBSyxTQUFTO0FBQUEsUUFDMUIsT0FBTyxLQUFLLFNBQVM7QUFBQSxRQUNyQixNQUFNLEtBQUssU0FBUztBQUFBLFFBQ3BCLFFBQVEsS0FBSyxTQUFTO0FBQUEsUUFDdEIsZUFBZSxLQUFLLFNBQVM7QUFBQSxNQUM5QjtBQUFBLElBQ0Q7QUFBQTtBQUFBLEVBRUEsTUFBTSxTQUFTO0FBQ2QsY0FBVSxlQUFlLEtBQUssSUFBSSxNQUFNLFNBQVM7QUFDakQsdUJBQW1CLGVBQWUsS0FBSyxJQUFJLE1BQU0sU0FBUztBQUUxRCxVQUFNLEtBQUssYUFBYTtBQUN4QixVQUFNLGFBQWEsS0FBSyxpQkFBaUI7QUFFekMsU0FBSztBQUFBLE1BQ0o7QUFBQSxNQUNBLENBQUMsU0FBUyxJQUFJLFlBQVksSUFBSTtBQUFBLElBQy9CO0FBRUEsZUFBVyxXQUFXLGdCQUFVO0FBQy9CLFdBQUssV0FBVyxPQUFPO0FBQUEsSUFDeEI7QUFFQSxTQUFLLGNBQWMsUUFBUSxzQkFBc0IsT0FBTyxRQUFvQjtBQUMzRSw0QkFBc0I7QUFBQSxJQUN2QixDQUFDLEVBQUUsU0FBUyx3QkFBd0I7QUFFcEMsU0FBSyxjQUFjLGtCQUFrQixTQUFTLE9BQU8sUUFBb0I7QUFDeEUsNkJBQXVCO0FBQUEsSUFDeEIsQ0FBQyxFQUFFLFNBQVMsd0JBQXdCO0FBR3BDLFNBQUs7QUFBQSxNQUNKLEtBQUssSUFBSSxVQUFVLEdBQUcsYUFBYSxDQUFDLE1BQU0sU0FBUztBQUNsRCw0QkFBb0IsTUFBTSxJQUFJO0FBQzlCLDRCQUFvQixNQUFNLElBQUk7QUFDOUIsOEJBQXNCLE1BQU0sSUFBSTtBQUFBLE1BQ2pDLENBQUM7QUFBQSxJQUNGO0FBRUEsU0FBSztBQUFBLE1BQ0osS0FBSyxJQUFJLFVBQVUsR0FBRyxhQUFhLE9BQU8sU0FBUztBQUNsRCxZQUFJLENBQUMsS0FBSyxTQUFTO0FBQU07QUFDekIsWUFBSSxFQUFDLDZCQUFNO0FBQU07QUFDakIsa0JBQVUsT0FBTyxZQUFZO0FBQzVCLHFCQUFXLFFBQVEsWUFBWTtBQUMvQixnQkFBTSxPQUFPLGdCQUFnQixLQUFLLE1BQU0sS0FBSyxNQUFNLElBQUk7QUFDdkQscUJBQVcsUUFBUSxXQUFXO0FBQUEsUUFDL0IsQ0FBQztBQUFBLE1BQ0YsQ0FBQztBQUFBLElBQ0Y7QUFFQSxRQUFJLGtCQUFrQixxQkFBcUI7QUFFM0MsZUFBVyxNQUFNO0FBQ2hCLFdBQUs7QUFBQSxRQUNKLEtBQUssSUFBSSxNQUFNLEdBQUcsVUFBVSxPQUFPLFNBQVM7QUFDM0MsZ0JBQU0sbUJBQW1CLFdBQVcsVUFBVSxLQUFLLElBQUk7QUFDdkQsY0FBSSxLQUFLLFNBQVM7QUFDakIsOEJBQWtCLGdCQUFnQjtBQUFBLGNBQ2pDO0FBQUEsY0FDQSx5QkFBeUI7QUFBQSxZQUMxQjtBQUFBLFFBQ0YsQ0FBQztBQUFBLE1BQ0Y7QUFDQSxXQUFLO0FBQUEsUUFDSixLQUFLLElBQUksTUFBTSxHQUFHLFVBQVUsT0FBTyxTQUFTO0FBQzNDLGdCQUFNLG1CQUFtQixXQUFXLFVBQVUsS0FBSyxJQUFJO0FBQ3ZELGNBQUksS0FBSyxTQUFTO0FBQ2pCLDhCQUFrQixnQkFBZ0I7QUFBQSxjQUNqQztBQUFBLGNBQ0EseUJBQXlCO0FBQUEsWUFDMUI7QUFBQSxRQUNGLENBQUM7QUFBQSxNQUNGO0FBQ0EsV0FBSztBQUFBLFFBQ0osS0FBSyxJQUFJLE1BQU0sR0FBRyxVQUFVLE9BQU8sU0FBUztBQUMzQyxnQkFBTSxtQkFBbUIsV0FBVyxVQUFVLEtBQUssSUFBSTtBQUN2RCxjQUFJLEtBQUssU0FBUztBQUNqQiw4QkFBa0IsZ0JBQWdCO0FBQUEsY0FDakM7QUFBQSxjQUNBLHlCQUF5QjtBQUFBLFlBQzFCO0FBQUEsUUFDRixDQUFDO0FBQUEsTUFDRjtBQUNBLFdBQUs7QUFBQSxRQUNKLEtBQUssSUFBSSxNQUFNLEdBQUcsVUFBVSxPQUFPLE1BQU0sYUFBYTtBQUNyRCxnQkFBTSxtQkFBbUIsV0FBVyxVQUFVLEtBQUssTUFBTSxRQUFRO0FBQ2pFLGVBQUssSUFBSSxNQUFNLFFBQVEsTUFBTSxLQUFLLElBQUksRUFBRSxRQUFRLEtBQUssSUFBSTtBQUN6RCxlQUFLLElBQUksTUFBTSxRQUFRLE1BQU0sS0FBSyxJQUFJLEVBQUUsV0FBVztBQUNuRCxjQUFJLEtBQUssU0FBUztBQUNqQiw4QkFBa0IsZ0JBQWdCO0FBQUEsY0FDakM7QUFBQSxjQUNBLHlCQUF5QjtBQUFBLFlBQzFCO0FBQUEsUUFDRixDQUFDO0FBQUEsTUFDRjtBQUFBLElBQ0QsR0FBRyxNQUFPLENBQUM7QUFFWCxlQUFXLE1BQU07QUFDaEIsNEJBQXNCO0FBRXRCLFVBQUksS0FBSyxTQUFTO0FBQ2pCLCtCQUF1QjtBQUFBLElBQ3pCLEdBQUcsR0FBSTtBQUVQLFNBQUssY0FBYyxJQUFJLGtCQUFrQixLQUFLLEtBQUssSUFBSSxDQUFDO0FBQUEsRUFDekQ7QUFBQSxFQUNBLE1BQU0sZUFBZTtBQUNwQixTQUFLLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsTUFBTSxLQUFLLFNBQVMsQ0FBQztBQUN6RSxXQUFPLFNBQVMsc0JBQXNCLEtBQUssU0FBUyxlQUFlLEtBQUssU0FBUztBQUNqRixVQUFNLGtCQUFrQixLQUFLLGdCQUFnQjtBQUM3QyxXQUFPLFdBQVcsZUFBZTtBQUFBLEVBQ2xDO0FBQUEsRUFDQSxNQUFNLGVBQWU7QUFDcEIsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQ2pDLFdBQU8sU0FBUyxzQkFBc0IsS0FBSyxTQUFTLGVBQWUsS0FBSyxTQUFTO0FBQ2pGLFVBQU0sa0JBQWtCLEtBQUssZ0JBQWdCO0FBQzdDLFdBQU8sV0FBVyxlQUFlO0FBQUEsRUFDbEM7QUFDRDsiLAogICJuYW1lcyI6IFsiU3luY1Nub3dmbGFrZSIsICJpbXBvcnRfb2JzaWRpYW4iLCAicHJvdG90eXBlIiwgImRlc2NyaXB0b3JzIiwgImZpbHRlciIsICJoYXNPd25Qcm9wZXJ0eSIsICJmaWx0ZXIiLCAicGF0aCIsICJwcm90b3R5cGUiLCAidG9TdHJpbmciLCAiZW5jb2RlIiwgInBhdGgiLCAicGF0aCIsICJpc0Zvcm1EYXRhIiwgImlzRmlsZUxpc3QiLCAidHJhbnNpdGlvbmFsIiwgImZpbHRlciIsICJzZWxmIiwgInByb3RvdHlwZSIsICJ2YWxpZGF0ZVN0YXR1cyIsICJwYXRoIiwgInRyYW5zaXRpb25hbCIsICJtZXJnZSIsICJ2YWxpZGF0b3JzIiwgInRyYW5zaXRpb25hbCIsICJBeGlvcyIsICJBeGlvc0Vycm9yIiwgIkNhbmNlbGVkRXJyb3IiLCAiaXNDYW5jZWwiLCAiQ2FuY2VsVG9rZW4iLCAiVkVSU0lPTiIsICJhbGwiLCAiaXNBeGlvc0Vycm9yIiwgInNwcmVhZCIsICJ0b0Zvcm1EYXRhIiwgIkF4aW9zSGVhZGVycyIsICJIdHRwU3RhdHVzQ29kZSIsICJtZXJnZUNvbmZpZyIsICJwYXRoIiwgImUiLCAiZ2l0bGFiIiwgInBhdGgiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJiYXNlNjRUb0FycmF5QnVmZmVyIiwgInBhdGgiLCAidHJlZSIsICJiYXNlNjRUb0FycmF5QnVmZmVyIiwgInJlcyIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGF0aCIsICJpdGVtIiwgImZpbGUiLCAiYmFzZTY0VG9BcnJheUJ1ZmZlciIsICJTeW5jU25vd2ZsYWtlIl0KfQo=
