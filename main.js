/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SyncSnowflake2,
  gitlab: () => gitlab,
  local_changes_logs: () => local_changes_logs,
  pocket: () => pocket,
  req_queue: () => req_queue,
  sync_logs: () => sync_logs
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/gitlab_api.ts
var import_obsidian = require("obsidian");

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2)
    return key;
  return path2.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index) {
    let name = path2[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path2.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path2, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path2) && cookie.push("path=" + path2);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders_default.from(config.headers).normalize();
    let { responseType, withXSRFToken } = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils_default.isFormData(requestData)) {
      if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitional_default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform_default.hasStandardBrowserEnv) {
      withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(fullPath)) {
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.6.2";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// src/gitlab_api.ts
var urlslash = (...text) => {
  const path2 = text.join("/");
  const end = path2.slice(path2.lastIndexOf("/"));
  const start = path2.slice(0, path2.lastIndexOf("/")).replace(/\./gm, "%2E");
  return (start + end).replace(/\//gm, "%2F");
};
function base64ToArrayBuffer(base64) {
  var binaryString = atob(base64);
  var bytes = new Uint8Array(binaryString.length);
  for (var i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}
var exurl = (_url, _params_no = 0) => ({
  base: (url) => exurl(_url + url, _params_no),
  add: (key, value) => exurl(_url + (_params_no == 0 ? "?" : "&") + `${key}=${value}`, _params_no + 1),
  params: (key, value) => exurl(_url.replace(`:${key}`, value), _params_no),
  value: _url
});
var GitLabAPI = class {
  constructor() {
    this.id = () => urlslash(this.options.project, this.options.repository);
    this.header = () => {
      return {
        "PRIVATE-TOKEN": this.options.token,
        "Content-Type": "application/json"
      };
    };
    this.url = {
      commits: () => exurl(`${this.options.api}/projects/${this.id()}/repository/commits`),
      branches: () => exurl(`${this.options.api}/projects/${this.id()}/repository/branches`),
      files: () => exurl(`${this.options.api}/projects/${this.id()}/repository/files`)
    };
  }
  setoptions(options) {
    this.options = options;
  }
  async get_local_file_content(path2) {
    const array_buffer = await app.vault.adapter.readBinary(path2);
    return (0, import_obsidian.arrayBufferToBase64)(array_buffer);
  }
  async save_local_file(remote_path, local_path, create_if_not_exist = false) {
    if (!local_path)
      local_path = remote_path;
    const remote_file = await this.read(remote_path);
    if (!remote_file) {
      if (create_if_not_exist)
        this.create(remote_path);
    } else
      app.vault.adapter.writeBinary(local_path, base64ToArrayBuffer(remote_file.data.content));
  }
  async get_branches() {
    const url = this.url.branches().add("pt", "null");
    const res = [];
    try {
      await this.pagination(1, url, async (res_item) => {
        res.push(...res_item.data.map((item) => item.name));
      });
    } catch (e) {
      new import_obsidian.Notice(`Cannot get branches
${url.value}`);
    }
    return res;
  }
  async create_branch(branch, parent_branch) {
    const url = this.url.branches().add("branch", urlslash(branch)).add("ref", urlslash(parent_branch)).value;
    const res = [];
    try {
      await axios_default.post(url, null, {
        headers: this.header()
      });
    } catch (e) {
      new import_obsidian.Notice(`Error while creating branch
${url}`);
    }
    return res;
  }
  async save_last_commit() {
    const url = this.url.commits().add("with_stats", "true").add("all", "true").add("per_page", "3").value;
    const res = await axios_default.get(url, {
      headers: this.header()
    });
    const last_commit = res.data.pop();
    pocket.set("last_commit_id", last_commit.id);
    pocket.set("last_commit_date", last_commit.committed_date);
  }
  convertToGitlabCommit(data) {
    return {
      ...data,
      created_at: new Date(data.created_at),
      authored_date: new Date(data.authored_date),
      committed_date: new Date(data.committed_date)
    };
  }
  async get_commit(sha) {
    const url = this.url.commits().base("/" + sha);
    try {
      const res = await axios_default.get(url.value, {
        headers: this.header()
      });
      return this.convertToGitlabCommit(res.data);
    } catch (e) {
      new import_obsidian.Notice(`Cannot get commit
${url.value}`);
    }
    return null;
  }
  async get_commits() {
    const url = this.url.commits().add("with_stats", "true").add("all", "true").add("ref_name", this.options.branch).add("since", pocket.get("last_commit_date") || new Date().toISOString());
    const res = [];
    try {
      await this.pagination(1, url, (res_item) => {
        res.push(...res_item.data);
      });
    } catch (e) {
      new import_obsidian.Notice(`Cannot get commits
${url.value}`);
    }
    return res;
  }
  async get_all_commits() {
    const url = this.url.commits().add("with_stats", "true").add("ref_name", this.options.branch).add("all", "true");
    const res = [];
    try {
      await this.pagination(1, url, (res_item) => {
        res.push(...res_item.data);
      });
    } catch (e) {
      new import_obsidian.Notice(`Cannot get commits
${url.value}`);
    }
    return res;
  }
  async get_meta_data_file(path2) {
    const url = this.url.files().base(`/${urlslash(path2)}`).add("ref", this.options.branch);
    try {
      return await axios_default.head(url.value, {
        headers: this.header()
      });
    } catch (e) {
      new import_obsidian.Notice(`Cannot get file header
${url.value}`);
    }
    return null;
  }
  async pagination(start_page, url, callback, per_page = 100) {
    var _a;
    const page_url = url.add("per_page", per_page.toString()).add("page", start_page.toString());
    const res = await axios_default.get(page_url.value, { headers: this.header() });
    if (((_a = res.data) == null ? void 0 : _a.length) == 0)
      return;
    await callback(res);
    await this.pagination(start_page + 1, url, callback, per_page);
  }
  async blame(path2) {
    const url = this.url.files().base(`/${urlslash(path2)}/blame`).add("ref", this.options.branch).value;
    try {
      const res = await axios_default.get(url, {
        headers: this.header()
      });
      return res.data;
    } catch (e) {
    }
  }
  async get_diffs(commit_id) {
    const url = this.url.commits().base(`/${commit_id}/diff`).value;
    let res = null;
    try {
      res = await axios_default.get(url, { headers: this.header() });
    } catch (e) {
      new import_obsidian.Notice(`Cannot get diff from commit ${commit_id}`);
    }
    return res;
  }
  async create(path2, commit = {}, notifications = true, update_if_exist = true) {
    const file_content = await this.get_local_file_content(path2);
    const data = {
      branch: commit.branch || this.options.branch,
      encoding: commit.encoding || "base64",
      author_email: commit.author_email || this.options.email,
      author_name: commit.author_name || this.options.nick,
      commit_message: commit.commit_message || "created file",
      content: file_content
    };
    const file_url = `${this.options.api}/projects/${this.id()}/repository/files/${urlslash(path2)}?ref=${data.branch}`;
    let res = null;
    try {
      res = await axios_default.post(
        file_url,
        data,
        {
          headers: this.header()
        }
      );
      sync_logs.log(`creating file "${path2}"`);
    } catch (e) {
      sync_logs.log(`FAIL: creating file "${path2}"`);
      if (update_if_exist) {
        if (notifications && this.options.notifications)
          new import_obsidian.Notice("Cannot create file\nTrying update file");
      }
      try {
        await this.modify(path2, commit, notifications, false);
      } catch (e2) {
        if (this.options.notifications)
          new import_obsidian.Notice("Cannot update file");
      }
    }
    return res;
  }
  async modify(path2, commit = {}, notifications = true, create_if_not_exist = true) {
    const file_content = await this.get_local_file_content(path2);
    const data = {
      branch: commit.branch || this.options.branch,
      encoding: commit.encoding || "base64",
      author_email: commit.author_email || this.options.email,
      author_name: commit.author_name || this.options.nick,
      commit_message: commit.commit_message || "modified file",
      content: file_content
    };
    const file_url = `${this.options.api}/projects/${this.id()}/repository/files/${urlslash(path2)}?ref=${data.branch}`;
    let res = null;
    try {
      res = await axios_default.put(
        file_url,
        data,
        {
          headers: this.header()
        }
      );
      sync_logs.log(`modifying file "${path2}"`);
    } catch (e) {
      sync_logs.log(`FAIL: modifying file "${path2}"`);
      if (create_if_not_exist) {
        if (notifications && this.options.notifications)
          new import_obsidian.Notice("Cannot update file\nTrying create file");
      }
      try {
        await this.create(path2, commit, notifications, false);
      } catch (e2) {
        if (this.options.notifications)
          new import_obsidian.Notice("Cannot create file");
      }
    }
    return res;
  }
  async delete(path2, commit = {}, notifications = true) {
    const data = {
      branch: commit.branch || this.options.branch,
      author_email: commit.author_email || this.options.email,
      author_name: commit.author_name || this.options.nick,
      commit_message: commit.commit_message || "deleted file"
    };
    const file_url = `${this.options.api}/projects/${this.id()}/repository/files/${urlslash(path2)}?ref=${data.branch}`;
    let res = null;
    try {
      res = await axios_default({
        method: "DELETE",
        url: file_url,
        data,
        headers: this.header()
      });
      sync_logs.log(`deleting file "${path2}"`);
    } catch (e) {
      sync_logs.log(`FAIL: deleting file "${path2}"`);
      if (notifications && this.options.notifications)
        new import_obsidian.Notice("Cannot delete file");
    }
    return res;
  }
  async rename(path2, old_path, commit = {}, notifications = true) {
    try {
      await this.create(path2, commit, notifications);
      await this.delete(old_path, commit, notifications);
      sync_logs.log(`renaming file "${old_path}" -> "${path2}"`);
    } catch (e) {
      sync_logs.log(`FAIL: renaming file "${old_path}" -> "${path2}"`);
    }
  }
  async read(path2, branch = this.options.branch) {
    const file_url = `${this.options.api}/projects/${this.id()}/repository/files/${urlslash(path2)}?ref=${branch}`;
    let res = null;
    try {
      res = await axios_default.get(
        file_url,
        {
          headers: this.header()
        }
      );
      sync_logs.log(`reading file "${path2}"`);
    } catch (e) {
      sync_logs.log(`FAIL: reading file "${path2}"`);
      if (this.options.notifications)
        new import_obsidian.Notice("Cannot read file");
    }
    return res;
  }
  async read_repo_tree(path2 = "", depth = 0, depth_limit = -1, notifications = true) {
    const url = exurl(`${this.options.api}/projects/${this.id()}/repository/tree`).add("path", urlslash(path2)).add("ref", this.options.branch).add("recursive", "true");
    const tree = [];
    const pages = [];
    await this.pagination(1, url, (res) => {
      pages.push(...res.data);
    });
    for (const item of pages) {
      tree.push([item.id, item.path, item.type == "tree"]);
      if (this.options.notifications && notifications && item.type == "tree")
        new import_obsidian.Notice(`Fetching: "${item.path}"`);
    }
    return tree;
  }
  snippet(title, description = "", visibility = "private") {
    const snippet = new GitLabAPISnippet(this);
    snippet.metadata({ title, description, visibility });
    return snippet;
  }
};
var GitLabAPISnippet = class extends GitLabAPI {
  constructor(gitlab2) {
    super();
    this.sync = false;
    this.files = [];
    this.setoptions(gitlab2.options);
  }
  body() {
    return {
      title: this.title,
      description: this.description,
      visibility: this.visibility,
      files: []
    };
  }
  metadata(snippet) {
    this.title = snippet.title;
    this.description = snippet.description;
    this.visibility = snippet.visibility;
  }
  async add_files(...files) {
    for (const file of files) {
      file.action = file.action || "create";
      this.files.push(file);
    }
    if (this.sync) {
      if (this.snippet_id)
        await this.update_snippet({ files });
      else
        await this.create_snippet({ files });
    }
  }
  async update_files(...files) {
    for (const file of files) {
      file.action = file.action || "update";
      if (!!file.previous_path)
        file.action = "move";
      for (let index in this.files) {
        const item = this.files[index];
        if (file.file_path == item.file_path || file.previous_path == item.file_path)
          this.files[index] = file;
      }
    }
    if (this.sync)
      await this.update_snippet({ files });
  }
  async remove_files(...files) {
    for (const file of files) {
      file.action = "delete";
      if (!file.file_path)
        continue;
      file.content = "";
      file.previous_path = "";
      for (let index = 0; index < this.files.length; index++) {
        const item = this.files[index];
        if (file.file_path == item.file_path || file.previous_path == item.file_path)
          this.files.splice(index, 1);
      }
    }
    if (this.sync)
      await this.update_snippet({ files });
  }
  async from_id(id) {
    const snippet = await axios_default.get(
      `${this.options.api}/projects/${this.id()}/snippets/${id}`,
      { headers: this.header() }
    );
    console.log(snippet);
    if (snippet && snippet.data) {
      this.snippet_id = id;
      this.title = snippet.data.title;
    }
    return snippet.data;
  }
  async create_snippet(body = {}) {
    const create = await axios_default.post(
      `${this.options.api}/projects/${this.id()}/snippets`,
      { ...this.body(), ...body },
      { headers: this.header() }
    );
    this.snippet_id = create.data.id;
  }
  async update_snippet(body = {}) {
    if (!this.snippet_id)
      return;
    await axios_default.put(
      `${this.options.api}/projects/${this.id()}/snippets/${this.snippet_id}`,
      { ...this.body(), ...body },
      { headers: this.header() }
    );
  }
  async delete_snippet() {
    if (!this.snippet_id)
      return;
    return await axios_default.delete(
      `${this.options.api}/projects/${this.id()}/snippets/${this.snippet_id}`,
      { headers: this.header() }
    );
  }
  async get_file(path2) {
    if (!this.snippet_id)
      return;
    const res = await axios_default.get(
      `${this.options.api}/projects/${this.id()}/snippets/${this.snippet_id}/files/main/${urlslash(path2)}/raw`,
      { headers: this.header() }
    );
    const content = res.data;
    for (let file of this.files) {
      if (file.file_path == path2 || file.previous_path == path2)
        file.content = content;
    }
    return content;
  }
  async get_snippet() {
    if (!this.snippet_id)
      return;
    return await axios_default.get(
      `${this.options.api}/projects/${this.id()}/snippets/${this.snippet_id}/raw`,
      { headers: this.header() }
    );
  }
};

// src/storage.ts
var path = __toESM(require("path"));

// src/static.ts
var DEFAULT_SETTINGS = {
  token: "*****",
  username: "",
  repo_name: "",
  project_name: "",
  email: "",
  auto: false,
  fetch: false,
  branch: "master",
  notif: true
};
var LOGGER_FILE = "logger.log";
var HISTORY_FILE = "history.log";
var POCKET_TOKEN_KEY = "gitlabtoken";
var HISTORY_VIEW = "history";
var GITLAB_API_URL = "https://gitlab.com/api/v4";
var PLUGIN_NAME = "obsidian-snowflake";

// src/storage.ts
var Pocket = class {
  constructor(settings) {
    this.prefix = "snowflake_obsidian";
    this.prefix = (settings == null ? void 0 : settings.prefix) || this.prefix;
  }
  get(key) {
    return localStorage.getItem(this.prefix + key);
  }
  set(key, value) {
    localStorage.setItem(this.prefix + key, `${value}`);
  }
  clear(key) {
    localStorage.removeItem(this.prefix + key);
  }
  clear_all() {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key == null ? void 0 : key.startsWith(this.prefix))
        localStorage.removeItem(key);
    }
  }
};
var FileMetaData = class {
  constructor(filename, config_dir = ".obsidian") {
    this.path = "";
    this.config_dir = ".obsidian";
    this.ext_path = () => `${this.config_dir}/plugins/${PLUGIN_NAME}`;
    this.lines_limit = 500;
    this.current_lines_pointer = 0;
    this.filename = filename;
    this.config_dir = config_dir;
    if (typeof process === "object")
      this.path = path.join(this.ext_path(), this.filename);
    else
      this.path = [this.ext_path(), this.filename].join("/");
  }
  set_main_path() {
    if (typeof process === "object")
      this.path = path.join(this.ext_path(), this.filename);
    else
      this.path = [this.ext_path(), this.filename].join("/");
  }
  set_limit(limit) {
    this.lines_limit = limit;
  }
  set_callback(callback) {
    this.callback = callback;
  }
  set_config_dir(config_dir) {
    this.config_dir = config_dir;
  }
  create() {
    try {
      app.vault.adapter.write(this.path, "");
    } catch (e) {
      console.log("Error: Write File");
    }
  }
  async set(value) {
    try {
      await app.vault.adapter.write(this.path, value);
    } catch (e) {
      console.log("Error: Write File Sync");
    }
  }
  async add(value) {
    try {
      await app.vault.adapter.append(this.path, value);
    } catch (e) {
      console.log("Error: Append File Sync");
    }
  }
  async get() {
    try {
      return await app.vault.adapter.read(this.path);
    } catch (err) {
      console.log("Error: Read File Sync - " + err.message);
      return "";
    }
  }
  /**
     *  returns `count` of lines from `start` value.
     * `start` could be also less then `0`, then `count` will be get by the end of the file
     * 
     * @param start 
     * @param count 
     * @returns 
  */
  async get_lines_by_index(start, count) {
    const file = await this.get();
    const lines = file.toString().split("\n");
    const len = lines.length;
    if (start > len)
      return [];
    if (!count)
      count = len;
    if (start < 0)
      start = len + start;
    if (start < 0)
      start = 0;
    if (start + count >= len)
      count = len;
    else
      count = start + count;
    this.current_lines_pointer = len;
    return lines.slice(start, count).filter((item) => !!item);
  }
  async get_lines_from_to_phrase(phrase, count = 1, contain_phrase = false, reverse = true) {
    const file = await this.get();
    const lines = file.toString().split("\n").reverse();
    const len = lines.length;
    const lines_to_return = [];
    for (let line of lines) {
      if (line.contains(phrase)) {
        if (contain_phrase)
          lines_to_return.push(line);
        count--;
      } else {
        lines_to_return.push(line);
      }
      if (count == 0)
        break;
    }
    this.current_lines_pointer = len;
    return lines_to_return.filter((item) => !!item);
  }
};
var Logger = class extends FileMetaData {
  constructor(filename, config_dir = ".obsidian") {
    super(filename, config_dir);
  }
  async check_limit() {
    if (this.current_lines_pointer > 0.9 * this.lines_limit) {
      const start = 0.1 * this.lines_limit;
      await this.set((await this.get_lines_by_index(-start)).join("\n"));
      this.current_lines_pointer = start;
    }
  }
  async log(message) {
    const date = new Date();
    const fullmessage = `
[${date.toLocaleString().replace(", ", "|")}]>	${message}`;
    await this.add(fullmessage);
    if (this.callback)
      this.callback(fullmessage);
    this.current_lines_pointer++;
    await this.check_limit();
  }
};
var History = class extends FileMetaData {
  constructor(filename, config_dir = ".obsidian") {
    super(filename, config_dir);
    this.lines_limit = 2e3;
    this.current_lines_pointer = 0;
  }
  async check_limit() {
    if (this.current_lines_pointer > 0.9 * this.lines_limit) {
      const start = 0.3 * this.lines_limit;
      await this.set((await this.get_lines_by_index(-start)).join("\n"));
      this.current_lines_pointer = start;
    }
  }
  parser(line) {
    const [time, action, path2, old_path] = line.split("	");
    return {
      time,
      action,
      path: path2,
      old_path
    };
  }
  async clear() {
    await this.set("");
    this.current_lines_pointer = 0;
  }
  async check_repeats(_action, _path) {
    const last_changes = await this.get_lines_by_index(-200);
    for (const item of last_changes) {
      const { action, path: path2 } = this.parser(item);
      if (action == "MODIFY" && _action == action && path2 == _path)
        return false;
    }
    return true;
  }
  async add_action(action, path2, old_path) {
    const date = new Date();
    if (!await this.check_repeats(action, path2))
      return;
    const fullmessage = `
[${date.toLocaleString()}]	${action}	${path2}	${old_path || "null"}`;
    await this.add(fullmessage);
    if (this.callback)
      this.callback(fullmessage);
    this.current_lines_pointer++;
    await this.check_limit();
  }
};

// src/async_queue.ts
var Queue = class {
  constructor() {
    this.actions = [];
  }
  append(action) {
    this.actions.push(action);
    if (this.actions.length == 1)
      this.action_handle();
  }
  async action_handle() {
    if (this.actions.length != 0) {
      const action = this.actions[0];
      if (action)
        await action();
      this.actions.shift();
      this.action_handle();
    }
  }
};

// src/settings.ts
var import_obsidian2 = require("obsidian");
var SnowflakeSettings = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const set = () => new import_obsidian2.Setting(containerEl);
    set().setName("Token").setDesc("Here is gitlab token").addText((text) => {
      var _a;
      return text.setPlaceholder("Enter your secret").setValue("*".repeat(((_a = pocket.get("gitlabtoken")) == null ? void 0 : _a.length) || 0)).onChange(async (value) => {
        pocket.set("gitlabtoken", value);
        await this.plugin.saveSettings();
      });
    });
    set().setName("Email").setDesc("Here is email - git commit").addText((text) => text.setPlaceholder("Enter your email").setValue(this.plugin.settings.email).onChange(async (value) => {
      this.plugin.settings.email = value;
      await this.plugin.saveSettings();
    }));
    set().setName("Username").setDesc("Here is gitlab username - git commit").addText((text) => text.setPlaceholder("Enter your username").setValue(this.plugin.settings.username).onChange(async (value) => {
      this.plugin.settings.username = value;
      await this.plugin.saveSettings();
    }));
    set().setName("Project").setDesc("Here is gitlab project name").addText((text) => text.setPlaceholder("Enter project name").setValue(this.plugin.settings.project_name).onChange(async (value) => {
      this.plugin.settings.project_name = value;
      await this.plugin.saveSettings();
    }));
    set().setName("Name").setDesc("Here is gitlab repository name").addText((text) => text.setPlaceholder("Enter repository name").setValue(this.plugin.settings.repo_name).onChange(async (value) => {
      this.plugin.settings.repo_name = value;
      await this.plugin.saveSettings();
    }));
    set().setName("Main branch").setDesc("Here is gitlab main branch name").addText((text) => text.setPlaceholder("Enter your branch name").setValue(this.plugin.settings.branch).onChange(async (value) => {
      this.plugin.settings.branch = value;
      await this.plugin.saveSettings();
    }));
    set().setName("Sync Auto").setDesc("Set on if you want to sync repository automatically").addToggle((cb) => cb.setValue(this.plugin.settings.auto).onChange(async (value) => {
      this.plugin.settings.auto = value;
      await this.plugin.saveSettings();
      new import_obsidian2.Notice(`Auto Mode: ${value ? "on" : "off"}`);
    }));
    set().setName("Fetch on start").setDesc("Set on if you want to sync repository on start").addToggle((cb) => cb.setValue(this.plugin.settings.fetch).onChange(async (value) => {
      this.plugin.settings.fetch = value;
      await this.plugin.saveSettings();
      new import_obsidian2.Notice(`Auto Fetch: ${value ? "on" : "off"}`);
    }));
    set().setName("Notifications").setDesc("Set on if you want notifications").addToggle((cb) => cb.setValue(this.plugin.settings.notif).onChange(async (value) => {
      this.plugin.settings.notif = value;
      await this.plugin.saveSettings();
      new import_obsidian2.Notice(`Notifications: ${value ? "on" : "off"}`);
    }));
    set().setName("Reload Settings").setDesc("Click to reload current settings").addButton((cb) => cb.setButtonText("Reload").setIcon("refresh-cw").onClick(() => {
      this.plugin.loadSettings();
      new import_obsidian2.Notice("Settings updated");
    }));
  }
};

// views/history_view.ts
var import_obsidian3 = require("obsidian");
var HistoryLeaf = class extends import_obsidian3.ItemView {
  constructor(leaf) {
    super(leaf);
    this.icon = "scroll";
  }
  getViewType() {
    return HISTORY_VIEW;
  }
  getDisplayText() {
    return "Snowflake History";
  }
  async reload_logs(element, type) {
    const logs = await type.get_lines_by_index(-300);
    element.empty();
    logs.reverse().forEach((item) => {
      element.createEl("code", {
        text: item.replace(/\t/gm, " | ")
      });
    });
  }
  create_button(parent, name, callback) {
    const button = parent.createEl("button", {
      text: name
    });
    button.style.margin = "10px";
    button.addEventListener("click", () => {
      callback();
    });
  }
  async render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("h2", { text: "Snowflake History" });
    container.createEl("h3", { text: "Snowflake Local Changes" });
    this.local_logs = container.createEl("div");
    container.createEl("h3", { text: "Snowflake Sync Logs" });
    this.sync_logs = container.createEl("div");
    [this.local_logs, this.sync_logs].forEach((item) => {
      item.style.fontSize = "10px";
      item.style.whiteSpace = "nowrap";
      item.style.maxHeight = "500px";
      item.style.overflowY = "auto";
      item.style.display = "flex";
      item.style.flexDirection = "column-reverse";
    });
  }
  async update() {
    await this.reload_logs(this.local_logs, local_changes_logs);
    await this.reload_logs(this.sync_logs, sync_logs);
  }
  async onOpen() {
    await this.render();
    await this.reload_logs(this.local_logs, local_changes_logs);
    await this.reload_logs(this.sync_logs, sync_logs);
  }
};

// views/views.ts
var activate_history_view = async () => {
  const { workspace } = app;
  let leaf = null;
  const leaves = workspace.getLeavesOfType(HISTORY_VIEW);
  if (leaves.length > 0) {
    leaf = leaves[0];
  } else {
    leaf = workspace.getRightLeaf(false);
    await leaf.setViewState({ type: HISTORY_VIEW, active: false });
  }
  sync_logs.set_callback(() => {
    if (leaf)
      leaf.view.update();
  });
  local_changes_logs.set_callback(() => {
    if (leaf)
      leaf.view.update();
  });
};

// src/commands/show_panels.ts
var logs_panel = {
  id: "open_logs_panel",
  name: "Open Snowflake Logs",
  callback: async () => {
    activate_history_view();
  }
};

// src/modal/selection.ts
var import_obsidian4 = require("obsidian");
var CommandSelection = class extends import_obsidian4.SuggestModal {
  constructor(config) {
    super(app);
    this.config = { ...config };
    this.setPlaceholder(this.config.placeholder || "");
  }
  open() {
    super.open();
    if (this.config.initialValue != void 0) {
      this.inputEl.value = this.config.initialValue;
      this.inputEl.dispatchEvent(new Event("input"));
    }
    return new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  selectSuggestion(value, evt) {
    if (this.resolve) {
      let res;
      if (this.config.allowEmpty && value === " ")
        res = "";
      else if (value === "...")
        res = void 0;
      else
        res = value;
      this.resolve(res);
    }
    super.selectSuggestion(value, evt);
  }
  onClose() {
    if (this.resolve)
      this.resolve(void 0);
  }
  getSuggestions(query) {
    if (this.config.onlySelection) {
      return this.config.options || [];
    } else if (this.config.allowEmpty) {
      return [query.length > 0 ? query : " ", ...this.config.options || []];
    } else {
      return [query.length > 0 ? query : "...", ...this.config.options || []];
    }
  }
  renderSuggestion(value, el) {
    el.setText(value);
  }
  onChooseSuggestion(item, evt) {
  }
};

// src/commands/repository_controller.ts
var import_obsidian5 = require("obsidian");

// src/utils.ts
var base64ToArrayBuffer2 = (base64) => {
  var binaryString = atob(base64);
  var bytes = new Uint8Array(binaryString.length);
  for (var i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
};

// src/commands/repository_controller.ts
var command__send_all = async () => {
  const nc = new import_obsidian5.Notice("Sending...", 0);
  const status = [0, 0];
  const read_folder = async (dir) => {
    if (dir.contains(".git") || dir.contains("node_modules"))
      return;
    const content = await app.vault.adapter.list(dir);
    for (const path2 of content.files) {
      nc.setMessage(path2);
      status[0] += 1;
      await gitlab.create(path2, {}, false);
    }
    for (const path2 of content.folders) {
      nc.setMessage(path2);
      status[1] += 1;
      await read_folder(path2);
    }
  };
  await read_folder("/");
  await gitlab.save_last_commit();
  nc.setMessage(`Done for ${status[0]} files in ${status[1]} folders`);
  setTimeout(() => nc.hide(), 1e3 * 5);
};
var command__send_changes = async () => {
  const logged_local_changes_from_file = await local_changes_logs.get_lines_from_to_phrase("LOCAL CHANGES");
  const files_states = /* @__PURE__ */ new Map();
  let logged_local_changes_parsed = [];
  logged_local_changes_from_file.reverse().forEach(
    (item) => {
      const parsed_object = local_changes_logs.parser(item);
      if (!!parsed_object.old_path)
        files_states.delete(parsed_object.old_path);
      if (files_states.has(parsed_object.path) && parsed_object.action == "DELETE")
        files_states.delete(parsed_object.path);
      if (files_states.has(parsed_object.path) && parsed_object.action == "MODIFY") {
        files_states.set(parsed_object.path, { ...parsed_object, action: "CREATE" });
        return;
      }
      files_states.set(parsed_object.path, parsed_object);
      logged_local_changes_parsed = Array.from(files_states.entries());
    }
  );
  logged_local_changes_parsed.forEach((item) => {
    const parsed = item[1];
    if (parsed.action == "CREATE")
      req_queue.append(async () => {
        try {
          await gitlab.create(
            parsed.path,
            { commit_message: `creating file "${parsed.path}" - ${parsed.time}` },
            false
          );
          sync_logs.log(`creating file "${parsed.path}"`);
        } catch (e) {
          sync_logs.log(`FAIL: creating file "${parsed.path}"`);
        }
      });
    if (parsed.action == "MODIFY")
      req_queue.append(async () => {
        try {
          await gitlab.modify(
            parsed.path,
            { commit_message: `modifying file "${parsed.path}" - ${parsed.time}` },
            false
          );
          sync_logs.log(`modifying file "${parsed.path}"`);
        } catch (e) {
          sync_logs.log(`FAIL: modifying file "${parsed.path}"`);
        }
      });
    if (parsed.action == "DELETE")
      req_queue.append(async () => {
        try {
          await gitlab.delete(
            parsed.path,
            { commit_message: `deleting file "${parsed.path}" - ${parsed.time}` },
            false
          );
          sync_logs.log(`deleting file "${parsed.path}"`);
        } catch (e) {
          sync_logs.log(`FAIL: deleting file "${parsed.path}"`);
        }
      });
    if (parsed.action == "RENAME")
      req_queue.append(async () => {
        try {
          await gitlab.create(
            parsed.path,
            { commit_message: `renaming[c] file "${parsed.old_path}" -> "${parsed.path}" - ${parsed.time}` },
            false
          );
          await gitlab.delete(
            parsed.old_path,
            { commit_message: `renaming[d] file "${parsed.old_path}" -> "${parsed.path}" - ${parsed.time}` },
            false
          );
          sync_logs.log(`renaming file "${parsed.old_path}" -> "${parsed.path}"`);
        } catch (e) {
          sync_logs.log(`FAIL: renaming file "${parsed.old_path}" -> "${parsed.path}"`);
        }
      });
  });
  await gitlab.save_last_commit();
  local_changes_logs.add_action("LOCAL CHANGES PUSHED", `${logged_local_changes_parsed.length} changes`);
  local_changes_logs.callback();
};
var command__get_all_repo = async () => {
  const include_config = await new CommandSelection({
    placeholder: "Includes .obsidian?",
    options: ["YES", "NO"]
  }).open();
  const choose_pathtree = async (start_path = "") => {
    const tree2 = await gitlab.read_repo_tree(start_path, 0, 0, false);
    const folders = tree2.filter((item) => item[2]).map((item) => item[1]);
    if (folders.length == 0)
      return start_path;
    const repo_path = await new CommandSelection({
      placeholder: "Repo dir path - leave empty for whole repo or .. to back",
      options: folders
    }).open();
    if (!repo_path)
      return start_path;
    if (repo_path == "..")
      return choose_pathtree("");
    return choose_pathtree(repo_path);
  };
  const path2 = await choose_pathtree("");
  const tree = await gitlab.read_repo_tree(path2);
  tree.forEach((item) => {
    if (item[2])
      app.vault.adapter.mkdir(item[1]);
  });
  const file_status = new import_obsidian5.Notice("File: ", 0);
  for (const file of tree) {
    if (include_config == "YES" && file[1].startsWith(".obsidian"))
      continue;
    if (file[2])
      continue;
    const res = await gitlab.read(file[1]);
    if (res == null)
      continue;
    file_status.setMessage("File: " + file[1]);
    app.vault.adapter.writeBinary(file[1], base64ToArrayBuffer2(res.data.content));
  }
  await gitlab.save_last_commit();
  file_status.hide();
  new import_obsidian5.Notice("Done");
};
var command__fetch_changes = async () => {
  const nc = new import_obsidian5.Notice("Fetching...", 0);
  const res = await gitlab.get_commits();
  const last_commit = res[res.length - 1];
  if (!last_commit)
    return await gitlab.save_last_commit();
  if (last_commit.id == pocket.get("last_commit_id"))
    return nc.setMessage("Everything is up to date");
  let content_remote_changes = 0;
  res.forEach((commit) => {
    req_queue.append(async () => {
      const res2 = await gitlab.get_diffs(commit.id);
      res2 == null ? void 0 : res2.data.forEach(async (item) => {
        content_remote_changes++;
        req_queue.append(async () => {
          try {
            if (item.new_file || !item.renamed_file && !item.new_file && !item.deleted_file)
              await gitlab.save_local_file(item.new_path);
            if (item.renamed_file)
              await app.vault.adapter.rename(item.old_path, item.new_path);
            if (item.deleted_file)
              await app.vault.adapter.remove(item.new_path);
          } catch (e) {
            console.log("fetching errors");
          }
        });
      });
    });
  });
  await gitlab.save_last_commit();
  req_queue.append(() => local_changes_logs.add_action("LOCAL CHANGES PULLED", `${content_remote_changes} changes`));
  nc.setMessage("Everything is up to date\nLast commit: " + pocket.get("last_commit_id"));
};
var get_all_repository = {
  id: "get_all_repository",
  name: "Download all repository",
  callback: async () => {
    command__get_all_repo();
  }
};
var fetch_changes = {
  id: "fetch_changes",
  name: "Fetch remote changes",
  callback: async () => {
    command__fetch_changes();
  }
};
var send_all_gitlab = {
  id: "send_all_gitlab",
  name: "Send all local files",
  callback: async () => {
    command__send_all();
  }
};
var send_changes_gitlab = {
  id: "send_changes_gitlab",
  name: "Send local changes",
  callback: async () => {
    command__send_changes();
  }
};

// src/commands/barrel.ts
var commands = [
  logs_panel,
  get_all_repository,
  send_all_gitlab,
  send_changes_gitlab,
  fetch_changes
];
var barrel_default = commands;

// src/context_menu/file-menu.ts
var import_obsidian6 = require("obsidian");
var file_menu_send_file = (menu, file) => {
  menu.addItem((item) => {
    item.setTitle("Gitlab: Send File").setIcon("send").onClick(async () => {
      const nc = new import_obsidian6.Notice("Sending...", 0);
      req_queue.append(async () => {
        if (file.children) {
          const read_folder = async (dir) => {
            const content = await app.vault.adapter.list(dir);
            for (const path2 of content.files) {
              nc.setMessage(path2);
              await gitlab.create(path2);
            }
            for (const path2 of content.folders) {
              nc.setMessage(path2);
              await read_folder(path2);
            }
          };
          await read_folder(file.path);
        } else {
          await gitlab.create(file.path);
        }
        nc.setMessage("Done");
      });
      setTimeout(() => nc.hide(), 1e3 * 5);
    });
  });
};
var file_menu_load_file = (menu, file) => {
  menu.addItem((item) => {
    item.setTitle("Gitlab: Load File").setIcon("file-down").onClick(async () => {
      const nc = new import_obsidian6.Notice("Loading...", 0);
      req_queue.append(async () => {
        if (file.children) {
          const tree = await gitlab.read_repo_tree(file.path);
          tree.forEach((item2) => {
            if (item2[2])
              app.vault.adapter.mkdir(item2[1]);
          });
          for (const file2 of tree) {
            if (file2[2])
              continue;
            const res = await gitlab.read(file2[1]);
            if (res == null)
              continue;
            app.vault.adapter.writeBinary(file2[1], base64ToArrayBuffer2(res.data.content));
          }
        } else {
          const res = await gitlab.read(file.path);
          if (res == null)
            return;
          app.vault.adapter.writeBinary(file.path, base64ToArrayBuffer2(res.data.content));
        }
        nc.setMessage("Done");
      });
      setTimeout(() => nc.hide(), 1e3 * 7);
    });
  });
};
var file_menu_delete_file = (menu, file) => {
  menu.addItem((item) => {
    item.setTitle("Gitlab: Delete File").setIcon("trash-2").onClick(async () => {
      const nc = new import_obsidian6.Notice("Deleting...", 0);
      req_queue.append(async () => {
        if (file.children) {
          const read_folder = async (dir) => {
            const content = await app.vault.adapter.list(dir);
            for (const path2 of content.files) {
              nc.setMessage(path2);
              await gitlab.delete(path2);
            }
            for (const path2 of content.folders) {
              nc.setMessage(path2);
              await read_folder(path2);
            }
          };
          await read_folder(file.path);
        } else {
          await gitlab.delete(file.path);
        }
        nc.setMessage("Done");
      });
      setTimeout(() => nc.hide(), 1e3 * 5);
    });
  });
};

// main.ts
var gitlab = new GitLabAPI();
var pocket = new Pocket();
var req_queue = new Queue();
var sync_logs = new Logger(LOGGER_FILE);
var local_changes_logs = new History(HISTORY_FILE);
var SyncSnowflake2 = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.gitlab_settings = () => {
      return {
        api: GITLAB_API_URL,
        token: pocket.get(POCKET_TOKEN_KEY) || "",
        project: this.settings.project_name,
        repository: this.settings.repo_name,
        email: this.settings.email,
        nick: this.settings.username,
        branch: this.settings.branch,
        notifications: this.settings.notif
      };
    };
  }
  async onload() {
    sync_logs.set_config_dir(this.app.vault.configDir);
    local_changes_logs.set_config_dir(this.app.vault.configDir);
    await this.loadSettings();
    const status_bar = this.addStatusBarItem();
    this.registerView(
      HISTORY_VIEW,
      (leaf) => new HistoryLeaf(leaf)
    );
    for (const command of barrel_default) {
      this.addCommand(command);
    }
    this.addRibbonIcon("send", "Send local changes", async (evt) => {
      command__send_changes();
    }).addClass("my-plugin-ribbon-class");
    this.addRibbonIcon("download-cloud", "Fetch", async (evt) => {
      command__fetch_changes();
    }).addClass("my-plugin-ribbon-class");
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        file_menu_send_file(menu, file);
        file_menu_load_file(menu, file);
        file_menu_delete_file(menu, file);
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-open", async (file) => {
        if (!this.settings.auto)
          return;
        if (!(file == null ? void 0 : file.path))
          return;
        req_queue.append(async () => {
          status_bar.setText("Syncing...");
          await gitlab.save_local_file(file.path, file.path, true);
          status_bar.setText("Sync done");
        });
      })
    );
    setTimeout(() => {
      this.registerEvent(
        this.app.vault.on("create", async (file) => {
          local_changes_logs.add_action("CREATE", file.path);
          if (this.settings.auto)
            req_queue.append(async () => await gitlab.create(file.path));
        })
      );
      this.registerEvent(
        this.app.vault.on("modify", async (file) => {
          local_changes_logs.add_action("MODIFY", file.path);
          if (this.settings.auto)
            req_queue.append(async () => await gitlab.modify(file.path));
        })
      );
      this.registerEvent(
        this.app.vault.on("delete", async (file) => {
          local_changes_logs.add_action("DELETE", file.path);
          if (this.settings.auto)
            req_queue.append(async () => await gitlab.delete(file.path));
        })
      );
      this.registerEvent(
        this.app.vault.on("rename", async (file, old_path) => {
          local_changes_logs.add_action("RENAME", file.path, old_path);
          this.app.vault.adapter.files[file.name].rtime = Date.now();
          this.app.vault.adapter.files[file.name].old_path = old_path;
          if (this.settings.auto)
            req_queue.append(async () => {
              await gitlab.create(file.path);
              await gitlab.delete(old_path);
            });
        })
      );
    }, 1e3 * 3);
    setTimeout(() => {
      activate_history_view();
    }, 1e3);
    this.addSettingTab(new SnowflakeSettings(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    pocket.prefix = `snowflake_obsidian_${this.settings.project_name + this.settings.repo_name}`;
    const git_lab_options = this.gitlab_settings();
    gitlab.setoptions(git_lab_options);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    pocket.prefix = `snowflake_obsidian_${this.settings.project_name + this.settings.repo_name}`;
    const git_lab_options = this.gitlab_settings();
    gitlab.setoptions(git_lab_options);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvZ2l0bGFiX2FwaS50cyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvc0Vycm9yLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9udWxsLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy90b0Zvcm1EYXRhLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvY2xhc3Nlcy9VUkxTZWFyY2hQYXJhbXMuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9icm93c2VyL2NsYXNzZXMvRm9ybURhdGEuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9icm93c2VyL2NsYXNzZXMvQmxvYi5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9jb21tb24vdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdG9VUkxFbmNvZGVkRm9ybS5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvc0hlYWRlcnMuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZVByb3RvY29sLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcGVlZG9tZXRlci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvZW52L2RhdGEuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9IdHRwU3RhdHVzQ29kZS5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsICJzcmMvc3RvcmFnZS50cyIsICJzcmMvc3RhdGljLnRzIiwgInNyYy9hc3luY19xdWV1ZS50cyIsICJzcmMvc2V0dGluZ3MudHMiLCAidmlld3MvaGlzdG9yeV92aWV3LnRzIiwgInZpZXdzL3ZpZXdzLnRzIiwgInNyYy9jb21tYW5kcy9zaG93X3BhbmVscy50cyIsICJzcmMvbW9kYWwvc2VsZWN0aW9uLnRzIiwgInNyYy9jb21tYW5kcy9yZXBvc2l0b3J5X2NvbnRyb2xsZXIudHMiLCAic3JjL3V0aWxzLnRzIiwgInNyYy9jb21tYW5kcy9iYXJyZWwudHMiLCAic3JjL2NvbnRleHRfbWVudS9maWxlLW1lbnUudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IE5vdGljZSwgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nXG5pbXBvcnQgeyBHaXRMYWJBUEksIEdpdExhYk9wdGlvbnMgfSBmcm9tICdzcmMvZ2l0bGFiX2FwaSdcbmltcG9ydCB7IEhpc3RvcnksIExvZ2dlciwgUG9ja2V0IH0gZnJvbSAnc3JjL3N0b3JhZ2UnXG5pbXBvcnQgeyBRdWV1ZSB9IGZyb20gJ3NyYy9hc3luY19xdWV1ZSdcbmltcG9ydCB7IFNldHRpbmdzVmlld3BvaW50IH0gZnJvbSAnZCdcbmltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MsIEdJVExBQl9BUElfVVJMLCBISVNUT1JZX0ZJTEUsIEhJU1RPUllfVklFVywgTE9HR0VSX0ZJTEUsIFBPQ0tFVF9UT0tFTl9LRVkgfSBmcm9tICdzcmMvc3RhdGljJ1xuaW1wb3J0IHsgU25vd2ZsYWtlU2V0dGluZ3MgfSBmcm9tICdzcmMvc2V0dGluZ3MnXG5cbmltcG9ydCB7IEhpc3RvcnlMZWFmIH0gZnJvbSAndmlld3MvaGlzdG9yeV92aWV3J1xuaW1wb3J0IGNvbW1hbmRzIGZyb20gJ3NyYy9jb21tYW5kcy9iYXJyZWwnXG5pbXBvcnQgeyBhY3RpdmF0ZV9oaXN0b3J5X3ZpZXcgfSBmcm9tICd2aWV3cy92aWV3cydcbmltcG9ydCB7IGZpbGVfbWVudV9kZWxldGVfZmlsZSwgZmlsZV9tZW51X2xvYWRfZmlsZSwgZmlsZV9tZW51X3NlbmRfZmlsZSB9IGZyb20gJ3NyYy9jb250ZXh0X21lbnUvZmlsZS1tZW51J1xuaW1wb3J0IHsgY29tbWFuZF9fZmV0Y2hfY2hhbmdlcywgY29tbWFuZF9fc2VuZF9jaGFuZ2VzIH0gZnJvbSAnc3JjL2NvbW1hbmRzL3JlcG9zaXRvcnlfY29udHJvbGxlcidcblxuXG5leHBvcnQgY29uc3QgZ2l0bGFiID0gbmV3IEdpdExhYkFQSSgpXG5leHBvcnQgY29uc3QgcG9ja2V0ID0gbmV3IFBvY2tldCgpXG5leHBvcnQgY29uc3QgcmVxX3F1ZXVlID0gbmV3IFF1ZXVlKClcblxuZXhwb3J0IGNvbnN0IHN5bmNfbG9ncyA9IG5ldyBMb2dnZXIoTE9HR0VSX0ZJTEUpXG5leHBvcnQgY29uc3QgbG9jYWxfY2hhbmdlc19sb2dzID0gbmV3IEhpc3RvcnkoSElTVE9SWV9GSUxFKVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTeW5jU25vd2ZsYWtlIGV4dGVuZHMgUGx1Z2luIHtcblx0c2V0dGluZ3M6IFNldHRpbmdzVmlld3BvaW50XG5cdGdpdGxhYl9zZXR0aW5ncyA9ICgpOiBHaXRMYWJPcHRpb25zID0+IHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0YXBpOiBHSVRMQUJfQVBJX1VSTCxcblx0XHRcdHRva2VuOiBwb2NrZXQuZ2V0KFBPQ0tFVF9UT0tFTl9LRVkpIHx8ICcnLFxuXHRcdFx0cHJvamVjdDogdGhpcy5zZXR0aW5ncy5wcm9qZWN0X25hbWUsXG5cdFx0XHRyZXBvc2l0b3J5OiB0aGlzLnNldHRpbmdzLnJlcG9fbmFtZSxcblx0XHRcdGVtYWlsOiB0aGlzLnNldHRpbmdzLmVtYWlsLFxuXHRcdFx0bmljazogdGhpcy5zZXR0aW5ncy51c2VybmFtZSxcblx0XHRcdGJyYW5jaDogdGhpcy5zZXR0aW5ncy5icmFuY2gsXG5cdFx0XHRub3RpZmljYXRpb25zOiB0aGlzLnNldHRpbmdzLm5vdGlmXG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgb25sb2FkKCkge1xuXHRcdHN5bmNfbG9ncy5zZXRfY29uZmlnX2Rpcih0aGlzLmFwcC52YXVsdC5jb25maWdEaXIpXG5cdFx0bG9jYWxfY2hhbmdlc19sb2dzLnNldF9jb25maWdfZGlyKHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpcilcblxuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKClcblx0XHRjb25zdCBzdGF0dXNfYmFyID0gdGhpcy5hZGRTdGF0dXNCYXJJdGVtKClcblxuXHRcdHRoaXMucmVnaXN0ZXJWaWV3KFxuXHRcdFx0SElTVE9SWV9WSUVXLFxuXHRcdFx0KGxlYWYpID0+IG5ldyBIaXN0b3J5TGVhZihsZWFmKVxuXHRcdClcblxuXHRcdGZvciAoY29uc3QgY29tbWFuZCBvZiBjb21tYW5kcykge1xuXHRcdFx0dGhpcy5hZGRDb21tYW5kKGNvbW1hbmQpXG5cdFx0fVxuXG5cblx0XHR0aGlzLmFkZFJpYmJvbkljb24oJ3NlbmQnLCAnU2VuZCBsb2NhbCBjaGFuZ2VzJywgYXN5bmMgKGV2dDogTW91c2VFdmVudCkgPT4ge1xuXHRcdFx0Y29tbWFuZF9fc2VuZF9jaGFuZ2VzKClcblx0XHR9KS5hZGRDbGFzcygnbXktcGx1Z2luLXJpYmJvbi1jbGFzcycpXG5cblx0XHR0aGlzLmFkZFJpYmJvbkljb24oJ2Rvd25sb2FkLWNsb3VkJywgJ0ZldGNoJywgYXN5bmMgKGV2dDogTW91c2VFdmVudCkgPT4ge1xuXHRcdFx0Y29tbWFuZF9fZmV0Y2hfY2hhbmdlcygpXG5cdFx0fSkuYWRkQ2xhc3MoJ215LXBsdWdpbi1yaWJib24tY2xhc3MnKVxuXG5cblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQoXG5cdFx0XHR0aGlzLmFwcC53b3Jrc3BhY2Uub24oXCJmaWxlLW1lbnVcIiwgKG1lbnUsIGZpbGUpID0+IHtcblx0XHRcdFx0ZmlsZV9tZW51X3NlbmRfZmlsZShtZW51LCBmaWxlKVxuXHRcdFx0XHRmaWxlX21lbnVfbG9hZF9maWxlKG1lbnUsIGZpbGUpXG5cdFx0XHRcdGZpbGVfbWVudV9kZWxldGVfZmlsZShtZW51LCBmaWxlKVxuXHRcdFx0fSlcblx0XHQpXG5cblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQoXG5cdFx0XHR0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2ZpbGUtb3BlbicsIGFzeW5jIChmaWxlKSA9PiB7XG5cdFx0XHRcdGlmICghdGhpcy5zZXR0aW5ncy5hdXRvKSByZXR1cm5cblx0XHRcdFx0aWYgKCFmaWxlPy5wYXRoKSByZXR1cm5cblx0XHRcdFx0cmVxX3F1ZXVlLmFwcGVuZChhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0c3RhdHVzX2Jhci5zZXRUZXh0KCdTeW5jaW5nLi4uJylcblx0XHRcdFx0XHRhd2FpdCBnaXRsYWIuc2F2ZV9sb2NhbF9maWxlKGZpbGUucGF0aCwgZmlsZS5wYXRoLCB0cnVlKVxuXHRcdFx0XHRcdHN0YXR1c19iYXIuc2V0VGV4dCgnU3luYyBkb25lJylcblx0XHRcdFx0fSlcblx0XHRcdH0pXG5cdFx0KVxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0XHR0aGlzLmFwcC52YXVsdC5vbignY3JlYXRlJywgYXN5bmMgKGZpbGUpID0+IHtcblx0XHRcdFx0XHRsb2NhbF9jaGFuZ2VzX2xvZ3MuYWRkX2FjdGlvbignQ1JFQVRFJywgZmlsZS5wYXRoKVxuXHRcdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmF1dG8pXG5cdFx0XHRcdFx0XHRyZXFfcXVldWUuYXBwZW5kKGFzeW5jICgpID0+IGF3YWl0IGdpdGxhYi5jcmVhdGUoZmlsZS5wYXRoKSlcblx0XHRcdFx0fSlcblx0XHRcdClcblx0XHRcdHRoaXMucmVnaXN0ZXJFdmVudChcblx0XHRcdFx0dGhpcy5hcHAudmF1bHQub24oJ21vZGlmeScsIGFzeW5jIChmaWxlKSA9PiB7XG5cdFx0XHRcdFx0bG9jYWxfY2hhbmdlc19sb2dzLmFkZF9hY3Rpb24oJ01PRElGWScsIGZpbGUucGF0aClcblx0XHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5hdXRvKVxuXHRcdFx0XHRcdFx0cmVxX3F1ZXVlLmFwcGVuZChhc3luYyAoKSA9PiBhd2FpdCBnaXRsYWIubW9kaWZ5KGZpbGUucGF0aCkpXG5cdFx0XHRcdH0pXG5cdFx0XHQpXG5cdFx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQoXG5cdFx0XHRcdHRoaXMuYXBwLnZhdWx0Lm9uKCdkZWxldGUnLCBhc3luYyAoZmlsZSkgPT4ge1xuXHRcdFx0XHRcdGxvY2FsX2NoYW5nZXNfbG9ncy5hZGRfYWN0aW9uKCdERUxFVEUnLCBmaWxlLnBhdGgpXG5cdFx0XHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuYXV0bylcblx0XHRcdFx0XHRcdHJlcV9xdWV1ZS5hcHBlbmQoYXN5bmMgKCkgPT4gYXdhaXQgZ2l0bGFiLmRlbGV0ZShmaWxlLnBhdGgpKVxuXHRcdFx0XHR9KVxuXHRcdFx0KVxuXHRcdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0XHR0aGlzLmFwcC52YXVsdC5vbigncmVuYW1lJywgYXN5bmMgKGZpbGUsIG9sZF9wYXRoKSA9PiB7XG5cdFx0XHRcdFx0bG9jYWxfY2hhbmdlc19sb2dzLmFkZF9hY3Rpb24oJ1JFTkFNRScsIGZpbGUucGF0aCwgb2xkX3BhdGgpXG5cdFx0XHRcdFx0dGhpcy5hcHAudmF1bHQuYWRhcHRlci5maWxlc1tmaWxlLm5hbWVdLnJ0aW1lID0gRGF0ZS5ub3coKVxuXHRcdFx0XHRcdHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZmlsZXNbZmlsZS5uYW1lXS5vbGRfcGF0aCA9IG9sZF9wYXRoXG5cdFx0XHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuYXV0bylcblx0XHRcdFx0XHRcdHJlcV9xdWV1ZS5hcHBlbmQoYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRhd2FpdCBnaXRsYWIuY3JlYXRlKGZpbGUucGF0aClcblx0XHRcdFx0XHRcdFx0YXdhaXQgZ2l0bGFiLmRlbGV0ZShvbGRfcGF0aClcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdH0pXG5cdFx0XHQpXG5cdFx0fSwgMTAwMCAqIDMpXG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRhY3RpdmF0ZV9oaXN0b3J5X3ZpZXcoKVxuXHRcdH0sIDEwMDApXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTbm93Zmxha2VTZXR0aW5ncyh0aGlzLmFwcCwgdGhpcykpXG5cdH1cblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpXG5cdFx0cG9ja2V0LnByZWZpeCA9IGBzbm93Zmxha2Vfb2JzaWRpYW5fJHt0aGlzLnNldHRpbmdzLnByb2plY3RfbmFtZSt0aGlzLnNldHRpbmdzLnJlcG9fbmFtZX1gXG5cdFx0Y29uc3QgZ2l0X2xhYl9vcHRpb25zID0gdGhpcy5naXRsYWJfc2V0dGluZ3MoKVxuXHRcdGdpdGxhYi5zZXRvcHRpb25zKGdpdF9sYWJfb3B0aW9ucylcblx0fVxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKVxuXHRcdHBvY2tldC5wcmVmaXggPSBgc25vd2ZsYWtlX29ic2lkaWFuXyR7dGhpcy5zZXR0aW5ncy5wcm9qZWN0X25hbWUrdGhpcy5zZXR0aW5ncy5yZXBvX25hbWV9YFxuXHRcdGNvbnN0IGdpdF9sYWJfb3B0aW9ucyA9IHRoaXMuZ2l0bGFiX3NldHRpbmdzKClcblx0XHRnaXRsYWIuc2V0b3B0aW9ucyhnaXRfbGFiX29wdGlvbnMpXG5cdH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIE5vdGljZSwgVEZpbGUsIGFycmF5QnVmZmVyVG9CYXNlNjQgfSBmcm9tICdvYnNpZGlhbidcclxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJ1xyXG5pbXBvcnQgeyBwb2NrZXQsIHN5bmNfbG9ncyB9IGZyb20gJ21haW4nXHJcblxyXG5leHBvcnQgdHlwZSBHaXRMYWJTbmlwcGV0RmlsZUFjdGlvbiA9ICdjcmVhdGUnIHwgJ3VwZGF0ZScgfCAnZGVsZXRlJyB8ICdtb3ZlJ1xyXG5leHBvcnQgdHlwZSBHaXRMYWJPcHRpb25zID0ge1xyXG4gIGFwaTogc3RyaW5nXHJcbiAgdG9rZW46IHN0cmluZyxcclxuICBwcm9qZWN0OiBzdHJpbmcsXHJcbiAgcmVwb3NpdG9yeTogc3RyaW5nLFxyXG4gIGVtYWlsOiBzdHJpbmcsXHJcbiAgbmljazogc3RyaW5nLFxyXG4gIGJyYW5jaDogc3RyaW5nLFxyXG4gIG5vdGlmaWNhdGlvbnM6IGJvb2xlYW5cclxufVxyXG5leHBvcnQgdHlwZSBHaXRMYWJDb21taXRPcHRpb25zID0ge1xyXG4gIGJyYW5jaD86IHN0cmluZyxcclxuICBlbmNvZGluZz86IHN0cmluZyxcclxuICBhdXRob3JfZW1haWw/OiBzdHJpbmcsXHJcbiAgYXV0aG9yX25hbWU/OiBzdHJpbmcsXHJcbiAgY29tbWl0X21lc3NhZ2U/OiBzdHJpbmdcclxufVxyXG5leHBvcnQgdHlwZSBHaXRMYWJTbmlwcGV0RmlsZSA9IHtcclxuICBhY3Rpb246IEdpdExhYlNuaXBwZXRGaWxlQWN0aW9uXHJcbiAgZmlsZV9wYXRoOiBzdHJpbmdcclxuICBjb250ZW50OiBzdHJpbmdcclxuICBwcmV2aW91c19wYXRoPzogc3RyaW5nXHJcbn1cclxuZXhwb3J0IHR5cGUgR2l0TGFiU25pcHBldEZpbGVPcHRpb25hbCA9IHtcclxuICBhY3Rpb24/OiBHaXRMYWJTbmlwcGV0RmlsZUFjdGlvblxyXG4gIGZpbGVfcGF0aD86IHN0cmluZ1xyXG4gIGNvbnRlbnQ/OiBzdHJpbmdcclxuICBwcmV2aW91c19wYXRoPzogc3RyaW5nXHJcbn1cclxuZXhwb3J0IHR5cGUgR2l0TGFiU25pcHBldERvYyA9IHtcclxuICB0aXRsZTogc3RyaW5nXHJcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xyXG4gIHZpc2liaWxpdHk6IHN0cmluZ1xyXG4gIGZpbGVzOiBHaXRMYWJTbmlwcGV0RmlsZVtdXHJcbn1cclxuZXhwb3J0IHR5cGUgR2l0TGFiU25pcHBldERvY09wdGlvbmFsID0ge1xyXG4gIHRpdGxlPzogc3RyaW5nXHJcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcclxuICB2aXNpYmlsaXR5Pzogc3RyaW5nXHJcbiAgZmlsZXM/OiBHaXRMYWJTbmlwcGV0RmlsZVtdXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEdpdGxhYkNvbW1pdCA9IHtcclxuICBpZDogc3RyaW5nLFxyXG4gIHNob3J0X2lkOiBzdHJpbmcsXHJcbiAgY3JlYXRlZF9hdDogRGF0ZSxcclxuICBwYXJlbnRfaWRzOiBzdHJpbmcsXHJcbiAgdGl0bGU6IHN0cmluZyxcclxuICBtZXNzYWdlOiBzdHJpbmcsXHJcbiAgYXV0aG9yX25hbWU6IHN0cmluZyxcclxuICBhdXRob3JfZW1haWw6IHN0cmluZyxcclxuICBhdXRob3JlZF9kYXRlOiBEYXRlLFxyXG4gIGNvbW1pdHRlcl9uYW1lOiBzdHJpbmcsXHJcbiAgY29tbWl0dGVyX2VtYWlsOiBzdHJpbmcsXHJcbiAgY29tbWl0dGVkX2RhdGU6IERhdGUsXHJcbiAgdHJhaWxlcnM6IGFueSxcclxuICBleHRlbmRlZF90cmFpbGVyczogYW55LFxyXG4gIHdlYl91cmw6IHN0cmluZyxcclxuICBzdGF0czoge1xyXG4gICAgYWRkaXRpb25zOiBudW1iZXIsXHJcbiAgICBkZWxldGlvbnM6IG51bWJlcixcclxuICAgIHRvdGFsOiBudW1iZXJcclxuICB9LFxyXG4gIHN0YXR1czogYW55LFxyXG4gIHByb2plY3RfaWQ6IG51bWJlcixcclxuICBsYXN0X3BpcGVsaW5lOiBhbnlcclxufVxyXG5cclxuY29uc3QgdXJsc2xhc2ggPSAoLi4udGV4dDogc3RyaW5nW10pOiBzdHJpbmcgPT4ge1xyXG4gIGNvbnN0IHBhdGggPSB0ZXh0LmpvaW4oJy8nKVxyXG4gIGNvbnN0IGVuZCA9IHBhdGguc2xpY2UocGF0aC5sYXN0SW5kZXhPZignLycpKVxyXG4gIGNvbnN0IHN0YXJ0ID0gcGF0aC5zbGljZSgwLCBwYXRoLmxhc3RJbmRleE9mKCcvJykpLnJlcGxhY2UoL1xcLi9nbSwgJyUyRScpXHJcbiAgcmV0dXJuIChzdGFydCArIGVuZCkucmVwbGFjZSgvXFwvL2dtLCAnJTJGJylcclxufVxyXG5mdW5jdGlvbiBiYXNlNjRUb0FycmF5QnVmZmVyKGJhc2U2NDogc3RyaW5nKSB7XHJcbiAgdmFyIGJpbmFyeVN0cmluZyA9IGF0b2IoYmFzZTY0KTtcclxuICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xyXG4gICAgYnl0ZXNbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICB9XHJcbiAgcmV0dXJuIGJ5dGVzLmJ1ZmZlcjtcclxufVxyXG5cclxuXHJcbmNvbnN0IGV4dXJsID0gKF91cmw6IHN0cmluZywgX3BhcmFtc19ubzogbnVtYmVyID0gMCkgPT4gKHtcclxuICBiYXNlOiAodXJsOiBzdHJpbmcpID0+IGV4dXJsKF91cmwgKyB1cmwsIF9wYXJhbXNfbm8pLFxyXG4gIGFkZDogKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiBleHVybChfdXJsICsgKF9wYXJhbXNfbm8gPT0gMCA/ICc/JyA6ICcmJykgKyBgJHtrZXl9PSR7dmFsdWV9YCwgX3BhcmFtc19ubyArIDEpLFxyXG4gIHBhcmFtczogKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiBleHVybChfdXJsLnJlcGxhY2UoYDoke2tleX1gLCB2YWx1ZSksIF9wYXJhbXNfbm8pLFxyXG4gIHZhbHVlOiBfdXJsXHJcbn0pXHJcblxyXG50eXBlIEV4VXJsID0gUmV0dXJuVHlwZTx0eXBlb2YgZXh1cmw+XHJcblxyXG5leHBvcnQgY2xhc3MgR2l0TGFiQVBJIHtcclxuICBvcHRpb25zOiBHaXRMYWJPcHRpb25zXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgfVxyXG4gIHNldG9wdGlvbnMob3B0aW9uczogR2l0TGFiT3B0aW9ucykge1xyXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xyXG4gIH1cclxuICBpZCA9ICgpID0+IHVybHNsYXNoKHRoaXMub3B0aW9ucy5wcm9qZWN0LCB0aGlzLm9wdGlvbnMucmVwb3NpdG9yeSlcclxuICBoZWFkZXIgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAnUFJJVkFURS1UT0tFTic6IHRoaXMub3B0aW9ucy50b2tlbixcclxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgfVxyXG4gIH1cclxuICB1cmwgPSB7XHJcbiAgICBjb21taXRzOiAoKSA9PiBleHVybChgJHt0aGlzLm9wdGlvbnMuYXBpfS9wcm9qZWN0cy8ke3RoaXMuaWQoKX0vcmVwb3NpdG9yeS9jb21taXRzYCksXHJcbiAgICBicmFuY2hlczogKCkgPT4gZXh1cmwoYCR7dGhpcy5vcHRpb25zLmFwaX0vcHJvamVjdHMvJHt0aGlzLmlkKCl9L3JlcG9zaXRvcnkvYnJhbmNoZXNgKSxcclxuICAgIGZpbGVzOiAoKSA9PiBleHVybChgJHt0aGlzLm9wdGlvbnMuYXBpfS9wcm9qZWN0cy8ke3RoaXMuaWQoKX0vcmVwb3NpdG9yeS9maWxlc2ApXHJcbiAgfVxyXG4gIGFzeW5jIGdldF9sb2NhbF9maWxlX2NvbnRlbnQocGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgIGNvbnN0IGFycmF5X2J1ZmZlciA9IGF3YWl0IGFwcC52YXVsdC5hZGFwdGVyLnJlYWRCaW5hcnkocGF0aClcclxuICAgIHJldHVybiBhcnJheUJ1ZmZlclRvQmFzZTY0KGFycmF5X2J1ZmZlcilcclxuICB9XHJcbiAgYXN5bmMgc2F2ZV9sb2NhbF9maWxlKHJlbW90ZV9wYXRoOiBzdHJpbmcsIGxvY2FsX3BhdGg/OiBzdHJpbmcsIGNyZWF0ZV9pZl9ub3RfZXhpc3Q6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKCFsb2NhbF9wYXRoKSBsb2NhbF9wYXRoID0gcmVtb3RlX3BhdGhcclxuICAgIGNvbnN0IHJlbW90ZV9maWxlID0gYXdhaXQgdGhpcy5yZWFkKHJlbW90ZV9wYXRoKVxyXG4gICAgaWYgKCFyZW1vdGVfZmlsZSkge1xyXG4gICAgICBpZiAoY3JlYXRlX2lmX25vdF9leGlzdClcclxuICAgICAgICB0aGlzLmNyZWF0ZShyZW1vdGVfcGF0aClcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgYXBwLnZhdWx0LmFkYXB0ZXIud3JpdGVCaW5hcnkobG9jYWxfcGF0aCwgYmFzZTY0VG9BcnJheUJ1ZmZlcihyZW1vdGVfZmlsZS5kYXRhLmNvbnRlbnQpKVxyXG4gIH1cclxuICBhc3luYyBnZXRfYnJhbmNoZXMoKSB7XHJcbiAgICBjb25zdCB1cmwgPSB0aGlzLnVybC5icmFuY2hlcygpXHJcbiAgICAgIC5hZGQoJ3B0JywgJ251bGwnKVxyXG5cclxuICAgIGNvbnN0IHJlczogYW55W10gPSBbXVxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgdGhpcy5wYWdpbmF0aW9uKDEsIHVybCwgYXN5bmMgKHJlc19pdGVtKSA9PiB7XHJcbiAgICAgICAgcmVzLnB1c2goLi4ucmVzX2l0ZW0uZGF0YS5tYXAoKGl0ZW06IGFueSkgPT4gaXRlbS5uYW1lKSlcclxuICAgICAgfSlcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgbmV3IE5vdGljZShgQ2Fubm90IGdldCBicmFuY2hlc1xcbiR7dXJsLnZhbHVlfWApXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfVxyXG4gIGFzeW5jIGNyZWF0ZV9icmFuY2goYnJhbmNoOiBzdHJpbmcsIHBhcmVudF9icmFuY2g6IHN0cmluZykge1xyXG4gICAgY29uc3QgdXJsID0gdGhpcy51cmwuYnJhbmNoZXMoKVxyXG4gICAgICAuYWRkKCdicmFuY2gnLCB1cmxzbGFzaChicmFuY2gpKVxyXG4gICAgICAuYWRkKCdyZWYnLCB1cmxzbGFzaChwYXJlbnRfYnJhbmNoKSlcclxuICAgICAgLnZhbHVlXHJcblxyXG4gICAgY29uc3QgcmVzOiBhbnlbXSA9IFtdXHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBheGlvcy5wb3N0KHVybCwgbnVsbCwge1xyXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyKClcclxuICAgICAgfSlcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgbmV3IE5vdGljZShgRXJyb3Igd2hpbGUgY3JlYXRpbmcgYnJhbmNoXFxuJHt1cmx9YClcclxuICAgIH1cclxuICAgIHJldHVybiByZXNcclxuICB9XHJcbiAgYXN5bmMgc2F2ZV9sYXN0X2NvbW1pdCgpIHtcclxuICAgIGNvbnN0IHVybCA9IHRoaXMudXJsLmNvbW1pdHMoKVxyXG4gICAgICAuYWRkKCd3aXRoX3N0YXRzJywgJ3RydWUnKVxyXG4gICAgICAuYWRkKCdhbGwnLCAndHJ1ZScpXHJcbiAgICAgIC5hZGQoJ3Blcl9wYWdlJywgJzMnKVxyXG4gICAgICAudmFsdWVcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGF4aW9zLmdldCh1cmwsIHtcclxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXIoKVxyXG4gICAgfSlcclxuICAgIGNvbnN0IGxhc3RfY29tbWl0ID0gcmVzLmRhdGEucG9wKClcclxuICAgIHBvY2tldC5zZXQoJ2xhc3RfY29tbWl0X2lkJywgbGFzdF9jb21taXQuaWQpXHJcbiAgICBwb2NrZXQuc2V0KCdsYXN0X2NvbW1pdF9kYXRlJywgbGFzdF9jb21taXQuY29tbWl0dGVkX2RhdGUpXHJcbiAgfVxyXG4gIGNvbnZlcnRUb0dpdGxhYkNvbW1pdChkYXRhOiBhbnkpOiBHaXRsYWJDb21taXQge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLi4uZGF0YSxcclxuICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoZGF0YS5jcmVhdGVkX2F0KSxcclxuICAgICAgYXV0aG9yZWRfZGF0ZTogbmV3IERhdGUoZGF0YS5hdXRob3JlZF9kYXRlKSxcclxuICAgICAgY29tbWl0dGVkX2RhdGU6IG5ldyBEYXRlKGRhdGEuY29tbWl0dGVkX2RhdGUpLFxyXG4gICAgfTtcclxuICB9XHJcbiAgYXN5bmMgZ2V0X2NvbW1pdChzaGE6IHN0cmluZyk6IFByb21pc2U8R2l0bGFiQ29tbWl0IHwgbnVsbD4ge1xyXG4gICAgY29uc3QgdXJsID0gdGhpcy51cmwuY29tbWl0cygpXHJcbiAgICAgIC5iYXNlKCcvJyArIHNoYSlcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGF4aW9zLmdldCh1cmwudmFsdWUsIHtcclxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcigpLFxyXG4gICAgICB9KVxyXG4gICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VG9HaXRsYWJDb21taXQocmVzLmRhdGEpXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoYENhbm5vdCBnZXQgY29tbWl0XFxuJHt1cmwudmFsdWV9YClcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsXHJcbiAgfVxyXG4gIGFzeW5jIGdldF9jb21taXRzKCkge1xyXG4gICAgY29uc3QgdXJsID0gdGhpcy51cmwuY29tbWl0cygpXHJcbiAgICAgIC5hZGQoJ3dpdGhfc3RhdHMnLCAndHJ1ZScpXHJcbiAgICAgIC5hZGQoJ2FsbCcsICd0cnVlJylcclxuICAgICAgLmFkZCgncmVmX25hbWUnLCB0aGlzLm9wdGlvbnMuYnJhbmNoKVxyXG4gICAgICAuYWRkKCdzaW5jZScsIHBvY2tldC5nZXQoJ2xhc3RfY29tbWl0X2RhdGUnKSB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkpXHJcblxyXG5cclxuICAgIGNvbnN0IHJlczogYW55W10gPSBbXVxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgdGhpcy5wYWdpbmF0aW9uKDEsIHVybCwgKHJlc19pdGVtKSA9PiB7XHJcbiAgICAgICAgcmVzLnB1c2goLi4ucmVzX2l0ZW0uZGF0YSlcclxuICAgICAgfSlcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgbmV3IE5vdGljZShgQ2Fubm90IGdldCBjb21taXRzXFxuJHt1cmwudmFsdWV9YClcclxuICAgIH1cclxuICAgIHJldHVybiByZXNcclxuICB9XHJcbiAgYXN5bmMgZ2V0X2FsbF9jb21taXRzKCkge1xyXG4gICAgY29uc3QgdXJsID0gdGhpcy51cmwuY29tbWl0cygpXHJcbiAgICAgIC5hZGQoJ3dpdGhfc3RhdHMnLCAndHJ1ZScpXHJcbiAgICAgIC5hZGQoJ3JlZl9uYW1lJywgdGhpcy5vcHRpb25zLmJyYW5jaClcclxuICAgICAgLmFkZCgnYWxsJywgJ3RydWUnKVxyXG5cclxuICAgIGNvbnN0IHJlczogYW55W10gPSBbXVxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgdGhpcy5wYWdpbmF0aW9uKDEsIHVybCwgKHJlc19pdGVtKSA9PiB7XHJcbiAgICAgICAgcmVzLnB1c2goLi4ucmVzX2l0ZW0uZGF0YSlcclxuICAgICAgfSlcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgbmV3IE5vdGljZShgQ2Fubm90IGdldCBjb21taXRzXFxuJHt1cmwudmFsdWV9YClcclxuICAgIH1cclxuICAgIHJldHVybiByZXNcclxuICB9XHJcbiAgYXN5bmMgZ2V0X21ldGFfZGF0YV9maWxlKHBhdGg6IHN0cmluZykge1xyXG4gICAgY29uc3QgdXJsID0gdGhpcy51cmwuZmlsZXMoKS5iYXNlKGAvJHt1cmxzbGFzaChwYXRoKX1gKVxyXG4gICAgICAuYWRkKCdyZWYnLCB0aGlzLm9wdGlvbnMuYnJhbmNoKVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBhd2FpdCBheGlvcy5oZWFkKHVybC52YWx1ZSwge1xyXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyKCksXHJcbiAgICAgIH0pXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIG5ldyBOb3RpY2UoYENhbm5vdCBnZXQgZmlsZSBoZWFkZXJcXG4ke3VybC52YWx1ZX1gKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGxcclxuICB9XHJcbiAgYXN5bmMgcGFnaW5hdGlvbihzdGFydF9wYWdlOiBudW1iZXIsIHVybDogRXhVcmwsIGNhbGxiYWNrOiAocmVzOiBhbnkpID0+IHZvaWQsIHBlcl9wYWdlOiBudW1iZXIgPSAxMDApIHtcclxuICAgIGNvbnN0IHBhZ2VfdXJsID0gdXJsLmFkZCgncGVyX3BhZ2UnLCBwZXJfcGFnZS50b1N0cmluZygpKS5hZGQoJ3BhZ2UnLCBzdGFydF9wYWdlLnRvU3RyaW5nKCkpXHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBheGlvcy5nZXQocGFnZV91cmwudmFsdWUsIHsgaGVhZGVyczogdGhpcy5oZWFkZXIoKSB9KVxyXG4gICAgaWYgKHJlcy5kYXRhPy5sZW5ndGggPT0gMCkgcmV0dXJuXHJcbiAgICBhd2FpdCBjYWxsYmFjayhyZXMpXHJcbiAgICBhd2FpdCB0aGlzLnBhZ2luYXRpb24oc3RhcnRfcGFnZSArIDEsIHVybCwgY2FsbGJhY2ssIHBlcl9wYWdlKVxyXG4gIH1cclxuICBhc3luYyBibGFtZShwYXRoOnN0cmluZyl7XHJcbiAgICBjb25zdCB1cmwgPSB0aGlzLnVybC5maWxlcygpXHJcbiAgICAuYmFzZShgLyR7dXJsc2xhc2gocGF0aCl9L2JsYW1lYClcclxuICAgIC5hZGQoJ3JlZicsIHRoaXMub3B0aW9ucy5icmFuY2gpXHJcbiAgICAudmFsdWVcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGF4aW9zLmdldCh1cmwsIHtcclxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcigpLFxyXG4gICAgICB9KVxyXG4gICAgICByZXR1cm4gcmVzLmRhdGFcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICB9XHJcbiAgYXN5bmMgZ2V0X2RpZmZzKGNvbW1pdF9pZDogc3RyaW5nKSB7XHJcbiAgICBjb25zdCB1cmwgPSB0aGlzLnVybC5jb21taXRzKClcclxuICAgICAgLmJhc2UoYC8ke2NvbW1pdF9pZH0vZGlmZmApXHJcbiAgICAgIC52YWx1ZVxyXG4gICAgbGV0IHJlcyA9IG51bGxcclxuICAgIHRyeSB7XHJcbiAgICAgIHJlcyA9IGF3YWl0IGF4aW9zLmdldCh1cmwsIHsgaGVhZGVyczogdGhpcy5oZWFkZXIoKSB9KVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBuZXcgTm90aWNlKGBDYW5ub3QgZ2V0IGRpZmYgZnJvbSBjb21taXQgJHtjb21taXRfaWR9YClcclxuICAgIH1cclxuICAgIHJldHVybiByZXNcclxuICB9XHJcbiAgYXN5bmMgY3JlYXRlKHBhdGg6IHN0cmluZywgY29tbWl0OiBHaXRMYWJDb21taXRPcHRpb25zID0ge30sIG5vdGlmaWNhdGlvbnM6IGJvb2xlYW4gPSB0cnVlLCB1cGRhdGVfaWZfZXhpc3Q6IGJvb2xlYW4gPSB0cnVlKSB7XHJcbiAgICBjb25zdCBmaWxlX2NvbnRlbnQgPSBhd2FpdCB0aGlzLmdldF9sb2NhbF9maWxlX2NvbnRlbnQocGF0aClcclxuXHJcbiAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICBicmFuY2g6IGNvbW1pdC5icmFuY2ggfHwgdGhpcy5vcHRpb25zLmJyYW5jaCxcclxuICAgICAgZW5jb2Rpbmc6IGNvbW1pdC5lbmNvZGluZyB8fCAnYmFzZTY0JyxcclxuICAgICAgYXV0aG9yX2VtYWlsOiBjb21taXQuYXV0aG9yX2VtYWlsIHx8IHRoaXMub3B0aW9ucy5lbWFpbCxcclxuICAgICAgYXV0aG9yX25hbWU6IGNvbW1pdC5hdXRob3JfbmFtZSB8fCB0aGlzLm9wdGlvbnMubmljayxcclxuICAgICAgY29tbWl0X21lc3NhZ2U6IGNvbW1pdC5jb21taXRfbWVzc2FnZSB8fCAnY3JlYXRlZCBmaWxlJyxcclxuICAgICAgY29udGVudDogZmlsZV9jb250ZW50LFxyXG4gICAgfVxyXG4gICAgY29uc3QgZmlsZV91cmwgPSBgJHt0aGlzLm9wdGlvbnMuYXBpfS9wcm9qZWN0cy8ke3RoaXMuaWQoKX0vcmVwb3NpdG9yeS9maWxlcy8ke3VybHNsYXNoKHBhdGgpfT9yZWY9JHtkYXRhLmJyYW5jaH1gXHJcbiAgICBsZXQgcmVzID0gbnVsbFxyXG4gICAgdHJ5IHtcclxuICAgICAgcmVzID0gYXdhaXQgYXhpb3MucG9zdChcclxuICAgICAgICBmaWxlX3VybCxcclxuICAgICAgICBkYXRhLCB7XHJcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXIoKSxcclxuICAgICAgfSlcclxuICAgICAgc3luY19sb2dzLmxvZyhgY3JlYXRpbmcgZmlsZSBcIiR7cGF0aH1cImApXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHN5bmNfbG9ncy5sb2coYEZBSUw6IGNyZWF0aW5nIGZpbGUgXCIke3BhdGh9XCJgKVxyXG4gICAgICBpZiAodXBkYXRlX2lmX2V4aXN0KVxyXG4gICAgICAgIGlmIChub3RpZmljYXRpb25zICYmIHRoaXMub3B0aW9ucy5ub3RpZmljYXRpb25zKVxyXG4gICAgICAgICAgbmV3IE5vdGljZSgnQ2Fubm90IGNyZWF0ZSBmaWxlXFxuVHJ5aW5nIHVwZGF0ZSBmaWxlJylcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCB0aGlzLm1vZGlmeShwYXRoLCBjb21taXQsIG5vdGlmaWNhdGlvbnMsIGZhbHNlKVxyXG4gICAgICB9IGNhdGNoIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vdGlmaWNhdGlvbnMpXHJcbiAgICAgICAgICBuZXcgTm90aWNlKCdDYW5ub3QgdXBkYXRlIGZpbGUnKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfVxyXG4gIGFzeW5jIG1vZGlmeShwYXRoOiBzdHJpbmcsIGNvbW1pdDogR2l0TGFiQ29tbWl0T3B0aW9ucyA9IHt9LCBub3RpZmljYXRpb25zOiBib29sZWFuID0gdHJ1ZSwgY3JlYXRlX2lmX25vdF9leGlzdDogYm9vbGVhbiA9IHRydWUpIHtcclxuICAgIGNvbnN0IGZpbGVfY29udGVudCA9IGF3YWl0IHRoaXMuZ2V0X2xvY2FsX2ZpbGVfY29udGVudChwYXRoKVxyXG4gICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgYnJhbmNoOiBjb21taXQuYnJhbmNoIHx8IHRoaXMub3B0aW9ucy5icmFuY2gsXHJcbiAgICAgIGVuY29kaW5nOiBjb21taXQuZW5jb2RpbmcgfHwgJ2Jhc2U2NCcsXHJcbiAgICAgIGF1dGhvcl9lbWFpbDogY29tbWl0LmF1dGhvcl9lbWFpbCB8fCB0aGlzLm9wdGlvbnMuZW1haWwsXHJcbiAgICAgIGF1dGhvcl9uYW1lOiBjb21taXQuYXV0aG9yX25hbWUgfHwgdGhpcy5vcHRpb25zLm5pY2ssXHJcbiAgICAgIGNvbW1pdF9tZXNzYWdlOiBjb21taXQuY29tbWl0X21lc3NhZ2UgfHwgJ21vZGlmaWVkIGZpbGUnLFxyXG4gICAgICBjb250ZW50OiBmaWxlX2NvbnRlbnQsXHJcbiAgICB9XHJcbiAgICBjb25zdCBmaWxlX3VybCA9IGAke3RoaXMub3B0aW9ucy5hcGl9L3Byb2plY3RzLyR7dGhpcy5pZCgpfS9yZXBvc2l0b3J5L2ZpbGVzLyR7dXJsc2xhc2gocGF0aCl9P3JlZj0ke2RhdGEuYnJhbmNofWBcclxuICAgIGxldCByZXMgPSBudWxsXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgcmVzID0gYXdhaXQgYXhpb3MucHV0KFxyXG4gICAgICAgIGZpbGVfdXJsLFxyXG4gICAgICAgIGRhdGEsIHtcclxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcigpLFxyXG4gICAgICB9KVxyXG4gICAgICBzeW5jX2xvZ3MubG9nKGBtb2RpZnlpbmcgZmlsZSBcIiR7cGF0aH1cImApXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHN5bmNfbG9ncy5sb2coYEZBSUw6IG1vZGlmeWluZyBmaWxlIFwiJHtwYXRofVwiYClcclxuICAgICAgaWYgKGNyZWF0ZV9pZl9ub3RfZXhpc3QpXHJcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbnMgJiYgdGhpcy5vcHRpb25zLm5vdGlmaWNhdGlvbnMpXHJcbiAgICAgICAgICBuZXcgTm90aWNlKCdDYW5ub3QgdXBkYXRlIGZpbGVcXG5UcnlpbmcgY3JlYXRlIGZpbGUnKVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlKHBhdGgsIGNvbW1pdCwgbm90aWZpY2F0aW9ucywgZmFsc2UpXHJcbiAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm90aWZpY2F0aW9ucylcclxuICAgICAgICAgIG5ldyBOb3RpY2UoJ0Nhbm5vdCBjcmVhdGUgZmlsZScpXHJcbiAgICAgIH1cclxuXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfVxyXG4gIGFzeW5jIGRlbGV0ZShwYXRoOiBzdHJpbmcsIGNvbW1pdDogR2l0TGFiQ29tbWl0T3B0aW9ucyA9IHt9LCBub3RpZmljYXRpb25zOiBib29sZWFuID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgYnJhbmNoOiBjb21taXQuYnJhbmNoIHx8IHRoaXMub3B0aW9ucy5icmFuY2gsXHJcbiAgICAgIGF1dGhvcl9lbWFpbDogY29tbWl0LmF1dGhvcl9lbWFpbCB8fCB0aGlzLm9wdGlvbnMuZW1haWwsXHJcbiAgICAgIGF1dGhvcl9uYW1lOiBjb21taXQuYXV0aG9yX25hbWUgfHwgdGhpcy5vcHRpb25zLm5pY2ssXHJcbiAgICAgIGNvbW1pdF9tZXNzYWdlOiBjb21taXQuY29tbWl0X21lc3NhZ2UgfHwgJ2RlbGV0ZWQgZmlsZScsXHJcbiAgICB9XHJcbiAgICBjb25zdCBmaWxlX3VybCA9IGAke3RoaXMub3B0aW9ucy5hcGl9L3Byb2plY3RzLyR7dGhpcy5pZCgpfS9yZXBvc2l0b3J5L2ZpbGVzLyR7dXJsc2xhc2gocGF0aCl9P3JlZj0ke2RhdGEuYnJhbmNofWBcclxuICAgIGxldCByZXMgPSBudWxsXHJcbiAgICB0cnkge1xyXG4gICAgICByZXMgPSBhd2FpdCBheGlvcyh7XHJcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgICB1cmw6IGZpbGVfdXJsLFxyXG4gICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXIoKVxyXG4gICAgICB9KVxyXG4gICAgICBzeW5jX2xvZ3MubG9nKGBkZWxldGluZyBmaWxlIFwiJHtwYXRofVwiYClcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgc3luY19sb2dzLmxvZyhgRkFJTDogZGVsZXRpbmcgZmlsZSBcIiR7cGF0aH1cImApXHJcbiAgICAgIGlmIChub3RpZmljYXRpb25zICYmIHRoaXMub3B0aW9ucy5ub3RpZmljYXRpb25zKVxyXG4gICAgICAgIG5ldyBOb3RpY2UoJ0Nhbm5vdCBkZWxldGUgZmlsZScpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbiAgfVxyXG4gIGFzeW5jIHJlbmFtZShwYXRoOiBzdHJpbmcsIG9sZF9wYXRoOiBzdHJpbmcsIGNvbW1pdDogR2l0TGFiQ29tbWl0T3B0aW9ucyA9IHt9LCBub3RpZmljYXRpb25zOiBib29sZWFuID0gdHJ1ZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgdGhpcy5jcmVhdGUocGF0aCwgY29tbWl0LCBub3RpZmljYXRpb25zKVxyXG4gICAgICBhd2FpdCB0aGlzLmRlbGV0ZShvbGRfcGF0aCwgY29tbWl0LCBub3RpZmljYXRpb25zKVxyXG4gICAgICBzeW5jX2xvZ3MubG9nKGByZW5hbWluZyBmaWxlIFwiJHtvbGRfcGF0aH1cIiAtPiBcIiR7cGF0aH1cImApXHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgc3luY19sb2dzLmxvZyhgRkFJTDogcmVuYW1pbmcgZmlsZSBcIiR7b2xkX3BhdGh9XCIgLT4gXCIke3BhdGh9XCJgKVxyXG4gICAgfVxyXG4gIH1cclxuICBhc3luYyByZWFkKHBhdGg6IHN0cmluZywgYnJhbmNoOiBzdHJpbmcgPSB0aGlzLm9wdGlvbnMuYnJhbmNoKSB7XHJcbiAgICBjb25zdCBmaWxlX3VybCA9IGAke3RoaXMub3B0aW9ucy5hcGl9L3Byb2plY3RzLyR7dGhpcy5pZCgpfS9yZXBvc2l0b3J5L2ZpbGVzLyR7dXJsc2xhc2gocGF0aCl9P3JlZj0ke2JyYW5jaH1gXHJcbiAgICBsZXQgcmVzID0gbnVsbFxyXG4gICAgdHJ5IHtcclxuICAgICAgcmVzID0gYXdhaXQgYXhpb3MuZ2V0KFxyXG4gICAgICAgIGZpbGVfdXJsLCB7XHJcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXIoKSxcclxuICAgICAgfSlcclxuICAgICAgc3luY19sb2dzLmxvZyhgcmVhZGluZyBmaWxlIFwiJHtwYXRofVwiYClcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgc3luY19sb2dzLmxvZyhgRkFJTDogcmVhZGluZyBmaWxlIFwiJHtwYXRofVwiYClcclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub3RpZmljYXRpb25zKVxyXG4gICAgICAgIG5ldyBOb3RpY2UoJ0Nhbm5vdCByZWFkIGZpbGUnKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc1xyXG4gIH1cclxuICBhc3luYyByZWFkX3JlcG9fdHJlZShwYXRoOiBzdHJpbmcgPSAnJywgZGVwdGg6IG51bWJlciA9IDAsIGRlcHRoX2xpbWl0OiBudW1iZXIgPSAtMSwgbm90aWZpY2F0aW9uczogYm9vbGVhbiA9IHRydWUpIHtcclxuICAgIGNvbnN0IHVybCA9IGV4dXJsKGAke3RoaXMub3B0aW9ucy5hcGl9L3Byb2plY3RzLyR7dGhpcy5pZCgpfS9yZXBvc2l0b3J5L3RyZWVgKVxyXG4gICAgICAuYWRkKCdwYXRoJywgdXJsc2xhc2gocGF0aCkpXHJcbiAgICAgIC5hZGQoJ3JlZicsIHRoaXMub3B0aW9ucy5icmFuY2gpXHJcbiAgICAgIC5hZGQoJ3JlY3Vyc2l2ZScsICd0cnVlJylcclxuXHJcbiAgICBjb25zdCB0cmVlOiBzdHJpbmdbXVtdID0gW11cclxuICAgIGNvbnN0IHBhZ2VzOiBhbnlbXSA9IFtdXHJcbiAgICBhd2FpdCB0aGlzLnBhZ2luYXRpb24oMSwgdXJsLCAocmVzKSA9PiB7XHJcbiAgICAgIHBhZ2VzLnB1c2goLi4ucmVzLmRhdGEpXHJcbiAgICB9KVxyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHBhZ2VzKSB7XHJcbiAgICAgIHRyZWUucHVzaChbaXRlbS5pZCwgaXRlbS5wYXRoLCBpdGVtLnR5cGUgPT0gJ3RyZWUnXSlcclxuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubm90aWZpY2F0aW9ucyAmJiBub3RpZmljYXRpb25zICYmIGl0ZW0udHlwZSA9PSAndHJlZScpXHJcbiAgICAgICAgbmV3IE5vdGljZShgRmV0Y2hpbmc6IFwiJHtpdGVtLnBhdGh9XCJgKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyZWVcclxuICB9XHJcbiAgc25pcHBldCh0aXRsZTogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nID0gJycsIHZpc2liaWxpdHk6IHN0cmluZyA9ICdwcml2YXRlJykge1xyXG4gICAgY29uc3Qgc25pcHBldCA9IG5ldyBHaXRMYWJBUElTbmlwcGV0KHRoaXMpXHJcbiAgICBzbmlwcGV0Lm1ldGFkYXRhKHsgdGl0bGUsIGRlc2NyaXB0aW9uLCB2aXNpYmlsaXR5IH0pXHJcbiAgICByZXR1cm4gc25pcHBldFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEdpdExhYkFQSVNuaXBwZXQgZXh0ZW5kcyBHaXRMYWJBUEkge1xyXG4gIHNuaXBwZXRfaWQ6IHN0cmluZ1xyXG4gIHRpdGxlOiBzdHJpbmdcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nXHJcbiAgdmlzaWJpbGl0eTogc3RyaW5nXHJcbiAgc3luYzogYm9vbGVhbiA9IGZhbHNlXHJcbiAgZmlsZXM6IEdpdExhYlNuaXBwZXRGaWxlW10gPSBbXVxyXG4gIGNvbnN0cnVjdG9yKGdpdGxhYjogR2l0TGFiQVBJKSB7XHJcbiAgICBzdXBlcigpXHJcbiAgICB0aGlzLnNldG9wdGlvbnMoZ2l0bGFiLm9wdGlvbnMpXHJcbiAgfVxyXG4gIGJvZHkoKTogR2l0TGFiU25pcHBldERvYyB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0aXRsZTogdGhpcy50aXRsZSxcclxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXHJcbiAgICAgIHZpc2liaWxpdHk6IHRoaXMudmlzaWJpbGl0eSxcclxuICAgICAgZmlsZXM6IFtdLFxyXG4gICAgfVxyXG4gIH1cclxuICBtZXRhZGF0YShzbmlwcGV0OiBhbnkpIHtcclxuICAgIHRoaXMudGl0bGUgPSBzbmlwcGV0LnRpdGxlXHJcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gc25pcHBldC5kZXNjcmlwdGlvblxyXG4gICAgdGhpcy52aXNpYmlsaXR5ID0gc25pcHBldC52aXNpYmlsaXR5XHJcbiAgfVxyXG4gIGFzeW5jIGFkZF9maWxlcyguLi5maWxlczogR2l0TGFiU25pcHBldEZpbGVbXSkge1xyXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XHJcbiAgICAgIGZpbGUuYWN0aW9uID0gZmlsZS5hY3Rpb24gfHwgXCJjcmVhdGVcIlxyXG4gICAgICB0aGlzLmZpbGVzLnB1c2goZmlsZSlcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnN5bmMpIHtcclxuICAgICAgaWYgKHRoaXMuc25pcHBldF9pZClcclxuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZV9zbmlwcGV0KHsgZmlsZXM6IGZpbGVzIH0pXHJcbiAgICAgIGVsc2VcclxuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZV9zbmlwcGV0KHsgZmlsZXM6IGZpbGVzIH0pXHJcbiAgICB9XHJcbiAgfVxyXG4gIGFzeW5jIHVwZGF0ZV9maWxlcyguLi5maWxlczogR2l0TGFiU25pcHBldEZpbGVbXSkge1xyXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XHJcbiAgICAgIGZpbGUuYWN0aW9uID0gZmlsZS5hY3Rpb24gfHwgXCJ1cGRhdGVcIlxyXG4gICAgICBpZiAoISFmaWxlLnByZXZpb3VzX3BhdGgpXHJcbiAgICAgICAgZmlsZS5hY3Rpb24gPSAnbW92ZSdcclxuXHJcbiAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuZmlsZXMpIHtcclxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5maWxlc1tpbmRleF1cclxuICAgICAgICBpZiAoZmlsZS5maWxlX3BhdGggPT0gaXRlbS5maWxlX3BhdGggfHwgZmlsZS5wcmV2aW91c19wYXRoID09IGl0ZW0uZmlsZV9wYXRoKVxyXG4gICAgICAgICAgdGhpcy5maWxlc1tpbmRleF0gPSBmaWxlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLnN5bmMpXHJcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlX3NuaXBwZXQoeyBmaWxlczogZmlsZXMgfSlcclxuICB9XHJcbiAgYXN5bmMgcmVtb3ZlX2ZpbGVzKC4uLmZpbGVzOiBHaXRMYWJTbmlwcGV0RmlsZU9wdGlvbmFsW10pIHtcclxuICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xyXG4gICAgICBmaWxlLmFjdGlvbiA9ICdkZWxldGUnXHJcbiAgICAgIGlmICghZmlsZS5maWxlX3BhdGgpIGNvbnRpbnVlXHJcbiAgICAgIGZpbGUuY29udGVudCA9ICcnXHJcbiAgICAgIGZpbGUucHJldmlvdXNfcGF0aCA9ICcnXHJcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmZpbGVzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmZpbGVzW2luZGV4XVxyXG4gICAgICAgIGlmIChmaWxlLmZpbGVfcGF0aCA9PSBpdGVtLmZpbGVfcGF0aCB8fCBmaWxlLnByZXZpb3VzX3BhdGggPT0gaXRlbS5maWxlX3BhdGgpXHJcbiAgICAgICAgICB0aGlzLmZpbGVzLnNwbGljZShpbmRleCwgMSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuc3luYylcclxuICAgICAgYXdhaXQgdGhpcy51cGRhdGVfc25pcHBldCh7IGZpbGVzOiBmaWxlcyBhcyBHaXRMYWJTbmlwcGV0RmlsZVtdIH0pXHJcbiAgfVxyXG4gIGFzeW5jIGZyb21faWQoaWQ6IHN0cmluZykge1xyXG4gICAgY29uc3Qgc25pcHBldCA9IGF3YWl0IGF4aW9zLmdldChcclxuICAgICAgYCR7dGhpcy5vcHRpb25zLmFwaX0vcHJvamVjdHMvJHt0aGlzLmlkKCl9L3NuaXBwZXRzLyR7aWR9YCxcclxuICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcigpIH0pXHJcbiAgICBjb25zb2xlLmxvZyhzbmlwcGV0KVxyXG4gICAgaWYgKHNuaXBwZXQgJiYgc25pcHBldC5kYXRhKSB7XHJcbiAgICAgIHRoaXMuc25pcHBldF9pZCA9IGlkXHJcbiAgICAgIHRoaXMudGl0bGUgPSBzbmlwcGV0LmRhdGEudGl0bGVcclxuICAgIH1cclxuICAgIHJldHVybiBzbmlwcGV0LmRhdGFcclxuICB9XHJcbiAgYXN5bmMgY3JlYXRlX3NuaXBwZXQoYm9keTogR2l0TGFiU25pcHBldERvY09wdGlvbmFsID0ge30pIHtcclxuICAgIGNvbnN0IGNyZWF0ZSA9IGF3YWl0IGF4aW9zLnBvc3QoXHJcbiAgICAgIGAke3RoaXMub3B0aW9ucy5hcGl9L3Byb2plY3RzLyR7dGhpcy5pZCgpfS9zbmlwcGV0c2AsXHJcbiAgICAgIHsgLi4udGhpcy5ib2R5KCksIC4uLmJvZHkgfSxcclxuICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcigpIH0pXHJcbiAgICB0aGlzLnNuaXBwZXRfaWQgPSBjcmVhdGUuZGF0YS5pZFxyXG4gIH1cclxuICBhc3luYyB1cGRhdGVfc25pcHBldChib2R5OiBHaXRMYWJTbmlwcGV0RG9jT3B0aW9uYWwgPSB7fSkge1xyXG4gICAgaWYgKCF0aGlzLnNuaXBwZXRfaWQpIHJldHVyblxyXG4gICAgYXdhaXQgYXhpb3MucHV0KFxyXG4gICAgICBgJHt0aGlzLm9wdGlvbnMuYXBpfS9wcm9qZWN0cy8ke3RoaXMuaWQoKX0vc25pcHBldHMvJHt0aGlzLnNuaXBwZXRfaWR9YCxcclxuICAgICAgeyAuLi50aGlzLmJvZHkoKSwgLi4uYm9keSB9LFxyXG4gICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVyKCkgfSlcclxuICB9XHJcbiAgYXN5bmMgZGVsZXRlX3NuaXBwZXQoKSB7XHJcbiAgICBpZiAoIXRoaXMuc25pcHBldF9pZCkgcmV0dXJuXHJcbiAgICByZXR1cm4gYXdhaXQgYXhpb3MuZGVsZXRlKFxyXG4gICAgICBgJHt0aGlzLm9wdGlvbnMuYXBpfS9wcm9qZWN0cy8ke3RoaXMuaWQoKX0vc25pcHBldHMvJHt0aGlzLnNuaXBwZXRfaWR9YCxcclxuICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcigpIH0pXHJcbiAgfVxyXG4gIGFzeW5jIGdldF9maWxlKHBhdGg6IHN0cmluZykge1xyXG4gICAgaWYgKCF0aGlzLnNuaXBwZXRfaWQpIHJldHVyblxyXG4gICAgLy8gVE9ETyBtYWluIC0gOnJlZiAtPiBkZWZhdWx0IGdpdGxhYiBicmFuY2ggZm9yIGFsbCBzbmlwcGV0XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBheGlvcy5nZXQoXHJcbiAgICAgIGAke3RoaXMub3B0aW9ucy5hcGl9L3Byb2plY3RzLyR7dGhpcy5pZCgpfS9zbmlwcGV0cy8ke3RoaXMuc25pcHBldF9pZH0vZmlsZXMvbWFpbi8ke3VybHNsYXNoKHBhdGgpfS9yYXdgLFxyXG4gICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVyKCkgfSlcclxuXHJcbiAgICBjb25zdCBjb250ZW50ID0gcmVzLmRhdGFcclxuXHJcbiAgICBmb3IgKGxldCBmaWxlIG9mIHRoaXMuZmlsZXMpIHtcclxuICAgICAgaWYgKGZpbGUuZmlsZV9wYXRoID09IHBhdGggfHwgZmlsZS5wcmV2aW91c19wYXRoID09IHBhdGgpXHJcbiAgICAgICAgZmlsZS5jb250ZW50ID0gY29udGVudFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb250ZW50XHJcbiAgfVxyXG4gIGFzeW5jIGdldF9zbmlwcGV0KCkge1xyXG4gICAgaWYgKCF0aGlzLnNuaXBwZXRfaWQpIHJldHVyblxyXG4gICAgcmV0dXJuIGF3YWl0IGF4aW9zLmdldChcclxuICAgICAgYCR7dGhpcy5vcHRpb25zLmFwaX0vcHJvamVjdHMvJHt0aGlzLmlkKCl9L3NuaXBwZXRzLyR7dGhpcy5zbmlwcGV0X2lkfS9yYXdgLFxyXG4gICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVyKCkgfSlcclxuICB9XHJcbn0iLCAiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGJpbmQgZnJvbSAnLi9oZWxwZXJzL2JpbmQuanMnO1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG5jb25zdCB7dG9TdHJpbmd9ID0gT2JqZWN0LnByb3RvdHlwZTtcbmNvbnN0IHtnZXRQcm90b3R5cGVPZn0gPSBPYmplY3Q7XG5cbmNvbnN0IGtpbmRPZiA9IChjYWNoZSA9PiB0aGluZyA9PiB7XG4gICAgY29uc3Qgc3RyID0gdG9TdHJpbmcuY2FsbCh0aGluZyk7XG4gICAgcmV0dXJuIGNhY2hlW3N0cl0gfHwgKGNhY2hlW3N0cl0gPSBzdHIuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkpO1xufSkoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbmNvbnN0IGtpbmRPZlRlc3QgPSAodHlwZSkgPT4ge1xuICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKHRoaW5nKSA9PiBraW5kT2YodGhpbmcpID09PSB0eXBlXG59XG5cbmNvbnN0IHR5cGVPZlRlc3QgPSB0eXBlID0+IHRoaW5nID0+IHR5cGVvZiB0aGluZyA9PT0gdHlwZTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IHtpc0FycmF5fSA9IEFycmF5O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzVW5kZWZpbmVkID0gdHlwZU9mVGVzdCgndW5kZWZpbmVkJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgaXNGdW5jdGlvbih2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIpICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQXJyYXlCdWZmZXIgPSBraW5kT2ZUZXN0KCdBcnJheUJ1ZmZlcicpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAoaXNBcnJheUJ1ZmZlcih2YWwuYnVmZmVyKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1N0cmluZyA9IHR5cGVPZlRlc3QoJ3N0cmluZycpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRnVuY3Rpb24gPSB0eXBlT2ZUZXN0KCdmdW5jdGlvbicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzTnVtYmVyID0gdHlwZU9mVGVzdCgnbnVtYmVyJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzT2JqZWN0ID0gKHRoaW5nKSA9PiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQm9vbGVhblxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQm9vbGVhbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQm9vbGVhbiA9IHRoaW5nID0+IHRoaW5nID09PSB0cnVlIHx8IHRoaW5nID09PSBmYWxzZTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4ge1xuICBpZiAoa2luZE9mKHZhbCkgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIChwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpID09PSBudWxsKSAmJiAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWwpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0RhdGUgPSBraW5kT2ZUZXN0KCdEYXRlJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0ZpbGUgPSBraW5kT2ZUZXN0KCdGaWxlJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Jsb2IgPSBraW5kT2ZUZXN0KCdCbG9iJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlTGlzdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlTGlzdCA9IGtpbmRPZlRlc3QoJ0ZpbGVMaXN0Jyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNTdHJlYW0gPSAodmFsKSA9PiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Zvcm1EYXRhID0gKHRoaW5nKSA9PiB7XG4gIGxldCBraW5kO1xuICByZXR1cm4gdGhpbmcgJiYgKFxuICAgICh0eXBlb2YgRm9ybURhdGEgPT09ICdmdW5jdGlvbicgJiYgdGhpbmcgaW5zdGFuY2VvZiBGb3JtRGF0YSkgfHwgKFxuICAgICAgaXNGdW5jdGlvbih0aGluZy5hcHBlbmQpICYmIChcbiAgICAgICAgKGtpbmQgPSBraW5kT2YodGhpbmcpKSA9PT0gJ2Zvcm1kYXRhJyB8fFxuICAgICAgICAvLyBkZXRlY3QgZm9ybS1kYXRhIGluc3RhbmNlXG4gICAgICAgIChraW5kID09PSAnb2JqZWN0JyAmJiBpc0Z1bmN0aW9uKHRoaW5nLnRvU3RyaW5nKSAmJiB0aGluZy50b1N0cmluZygpID09PSAnW29iamVjdCBGb3JtRGF0YV0nKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNVUkxTZWFyY2hQYXJhbXMgPSBraW5kT2ZUZXN0KCdVUkxTZWFyY2hQYXJhbXMnKTtcblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuY29uc3QgdHJpbSA9IChzdHIpID0+IHN0ci50cmltID9cbiAgc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbYWxsT3duS2V5cyA9IGZhbHNlXVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuLCB7YWxsT3duS2V5cyA9IGZhbHNlfSA9IHt9KSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGk7XG4gIGxldCBsO1xuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yIChpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBjb25zdCBrZXlzID0gYWxsT3duS2V5cyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikgOiBPYmplY3Qua2V5cyhvYmopO1xuICAgIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrZXk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRLZXkob2JqLCBrZXkpIHtcbiAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICBsZXQgX2tleTtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBfa2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoa2V5ID09PSBfa2V5LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIHJldHVybiBfa2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgX2dsb2JhbCA9ICgoKSA9PiB7XG4gIC8qZXNsaW50IG5vLXVuZGVmOjAqL1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBnbG9iYWxUaGlzO1xuICByZXR1cm4gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKVxufSkoKTtcblxuY29uc3QgaXNDb250ZXh0RGVmaW5lZCA9IChjb250ZXh0KSA9PiAhaXNVbmRlZmluZWQoY29udGV4dCkgJiYgY29udGV4dCAhPT0gX2dsb2JhbDtcblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKlxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICBjb25zdCB7Y2FzZWxlc3N9ID0gaXNDb250ZXh0RGVmaW5lZCh0aGlzKSAmJiB0aGlzIHx8IHt9O1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgYXNzaWduVmFsdWUgPSAodmFsLCBrZXkpID0+IHtcbiAgICBjb25zdCB0YXJnZXRLZXkgPSBjYXNlbGVzcyAmJiBmaW5kS2V5KHJlc3VsdCwga2V5KSB8fCBrZXk7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W3RhcmdldEtleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSBtZXJnZShyZXN1bHRbdGFyZ2V0S2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYXJndW1lbnRzW2ldICYmIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXNdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmNvbnN0IGV4dGVuZCA9IChhLCBiLCB0aGlzQXJnLCB7YWxsT3duS2V5c309IHt9KSA9PiB7XG4gIGZvckVhY2goYiwgKHZhbCwga2V5KSA9PiB7XG4gICAgaWYgKHRoaXNBcmcgJiYgaXNGdW5jdGlvbih2YWwpKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0sIHthbGxPd25LZXlzfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5jb25zdCBzdHJpcEJPTSA9IChjb250ZW50KSA9PiB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcHNdXG4gKiBAcGFyYW0ge29iamVjdH0gW2Rlc2NyaXB0b3JzXVxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCBpbmhlcml0cyA9IChjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3RvciwgcHJvcHMsIGRlc2NyaXB0b3JzKSA9PiB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGRlc2NyaXB0b3JzKTtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ3N1cGVyJywge1xuICAgIHZhbHVlOiBzdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZVxuICB9KTtcbiAgcHJvcHMgJiYgT2JqZWN0LmFzc2lnbihjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIG9iamVjdCB3aXRoIGRlZXAgcHJvdG90eXBlIGNoYWluIHRvIGEgZmxhdCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VPYmogc291cmNlIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IFtkZXN0T2JqXVxuICogQHBhcmFtIHtGdW5jdGlvbnxCb29sZWFufSBbZmlsdGVyXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BGaWx0ZXJdXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuY29uc3QgdG9GbGF0T2JqZWN0ID0gKHNvdXJjZU9iaiwgZGVzdE9iaiwgZmlsdGVyLCBwcm9wRmlsdGVyKSA9PiB7XG4gIGxldCBwcm9wcztcbiAgbGV0IGk7XG4gIGxldCBwcm9wO1xuICBjb25zdCBtZXJnZWQgPSB7fTtcblxuICBkZXN0T2JqID0gZGVzdE9iaiB8fCB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gIGlmIChzb3VyY2VPYmogPT0gbnVsbCkgcmV0dXJuIGRlc3RPYmo7XG5cbiAgZG8ge1xuICAgIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlT2JqKTtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAoKCFwcm9wRmlsdGVyIHx8IHByb3BGaWx0ZXIocHJvcCwgc291cmNlT2JqLCBkZXN0T2JqKSkgJiYgIW1lcmdlZFtwcm9wXSkge1xuICAgICAgICBkZXN0T2JqW3Byb3BdID0gc291cmNlT2JqW3Byb3BdO1xuICAgICAgICBtZXJnZWRbcHJvcF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2VPYmogPSBmaWx0ZXIgIT09IGZhbHNlICYmIGdldFByb3RvdHlwZU9mKHNvdXJjZU9iaik7XG4gIH0gd2hpbGUgKHNvdXJjZU9iaiAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoc291cmNlT2JqLCBkZXN0T2JqKSkgJiYgc291cmNlT2JqICE9PSBPYmplY3QucHJvdG90eXBlKTtcblxuICByZXR1cm4gZGVzdE9iajtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgZW5kcyB3aXRoIHRoZSBjaGFyYWN0ZXJzIG9mIGEgc3BlY2lmaWVkIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb249IDBdXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVuZHNXaXRoID0gKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikgPT4ge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPiBzdHIubGVuZ3RoKSB7XG4gICAgcG9zaXRpb24gPSBzdHIubGVuZ3RoO1xuICB9XG4gIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHN0ci5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBuZXcgYXJyYXkgZnJvbSBhcnJheSBsaWtlIG9iamVjdCBvciBudWxsIGlmIGZhaWxlZFxuICpcbiAqIEBwYXJhbSB7Kn0gW3RoaW5nXVxuICpcbiAqIEByZXR1cm5zIHs/QXJyYXl9XG4gKi9cbmNvbnN0IHRvQXJyYXkgPSAodGhpbmcpID0+IHtcbiAgaWYgKCF0aGluZykgcmV0dXJuIG51bGw7XG4gIGlmIChpc0FycmF5KHRoaW5nKSkgcmV0dXJuIHRoaW5nO1xuICBsZXQgaSA9IHRoaW5nLmxlbmd0aDtcbiAgaWYgKCFpc051bWJlcihpKSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGFyciA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBhcnJbaV0gPSB0aGluZ1tpXTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vKipcbiAqIENoZWNraW5nIGlmIHRoZSBVaW50OEFycmF5IGV4aXN0cyBhbmQgaWYgaXQgZG9lcywgaXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZVxuICogdGhpbmcgcGFzc2VkIGluIGlzIGFuIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXlcbiAqXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9XG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuY29uc3QgaXNUeXBlZEFycmF5ID0gKFR5cGVkQXJyYXkgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gdGhpbmcgPT4ge1xuICAgIHJldHVybiBUeXBlZEFycmF5ICYmIHRoaW5nIGluc3RhbmNlb2YgVHlwZWRBcnJheTtcbiAgfTtcbn0pKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBnZXRQcm90b3R5cGVPZihVaW50OEFycmF5KSk7XG5cbi8qKlxuICogRm9yIGVhY2ggZW50cnkgaW4gdGhlIG9iamVjdCwgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB0aGUga2V5IGFuZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdDxhbnksIGFueT59IG9iaiAtIFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBlbnRyeS5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgZm9yRWFjaEVudHJ5ID0gKG9iaiwgZm4pID0+IHtcbiAgY29uc3QgZ2VuZXJhdG9yID0gb2JqICYmIG9ialtTeW1ib2wuaXRlcmF0b3JdO1xuXG4gIGNvbnN0IGl0ZXJhdG9yID0gZ2VuZXJhdG9yLmNhbGwob2JqKTtcblxuICBsZXQgcmVzdWx0O1xuXG4gIHdoaWxlICgocmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpKSAmJiAhcmVzdWx0LmRvbmUpIHtcbiAgICBjb25zdCBwYWlyID0gcmVzdWx0LnZhbHVlO1xuICAgIGZuLmNhbGwob2JqLCBwYWlyWzBdLCBwYWlyWzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcmVndWxhciBleHByZXNzaW9uIGFuZCBhIHN0cmluZywgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBtYXRjaGVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ0V4cCAtIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggYWdhaW5zdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8Ym9vbGVhbj59XG4gKi9cbmNvbnN0IG1hdGNoQWxsID0gKHJlZ0V4cCwgc3RyKSA9PiB7XG4gIGxldCBtYXRjaGVzO1xuICBjb25zdCBhcnIgPSBbXTtcblxuICB3aGlsZSAoKG1hdGNoZXMgPSByZWdFeHAuZXhlYyhzdHIpKSAhPT0gbnVsbCkge1xuICAgIGFyci5wdXNoKG1hdGNoZXMpO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuLyogQ2hlY2tpbmcgaWYgdGhlIGtpbmRPZlRlc3QgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHdoZW4gcGFzc2VkIGFuIEhUTUxGb3JtRWxlbWVudC4gKi9cbmNvbnN0IGlzSFRNTEZvcm0gPSBraW5kT2ZUZXN0KCdIVE1MRm9ybUVsZW1lbnQnKTtcblxuY29uc3QgdG9DYW1lbENhc2UgPSBzdHIgPT4ge1xuICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXFxzXShbYS16XFxkXSkoXFx3KikvZyxcbiAgICBmdW5jdGlvbiByZXBsYWNlcihtLCBwMSwgcDIpIHtcbiAgICAgIHJldHVybiBwMS50b1VwcGVyQ2FzZSgpICsgcDI7XG4gICAgfVxuICApO1xufTtcblxuLyogQ3JlYXRpbmcgYSBmdW5jdGlvbiB0aGF0IHdpbGwgY2hlY2sgaWYgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LiAqL1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSAoKHtoYXNPd25Qcm9wZXJ0eX0pID0+IChvYmosIHByb3ApID0+IGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkoT2JqZWN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1JlZ0V4cCA9IGtpbmRPZlRlc3QoJ1JlZ0V4cCcpO1xuXG5jb25zdCByZWR1Y2VEZXNjcmlwdG9ycyA9IChvYmosIHJlZHVjZXIpID0+IHtcbiAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopO1xuICBjb25zdCByZWR1Y2VkRGVzY3JpcHRvcnMgPSB7fTtcblxuICBmb3JFYWNoKGRlc2NyaXB0b3JzLCAoZGVzY3JpcHRvciwgbmFtZSkgPT4ge1xuICAgIGxldCByZXQ7XG4gICAgaWYgKChyZXQgPSByZWR1Y2VyKGRlc2NyaXB0b3IsIG5hbWUsIG9iaikpICE9PSBmYWxzZSkge1xuICAgICAgcmVkdWNlZERlc2NyaXB0b3JzW25hbWVdID0gcmV0IHx8IGRlc2NyaXB0b3I7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmosIHJlZHVjZWREZXNjcmlwdG9ycyk7XG59XG5cbi8qKlxuICogTWFrZXMgYWxsIG1ldGhvZHMgcmVhZC1vbmx5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuY29uc3QgZnJlZXplTWV0aG9kcyA9IChvYmopID0+IHtcbiAgcmVkdWNlRGVzY3JpcHRvcnMob2JqLCAoZGVzY3JpcHRvciwgbmFtZSkgPT4ge1xuICAgIC8vIHNraXAgcmVzdHJpY3RlZCBwcm9wcyBpbiBzdHJpY3QgbW9kZVxuICAgIGlmIChpc0Z1bmN0aW9uKG9iaikgJiYgWydhcmd1bWVudHMnLCAnY2FsbGVyJywgJ2NhbGxlZSddLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm47XG5cbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBmYWxzZTtcblxuICAgIGlmICgnd3JpdGFibGUnIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICBkZXNjcmlwdG9yLnNldCA9ICgpID0+IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0NhbiBub3QgcmV3cml0ZSByZWFkLW9ubHkgbWV0aG9kIFxcJycgKyBuYW1lICsgJ1xcJycpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCB0b09iamVjdFNldCA9IChhcnJheU9yU3RyaW5nLCBkZWxpbWl0ZXIpID0+IHtcbiAgY29uc3Qgb2JqID0ge307XG5cbiAgY29uc3QgZGVmaW5lID0gKGFycikgPT4ge1xuICAgIGFyci5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgIG9ialt2YWx1ZV0gPSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgaXNBcnJheShhcnJheU9yU3RyaW5nKSA/IGRlZmluZShhcnJheU9yU3RyaW5nKSA6IGRlZmluZShTdHJpbmcoYXJyYXlPclN0cmluZykuc3BsaXQoZGVsaW1pdGVyKSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbmNvbnN0IHRvRmluaXRlTnVtYmVyID0gKHZhbHVlLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbmNvbnN0IEFMUEhBID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6J1xuXG5jb25zdCBESUdJVCA9ICcwMTIzNDU2Nzg5JztcblxuY29uc3QgQUxQSEFCRVQgPSB7XG4gIERJR0lULFxuICBBTFBIQSxcbiAgQUxQSEFfRElHSVQ6IEFMUEhBICsgQUxQSEEudG9VcHBlckNhc2UoKSArIERJR0lUXG59XG5cbmNvbnN0IGdlbmVyYXRlU3RyaW5nID0gKHNpemUgPSAxNiwgYWxwaGFiZXQgPSBBTFBIQUJFVC5BTFBIQV9ESUdJVCkgPT4ge1xuICBsZXQgc3RyID0gJyc7XG4gIGNvbnN0IHtsZW5ndGh9ID0gYWxwaGFiZXQ7XG4gIHdoaWxlIChzaXplLS0pIHtcbiAgICBzdHIgKz0gYWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIGxlbmd0aHwwXVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBJZiB0aGUgdGhpbmcgaXMgYSBGb3JtRGF0YSBvYmplY3QsIHJldHVybiB0cnVlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gdGhpbmcgLSBUaGUgdGhpbmcgdG8gY2hlY2suXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3BlY0NvbXBsaWFudEZvcm0odGhpbmcpIHtcbiAgcmV0dXJuICEhKHRoaW5nICYmIGlzRnVuY3Rpb24odGhpbmcuYXBwZW5kKSAmJiB0aGluZ1tTeW1ib2wudG9TdHJpbmdUYWddID09PSAnRm9ybURhdGEnICYmIHRoaW5nW1N5bWJvbC5pdGVyYXRvcl0pO1xufVxuXG5jb25zdCB0b0pTT05PYmplY3QgPSAob2JqKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IEFycmF5KDEwKTtcblxuICBjb25zdCB2aXNpdCA9IChzb3VyY2UsIGkpID0+IHtcblxuICAgIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICBpZiAoc3RhY2suaW5kZXhPZihzb3VyY2UpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZighKCd0b0pTT04nIGluIHNvdXJjZSkpIHtcbiAgICAgICAgc3RhY2tbaV0gPSBzb3VyY2U7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGlzQXJyYXkoc291cmNlKSA/IFtdIDoge307XG5cbiAgICAgICAgZm9yRWFjaChzb3VyY2UsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVkdWNlZFZhbHVlID0gdmlzaXQodmFsdWUsIGkgKyAxKTtcbiAgICAgICAgICAhaXNVbmRlZmluZWQocmVkdWNlZFZhbHVlKSAmJiAodGFyZ2V0W2tleV0gPSByZWR1Y2VkVmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdGFja1tpXSA9IHVuZGVmaW5lZDtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICByZXR1cm4gdmlzaXQob2JqLCAwKTtcbn1cblxuY29uc3QgaXNBc3luY0ZuID0ga2luZE9mVGVzdCgnQXN5bmNGdW5jdGlvbicpO1xuXG5jb25zdCBpc1RoZW5hYmxlID0gKHRoaW5nKSA9PlxuICB0aGluZyAmJiAoaXNPYmplY3QodGhpbmcpIHx8IGlzRnVuY3Rpb24odGhpbmcpKSAmJiBpc0Z1bmN0aW9uKHRoaW5nLnRoZW4pICYmIGlzRnVuY3Rpb24odGhpbmcuY2F0Y2gpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmcsXG4gIGlzTnVtYmVyLFxuICBpc0Jvb2xlYW4sXG4gIGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlLFxuICBpc0ZpbGUsXG4gIGlzQmxvYixcbiAgaXNSZWdFeHAsXG4gIGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNUeXBlZEFycmF5LFxuICBpc0ZpbGVMaXN0LFxuICBmb3JFYWNoLFxuICBtZXJnZSxcbiAgZXh0ZW5kLFxuICB0cmltLFxuICBzdHJpcEJPTSxcbiAgaW5oZXJpdHMsXG4gIHRvRmxhdE9iamVjdCxcbiAga2luZE9mLFxuICBraW5kT2ZUZXN0LFxuICBlbmRzV2l0aCxcbiAgdG9BcnJheSxcbiAgZm9yRWFjaEVudHJ5LFxuICBtYXRjaEFsbCxcbiAgaXNIVE1MRm9ybSxcbiAgaGFzT3duUHJvcGVydHksXG4gIGhhc093blByb3A6IGhhc093blByb3BlcnR5LCAvLyBhbiBhbGlhcyB0byBhdm9pZCBFU0xpbnQgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIGRldGVjdGlvblxuICByZWR1Y2VEZXNjcmlwdG9ycyxcbiAgZnJlZXplTWV0aG9kcyxcbiAgdG9PYmplY3RTZXQsXG4gIHRvQ2FtZWxDYXNlLFxuICBub29wLFxuICB0b0Zpbml0ZU51bWJlcixcbiAgZmluZEtleSxcbiAgZ2xvYmFsOiBfZ2xvYmFsLFxuICBpc0NvbnRleHREZWZpbmVkLFxuICBBTFBIQUJFVCxcbiAgZ2VuZXJhdGVTdHJpbmcsXG4gIGlzU3BlY0NvbXBsaWFudEZvcm0sXG4gIHRvSlNPTk9iamVjdCxcbiAgaXNBc3luY0ZuLFxuICBpc1RoZW5hYmxlXG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIEF4aW9zRXJyb3IobWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBFcnJvci5jYWxsKHRoaXMpO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICB9XG5cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5uYW1lID0gJ0F4aW9zRXJyb3InO1xuICBjb2RlICYmICh0aGlzLmNvZGUgPSBjb2RlKTtcbiAgY29uZmlnICYmICh0aGlzLmNvbmZpZyA9IGNvbmZpZyk7XG4gIHJlcXVlc3QgJiYgKHRoaXMucmVxdWVzdCA9IHJlcXVlc3QpO1xuICByZXNwb25zZSAmJiAodGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlKTtcbn1cblxudXRpbHMuaW5oZXJpdHMoQXhpb3NFcnJvciwgRXJyb3IsIHtcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdXRpbHMudG9KU09OT2JqZWN0KHRoaXMuY29uZmlnKSxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHN0YXR1czogdGhpcy5yZXNwb25zZSAmJiB0aGlzLnJlc3BvbnNlLnN0YXR1cyA/IHRoaXMucmVzcG9uc2Uuc3RhdHVzIDogbnVsbFxuICAgIH07XG4gIH1cbn0pO1xuXG5jb25zdCBwcm90b3R5cGUgPSBBeGlvc0Vycm9yLnByb3RvdHlwZTtcbmNvbnN0IGRlc2NyaXB0b3JzID0ge307XG5cbltcbiAgJ0VSUl9CQURfT1BUSU9OX1ZBTFVFJyxcbiAgJ0VSUl9CQURfT1BUSU9OJyxcbiAgJ0VDT05OQUJPUlRFRCcsXG4gICdFVElNRURPVVQnLFxuICAnRVJSX05FVFdPUksnLFxuICAnRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUUycsXG4gICdFUlJfREVQUkVDQVRFRCcsXG4gICdFUlJfQkFEX1JFU1BPTlNFJyxcbiAgJ0VSUl9CQURfUkVRVUVTVCcsXG4gICdFUlJfQ0FOQ0VMRUQnLFxuICAnRVJSX05PVF9TVVBQT1JUJyxcbiAgJ0VSUl9JTlZBTElEX1VSTCdcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5dLmZvckVhY2goY29kZSA9PiB7XG4gIGRlc2NyaXB0b3JzW2NvZGVdID0ge3ZhbHVlOiBjb2RlfTtcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBeGlvc0Vycm9yLCBkZXNjcmlwdG9ycyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnaXNBeGlvc0Vycm9yJywge3ZhbHVlOiB0cnVlfSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5BeGlvc0Vycm9yLmZyb20gPSAoZXJyb3IsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UsIGN1c3RvbVByb3BzKSA9PiB7XG4gIGNvbnN0IGF4aW9zRXJyb3IgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG5cbiAgdXRpbHMudG9GbGF0T2JqZWN0KGVycm9yLCBheGlvc0Vycm9yLCBmdW5jdGlvbiBmaWx0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gRXJyb3IucHJvdG90eXBlO1xuICB9LCBwcm9wID0+IHtcbiAgICByZXR1cm4gcHJvcCAhPT0gJ2lzQXhpb3NFcnJvcic7XG4gIH0pO1xuXG4gIEF4aW9zRXJyb3IuY2FsbChheGlvc0Vycm9yLCBlcnJvci5tZXNzYWdlLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlKTtcblxuICBheGlvc0Vycm9yLmNhdXNlID0gZXJyb3I7XG5cbiAgYXhpb3NFcnJvci5uYW1lID0gZXJyb3IubmFtZTtcblxuICBjdXN0b21Qcm9wcyAmJiBPYmplY3QuYXNzaWduKGF4aW9zRXJyb3IsIGN1c3RvbVByb3BzKTtcblxuICByZXR1cm4gYXhpb3NFcnJvcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zRXJyb3I7XG4iLCAiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHN0cmljdFxuZXhwb3J0IGRlZmF1bHQgbnVsbDtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuLy8gdGVtcG9yYXJ5IGhvdGZpeCB0byBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzIHVudGlsIEF4aW9zVVJMU2VhcmNoUGFyYW1zIGlzIHJlZmFjdG9yZWRcbmltcG9ydCBQbGF0Zm9ybUZvcm1EYXRhIGZyb20gJy4uL3BsYXRmb3JtL25vZGUvY2xhc3Nlcy9Gb3JtRGF0YS5qcyc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gdGhpbmcgaXMgYSBhcnJheSBvciBqcyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRoaW5nIC0gVGhlIG9iamVjdCBvciBhcnJheSB0byBiZSB2aXNpdGVkLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Zpc2l0YWJsZSh0aGluZykge1xuICByZXR1cm4gdXRpbHMuaXNQbGFpbk9iamVjdCh0aGluZykgfHwgdXRpbHMuaXNBcnJheSh0aGluZyk7XG59XG5cbi8qKlxuICogSXQgcmVtb3ZlcyB0aGUgYnJhY2tldHMgZnJvbSB0aGUgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIHBhcmFtZXRlci5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUga2V5IHdpdGhvdXQgdGhlIGJyYWNrZXRzLlxuICovXG5mdW5jdGlvbiByZW1vdmVCcmFja2V0cyhrZXkpIHtcbiAgcmV0dXJuIHV0aWxzLmVuZHNXaXRoKGtleSwgJ1tdJykgPyBrZXkuc2xpY2UoMCwgLTIpIDoga2V5O1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcGF0aCwgYSBrZXksIGFuZCBhIGJvb2xlYW4sIGFuZCByZXR1cm5zIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgY3VycmVudCBvYmplY3QgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkb3RzIC0gSWYgdHJ1ZSwgdGhlIGtleSB3aWxsIGJlIHJlbmRlcmVkIHdpdGggZG90cyBpbnN0ZWFkIG9mIGJyYWNrZXRzLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IGtleS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyS2V5KHBhdGgsIGtleSwgZG90cykge1xuICBpZiAoIXBhdGgpIHJldHVybiBrZXk7XG4gIHJldHVybiBwYXRoLmNvbmNhdChrZXkpLm1hcChmdW5jdGlvbiBlYWNoKHRva2VuLCBpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdG9rZW4gPSByZW1vdmVCcmFja2V0cyh0b2tlbik7XG4gICAgcmV0dXJuICFkb3RzICYmIGkgPyAnWycgKyB0b2tlbiArICddJyA6IHRva2VuO1xuICB9KS5qb2luKGRvdHMgPyAnLicgOiAnJyk7XG59XG5cbi8qKlxuICogSWYgdGhlIGFycmF5IGlzIGFuIGFycmF5IGFuZCBub25lIG9mIGl0cyBlbGVtZW50cyBhcmUgdmlzaXRhYmxlLCB0aGVuIGl0J3MgYSBmbGF0IGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyIC0gVGhlIGFycmF5IHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmxhdEFycmF5KGFycikge1xuICByZXR1cm4gdXRpbHMuaXNBcnJheShhcnIpICYmICFhcnIuc29tZShpc1Zpc2l0YWJsZSk7XG59XG5cbmNvbnN0IHByZWRpY2F0ZXMgPSB1dGlscy50b0ZsYXRPYmplY3QodXRpbHMsIHt9LCBudWxsLCBmdW5jdGlvbiBmaWx0ZXIocHJvcCkge1xuICByZXR1cm4gL15pc1tBLVpdLy50ZXN0KHByb3ApO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIGRhdGEgb2JqZWN0IHRvIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHs/T2JqZWN0fSBbZm9ybURhdGFdXG4gKiBAcGFyYW0gez9PYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmlzaXRvcl1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWV0YVRva2VucyA9IHRydWVdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRvdHMgPSBmYWxzZV1cbiAqIEBwYXJhbSB7P0Jvb2xlYW59IFtvcHRpb25zLmluZGV4ZXMgPSBmYWxzZV1cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICoqL1xuXG4vKipcbiAqIEl0IGNvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgRm9ybURhdGEgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgdG8gZm9ybSBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1EYXRhIC0gVGhlIEZvcm1EYXRhIG9iamVjdCB0byBhcHBlbmQgdG8uXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiB0b0Zvcm1EYXRhKG9iaiwgZm9ybURhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgZm9ybURhdGEgPSBmb3JtRGF0YSB8fCBuZXcgKFBsYXRmb3JtRm9ybURhdGEgfHwgRm9ybURhdGEpKCk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIG9wdGlvbnMgPSB1dGlscy50b0ZsYXRPYmplY3Qob3B0aW9ucywge1xuICAgIG1ldGFUb2tlbnM6IHRydWUsXG4gICAgZG90czogZmFsc2UsXG4gICAgaW5kZXhlczogZmFsc2VcbiAgfSwgZmFsc2UsIGZ1bmN0aW9uIGRlZmluZWQob3B0aW9uLCBzb3VyY2UpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgICByZXR1cm4gIXV0aWxzLmlzVW5kZWZpbmVkKHNvdXJjZVtvcHRpb25dKTtcbiAgfSk7XG5cbiAgY29uc3QgbWV0YVRva2VucyA9IG9wdGlvbnMubWV0YVRva2VucztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIGNvbnN0IHZpc2l0b3IgPSBvcHRpb25zLnZpc2l0b3IgfHwgZGVmYXVsdFZpc2l0b3I7XG4gIGNvbnN0IGRvdHMgPSBvcHRpb25zLmRvdHM7XG4gIGNvbnN0IGluZGV4ZXMgPSBvcHRpb25zLmluZGV4ZXM7XG4gIGNvbnN0IF9CbG9iID0gb3B0aW9ucy5CbG9iIHx8IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBCbG9iO1xuICBjb25zdCB1c2VCbG9iID0gX0Jsb2IgJiYgdXRpbHMuaXNTcGVjQ29tcGxpYW50Rm9ybShmb3JtRGF0YSk7XG5cbiAgaWYgKCF1dGlscy5pc0Z1bmN0aW9uKHZpc2l0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmlzaXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuICcnO1xuXG4gICAgaWYgKHV0aWxzLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICghdXNlQmxvYiAmJiB1dGlscy5pc0Jsb2IodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignQmxvYiBpcyBub3Qgc3VwcG9ydGVkLiBVc2UgYSBCdWZmZXIgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHwgdXRpbHMuaXNUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHVzZUJsb2IgJiYgdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicgPyBuZXcgQmxvYihbdmFsdWVdKSA6IEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCB2aXNpdG9yLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0ga2V5XG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nfE51bWJlcj59IHBhdGhcbiAgICogQHRoaXMge0Zvcm1EYXRhfVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJuIHRydWUgdG8gdmlzaXQgdGhlIGVhY2ggcHJvcCBvZiB0aGUgdmFsdWUgcmVjdXJzaXZlbHlcbiAgICovXG4gIGZ1bmN0aW9uIGRlZmF1bHRWaXNpdG9yKHZhbHVlLCBrZXksIHBhdGgpIHtcbiAgICBsZXQgYXJyID0gdmFsdWU7XG5cbiAgICBpZiAodmFsdWUgJiYgIXBhdGggJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHV0aWxzLmVuZHNXaXRoKGtleSwgJ3t9JykpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGtleSA9IG1ldGFUb2tlbnMgPyBrZXkgOiBrZXkuc2xpY2UoMCwgLTIpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAodXRpbHMuaXNBcnJheSh2YWx1ZSkgJiYgaXNGbGF0QXJyYXkodmFsdWUpKSB8fFxuICAgICAgICAoKHV0aWxzLmlzRmlsZUxpc3QodmFsdWUpIHx8IHV0aWxzLmVuZHNXaXRoKGtleSwgJ1tdJykpICYmIChhcnIgPSB1dGlscy50b0FycmF5KHZhbHVlKSlcbiAgICAgICAgKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAga2V5ID0gcmVtb3ZlQnJhY2tldHMoa2V5KTtcblxuICAgICAgICBhcnIuZm9yRWFjaChmdW5jdGlvbiBlYWNoKGVsLCBpbmRleCkge1xuICAgICAgICAgICEodXRpbHMuaXNVbmRlZmluZWQoZWwpIHx8IGVsID09PSBudWxsKSAmJiBmb3JtRGF0YS5hcHBlbmQoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIGluZGV4ZXMgPT09IHRydWUgPyByZW5kZXJLZXkoW2tleV0sIGluZGV4LCBkb3RzKSA6IChpbmRleGVzID09PSBudWxsID8ga2V5IDoga2V5ICsgJ1tdJyksXG4gICAgICAgICAgICBjb252ZXJ0VmFsdWUoZWwpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNWaXNpdGFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3JtRGF0YS5hcHBlbmQocmVuZGVyS2V5KHBhdGgsIGtleSwgZG90cyksIGNvbnZlcnRWYWx1ZSh2YWx1ZSkpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgc3RhY2sgPSBbXTtcblxuICBjb25zdCBleHBvc2VkSGVscGVycyA9IE9iamVjdC5hc3NpZ24ocHJlZGljYXRlcywge1xuICAgIGRlZmF1bHRWaXNpdG9yLFxuICAgIGNvbnZlcnRWYWx1ZSxcbiAgICBpc1Zpc2l0YWJsZVxuICB9KTtcblxuICBmdW5jdGlvbiBidWlsZCh2YWx1ZSwgcGF0aCkge1xuICAgIGlmICh1dGlscy5pc1VuZGVmaW5lZCh2YWx1ZSkpIHJldHVybjtcblxuICAgIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IEVycm9yKCdDaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQgaW4gJyArIHBhdGguam9pbignLicpKTtcbiAgICB9XG5cbiAgICBzdGFjay5wdXNoKHZhbHVlKTtcblxuICAgIHV0aWxzLmZvckVhY2godmFsdWUsIGZ1bmN0aW9uIGVhY2goZWwsIGtleSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gISh1dGlscy5pc1VuZGVmaW5lZChlbCkgfHwgZWwgPT09IG51bGwpICYmIHZpc2l0b3IuY2FsbChcbiAgICAgICAgZm9ybURhdGEsIGVsLCB1dGlscy5pc1N0cmluZyhrZXkpID8ga2V5LnRyaW0oKSA6IGtleSwgcGF0aCwgZXhwb3NlZEhlbHBlcnNcbiAgICAgICk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgYnVpbGQoZWwsIHBhdGggPyBwYXRoLmNvbmNhdChrZXkpIDogW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc3RhY2sucG9wKCk7XG4gIH1cblxuICBpZiAoIXV0aWxzLmlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkYXRhIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICBidWlsZChvYmopO1xuXG4gIHJldHVybiBmb3JtRGF0YTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Gb3JtRGF0YTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4vdG9Gb3JtRGF0YS5qcyc7XG5cbi8qKlxuICogSXQgZW5jb2RlcyBhIHN0cmluZyBieSByZXBsYWNpbmcgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IGluIHRoZSB1bnJlc2VydmVkIHNldCB3aXRoXG4gKiB0aGVpciBwZXJjZW50LWVuY29kZWQgZXF1aXZhbGVudHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGUoc3RyKSB7XG4gIGNvbnN0IGNoYXJNYXAgPSB7XG4gICAgJyEnOiAnJTIxJyxcbiAgICBcIidcIjogJyUyNycsXG4gICAgJygnOiAnJTI4JyxcbiAgICAnKSc6ICclMjknLFxuICAgICd+JzogJyU3RScsXG4gICAgJyUyMCc6ICcrJyxcbiAgICAnJTAwJzogJ1xceDAwJ1xuICB9O1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCl+XXwlMjB8JTAwL2csIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoKSB7XG4gICAgcmV0dXJuIGNoYXJNYXBbbWF0Y2hdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhcmFtcyBvYmplY3QgYW5kIGNvbnZlcnRzIGl0IHRvIGEgRm9ybURhdGEgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBGb3JtRGF0YSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkIHRvIHRoZSBBeGlvcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gQXhpb3NVUkxTZWFyY2hQYXJhbXMocGFyYW1zLCBvcHRpb25zKSB7XG4gIHRoaXMuX3BhaXJzID0gW107XG5cbiAgcGFyYW1zICYmIHRvRm9ybURhdGEocGFyYW1zLCB0aGlzLCBvcHRpb25zKTtcbn1cblxuY29uc3QgcHJvdG90eXBlID0gQXhpb3NVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMuX3BhaXJzLnB1c2goW25hbWUsIHZhbHVlXSk7XG59O1xuXG5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhlbmNvZGVyKSB7XG4gIGNvbnN0IF9lbmNvZGUgPSBlbmNvZGVyID8gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZW5jb2Rlci5jYWxsKHRoaXMsIHZhbHVlLCBlbmNvZGUpO1xuICB9IDogZW5jb2RlO1xuXG4gIHJldHVybiB0aGlzLl9wYWlycy5tYXAoZnVuY3Rpb24gZWFjaChwYWlyKSB7XG4gICAgcmV0dXJuIF9lbmNvZGUocGFpclswXSkgKyAnPScgKyBfZW5jb2RlKHBhaXJbMV0pO1xuICB9LCAnJykuam9pbignJicpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3NVUkxTZWFyY2hQYXJhbXM7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4uL2hlbHBlcnMvQXhpb3NVUkxTZWFyY2hQYXJhbXMuanMnO1xuXG4vKipcbiAqIEl0IHJlcGxhY2VzIGFsbCBpbnN0YW5jZXMgb2YgdGhlIGNoYXJhY3RlcnMgYDpgLCBgJGAsIGAsYCwgYCtgLCBgW2AsIGFuZCBgXWAgd2l0aCB0aGVpclxuICogVVJJIGVuY29kZWQgY291bnRlcnBhcnRzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbCBUaGUgdmFsdWUgdG8gYmUgZW5jb2RlZC5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEBwYXJhbSB7P29iamVjdH0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgXG4gIGNvbnN0IF9lbmNvZGUgPSBvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RlIHx8IGVuY29kZTtcblxuICBjb25zdCBzZXJpYWxpemVGbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemU7XG5cbiAgbGV0IHNlcmlhbGl6ZWRQYXJhbXM7XG5cbiAgaWYgKHNlcmlhbGl6ZUZuKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHNlcmlhbGl6ZUZuKHBhcmFtcywgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykgP1xuICAgICAgcGFyYW1zLnRvU3RyaW5nKCkgOlxuICAgICAgbmV3IEF4aW9zVVJMU2VhcmNoUGFyYW1zKHBhcmFtcywgb3B0aW9ucykudG9TdHJpbmcoX2VuY29kZSk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIGNvbnN0IGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG5cbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcblxuY2xhc3MgSW50ZXJjZXB0b3JNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gICAqL1xuICB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCwgb3B0aW9ucykge1xuICAgIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgICBmdWxmaWxsZWQsXG4gICAgICByZWplY3RlZCxcbiAgICAgIHN5bmNocm9ub3VzOiBvcHRpb25zID8gb3B0aW9ucy5zeW5jaHJvbm91cyA6IGZhbHNlLFxuICAgICAgcnVuV2hlbjogb3B0aW9ucyA/IG9wdGlvbnMucnVuV2hlbiA6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGludGVyY2VwdG9yIHdhcyByZW1vdmVkLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cbiAgZWplY3QoaWQpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGludGVyY2VwdG9ycyBmcm9tIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLmhhbmRsZXJzKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gICAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZvckVhY2goZm4pIHtcbiAgICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICAgIGZuKGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2lsZW50SlNPTlBhcnNpbmc6IHRydWUsXG4gIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxuICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBmcm9tICcuLi8uLi8uLi9oZWxwZXJzL0F4aW9zVVJMU2VhcmNoUGFyYW1zLmpzJztcbmV4cG9ydCBkZWZhdWx0IHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnID8gVVJMU2VhcmNoUGFyYW1zIDogQXhpb3NVUkxTZWFyY2hQYXJhbXM7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnID8gRm9ybURhdGEgOiBudWxsO1xuIiwgIid1c2Ugc3RyaWN0J1xuXG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iIDogbnVsbFxuIiwgImltcG9ydCBVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi9jbGFzc2VzL1VSTFNlYXJjaFBhcmFtcy5qcydcbmltcG9ydCBGb3JtRGF0YSBmcm9tICcuL2NsYXNzZXMvRm9ybURhdGEuanMnXG5pbXBvcnQgQmxvYiBmcm9tICcuL2NsYXNzZXMvQmxvYi5qcydcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0Jyb3dzZXI6IHRydWUsXG4gIGNsYXNzZXM6IHtcbiAgICBVUkxTZWFyY2hQYXJhbXMsXG4gICAgRm9ybURhdGEsXG4gICAgQmxvYlxuICB9LFxuICBwcm90b2NvbHM6IFsnaHR0cCcsICdodHRwcycsICdmaWxlJywgJ2Jsb2InLCAndXJsJywgJ2RhdGEnXVxufTtcbiIsICJjb25zdCBoYXNCcm93c2VyRW52ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGhhc1N0YW5kYXJkQnJvd3NlckVudiA9IChcbiAgKHByb2R1Y3QpID0+IHtcbiAgICByZXR1cm4gaGFzQnJvd3NlckVudiAmJiBbJ1JlYWN0TmF0aXZlJywgJ05hdGl2ZVNjcmlwdCcsICdOUyddLmluZGV4T2YocHJvZHVjdCkgPCAwXG4gIH0pKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0KTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgd2ViV29ya2VyIGVudmlyb25tZW50XG4gKlxuICogQWx0aG91Z2ggdGhlIGBpc1N0YW5kYXJkQnJvd3NlckVudmAgbWV0aG9kIGluZGljYXRlcyB0aGF0XG4gKiBgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXJgLCB0aGUgV2ViV29ya2VyIHdpbGwgc3RpbGwgYmVcbiAqIGZpbHRlcmVkIG91dCBkdWUgdG8gaXRzIGp1ZGdtZW50IHN0YW5kYXJkXG4gKiBgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ2AuXG4gKiBUaGlzIGxlYWRzIHRvIGEgcHJvYmxlbSB3aGVuIGF4aW9zIHBvc3QgYEZvcm1EYXRhYCBpbiB3ZWJXb3JrZXJcbiAqL1xuY29uc3QgaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52ID0gKCgpID0+IHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlICYmXG4gICAgdHlwZW9mIHNlbGYuaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufSkoKTtcblxuZXhwb3J0IHtcbiAgaGFzQnJvd3NlckVudixcbiAgaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52LFxuICBoYXNTdGFuZGFyZEJyb3dzZXJFbnZcbn1cbiIsICJpbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9ub2RlL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vY29tbW9uL3V0aWxzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAuLi51dGlscyxcbiAgLi4ucGxhdGZvcm1cbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b0Zvcm1EYXRhKGRhdGEsIG5ldyBwbGF0Zm9ybS5jbGFzc2VzLlVSTFNlYXJjaFBhcmFtcygpLCBPYmplY3QuYXNzaWduKHtcbiAgICB2aXNpdG9yOiBmdW5jdGlvbih2YWx1ZSwga2V5LCBwYXRoLCBoZWxwZXJzKSB7XG4gICAgICBpZiAocGxhdGZvcm0uaXNOb2RlICYmIHV0aWxzLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhlbHBlcnMuZGVmYXVsdFZpc2l0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIG9wdGlvbnMpKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogSXQgdGFrZXMgYSBzdHJpbmcgbGlrZSBgZm9vW3hdW3ldW3pdYCBhbmQgcmV0dXJucyBhbiBhcnJheSBsaWtlIGBbJ2ZvbycsICd4JywgJ3knLCAneiddXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICpcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUHJvcFBhdGgobmFtZSkge1xuICAvLyBmb29beF1beV1bel1cbiAgLy8gZm9vLngueS56XG4gIC8vIGZvby14LXktelxuICAvLyBmb28geCB5IHpcbiAgcmV0dXJuIHV0aWxzLm1hdGNoQWxsKC9cXHcrfFxcWyhcXHcqKV0vZywgbmFtZSkubWFwKG1hdGNoID0+IHtcbiAgICByZXR1cm4gbWF0Y2hbMF0gPT09ICdbXScgPyAnJyA6IG1hdGNoWzFdIHx8IG1hdGNoWzBdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGFycmF5IHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGFyciAtIFRoZSBhcnJheSB0byBjb252ZXJ0IHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFuZCB2YWx1ZXMgYXMgdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheVRvT2JqZWN0KGFycikge1xuICBjb25zdCBvYmogPSB7fTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFycik7XG4gIGxldCBpO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgbGV0IGtleTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBvYmpba2V5XSA9IGFycltrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBGb3JtRGF0YSBvYmplY3QgYW5kIHJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtRGF0YSBUaGUgRm9ybURhdGEgb2JqZWN0IHRvIGNvbnZlcnQgdG8gSlNPTi5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0PHN0cmluZywgYW55PiB8IG51bGx9IFRoZSBjb252ZXJ0ZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBmb3JtRGF0YVRvSlNPTihmb3JtRGF0YSkge1xuICBmdW5jdGlvbiBidWlsZFBhdGgocGF0aCwgdmFsdWUsIHRhcmdldCwgaW5kZXgpIHtcbiAgICBsZXQgbmFtZSA9IHBhdGhbaW5kZXgrK107XG4gICAgY29uc3QgaXNOdW1lcmljS2V5ID0gTnVtYmVyLmlzRmluaXRlKCtuYW1lKTtcbiAgICBjb25zdCBpc0xhc3QgPSBpbmRleCA+PSBwYXRoLmxlbmd0aDtcbiAgICBuYW1lID0gIW5hbWUgJiYgdXRpbHMuaXNBcnJheSh0YXJnZXQpID8gdGFyZ2V0Lmxlbmd0aCA6IG5hbWU7XG5cbiAgICBpZiAoaXNMYXN0KSB7XG4gICAgICBpZiAodXRpbHMuaGFzT3duUHJvcCh0YXJnZXQsIG5hbWUpKSB7XG4gICAgICAgIHRhcmdldFtuYW1lXSA9IFt0YXJnZXRbbmFtZV0sIHZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gIWlzTnVtZXJpY0tleTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldFtuYW1lXSB8fCAhdXRpbHMuaXNPYmplY3QodGFyZ2V0W25hbWVdKSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gW107XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYnVpbGRQYXRoKHBhdGgsIHZhbHVlLCB0YXJnZXRbbmFtZV0sIGluZGV4KTtcblxuICAgIGlmIChyZXN1bHQgJiYgdXRpbHMuaXNBcnJheSh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSBhcnJheVRvT2JqZWN0KHRhcmdldFtuYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICFpc051bWVyaWNLZXk7XG4gIH1cblxuICBpZiAodXRpbHMuaXNGb3JtRGF0YShmb3JtRGF0YSkgJiYgdXRpbHMuaXNGdW5jdGlvbihmb3JtRGF0YS5lbnRyaWVzKSkge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuXG4gICAgdXRpbHMuZm9yRWFjaEVudHJ5KGZvcm1EYXRhLCAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgIGJ1aWxkUGF0aChwYXJzZVByb3BQYXRoKG5hbWUpLCB2YWx1ZSwgb2JqLCAwKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9ybURhdGFUb0pTT047XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCB0cmFuc2l0aW9uYWxEZWZhdWx0cyBmcm9tICcuL3RyYW5zaXRpb25hbC5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuLi9oZWxwZXJzL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IHRvVVJMRW5jb2RlZEZvcm0gZnJvbSAnLi4vaGVscGVycy90b1VSTEVuY29kZWRGb3JtLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgZm9ybURhdGFUb0pTT04gZnJvbSAnLi4vaGVscGVycy9mb3JtRGF0YVRvSlNPTi5qcyc7XG5cbi8qKlxuICogSXQgdGFrZXMgYSBzdHJpbmcsIHRyaWVzIHRvIHBhcnNlIGl0LCBhbmQgaWYgaXQgZmFpbHMsIGl0IHJldHVybnMgdGhlIHN0cmluZ2lmaWVkIHZlcnNpb25cbiAqIG9mIHRoZSBpbnB1dFxuICpcbiAqIEBwYXJhbSB7YW55fSByYXdWYWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBzdHJpbmdpZmllZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcnNlciAtIEEgZnVuY3Rpb24gdGhhdCBwYXJzZXMgYSBzdHJpbmcgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlciAtIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZhbHVlIGFuZCByZXR1cm5zIGEgc3RyaW5nLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5naWZpZWQgdmVyc2lvbiBvZiB0aGUgcmF3VmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVNhZmVseShyYXdWYWx1ZSwgcGFyc2VyLCBlbmNvZGVyKSB7XG4gIGlmICh1dGlscy5pc1N0cmluZyhyYXdWYWx1ZSkpIHtcbiAgICB0cnkge1xuICAgICAgKHBhcnNlciB8fCBKU09OLnBhcnNlKShyYXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdXRpbHMudHJpbShyYXdWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubmFtZSAhPT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoZW5jb2RlciB8fCBKU09OLnN0cmluZ2lmeSkocmF3VmFsdWUpO1xufVxuXG5jb25zdCBkZWZhdWx0cyA9IHtcblxuICB0cmFuc2l0aW9uYWw6IHRyYW5zaXRpb25hbERlZmF1bHRzLFxuXG4gIGFkYXB0ZXI6IFsneGhyJywgJ2h0dHAnXSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzLmdldENvbnRlbnRUeXBlKCkgfHwgJyc7XG4gICAgY29uc3QgaGFzSlNPTkNvbnRlbnRUeXBlID0gY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTE7XG4gICAgY29uc3QgaXNPYmplY3RQYXlsb2FkID0gdXRpbHMuaXNPYmplY3QoZGF0YSk7XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkICYmIHV0aWxzLmlzSFRNTEZvcm0oZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBuZXcgRm9ybURhdGEoZGF0YSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNGb3JtRGF0YSA9IHV0aWxzLmlzRm9ybURhdGEoZGF0YSk7XG5cbiAgICBpZiAoaXNGb3JtRGF0YSkge1xuICAgICAgaWYgKCFoYXNKU09OQ29udGVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzSlNPTkNvbnRlbnRUeXBlID8gSlNPTi5zdHJpbmdpZnkoZm9ybURhdGFUb0pTT04oZGF0YSkpIDogZGF0YTtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04JywgZmFsc2UpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBsZXQgaXNGaWxlTGlzdDtcblxuICAgIGlmIChpc09iamVjdFBheWxvYWQpIHtcbiAgICAgIGlmIChjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0b1VSTEVuY29kZWRGb3JtKGRhdGEsIHRoaXMuZm9ybVNlcmlhbGl6ZXIpLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoaXNGaWxlTGlzdCA9IHV0aWxzLmlzRmlsZUxpc3QoZGF0YSkpIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ211bHRpcGFydC9mb3JtLWRhdGEnKSA+IC0xKSB7XG4gICAgICAgIGNvbnN0IF9Gb3JtRGF0YSA9IHRoaXMuZW52ICYmIHRoaXMuZW52LkZvcm1EYXRhO1xuXG4gICAgICAgIHJldHVybiB0b0Zvcm1EYXRhKFxuICAgICAgICAgIGlzRmlsZUxpc3QgPyB7J2ZpbGVzW10nOiBkYXRhfSA6IGRhdGEsXG4gICAgICAgICAgX0Zvcm1EYXRhICYmIG5ldyBfRm9ybURhdGEoKSxcbiAgICAgICAgICB0aGlzLmZvcm1TZXJpYWxpemVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCB8fCBoYXNKU09OQ29udGVudFR5cGUgKSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi9qc29uJywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeVNhZmVseShkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgY29uc3QgdHJhbnNpdGlvbmFsID0gdGhpcy50cmFuc2l0aW9uYWwgfHwgZGVmYXVsdHMudHJhbnNpdGlvbmFsO1xuICAgIGNvbnN0IGZvcmNlZEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5mb3JjZWRKU09OUGFyc2luZztcbiAgICBjb25zdCBKU09OUmVxdWVzdGVkID0gdGhpcy5yZXNwb25zZVR5cGUgPT09ICdqc29uJztcblxuICAgIGlmIChkYXRhICYmIHV0aWxzLmlzU3RyaW5nKGRhdGEpICYmICgoZm9yY2VkSlNPTlBhcnNpbmcgJiYgIXRoaXMucmVzcG9uc2VUeXBlKSB8fCBKU09OUmVxdWVzdGVkKSkge1xuICAgICAgY29uc3Qgc2lsZW50SlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLnNpbGVudEpTT05QYXJzaW5nO1xuICAgICAgY29uc3Qgc3RyaWN0SlNPTlBhcnNpbmcgPSAhc2lsZW50SlNPTlBhcnNpbmcgJiYgSlNPTlJlcXVlc3RlZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IEF4aW9zRXJyb3IuZnJvbShlLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0UsIHRoaXMsIG51bGwsIHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcblxuICBlbnY6IHtcbiAgICBGb3JtRGF0YTogcGxhdGZvcm0uY2xhc3Nlcy5Gb3JtRGF0YSxcbiAgICBCbG9iOiBwbGF0Zm9ybS5jbGFzc2VzLkJsb2JcbiAgfSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9LFxuXG4gIGhlYWRlcnM6IHtcbiAgICBjb21tb246IHtcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiB1bmRlZmluZWRcbiAgICB9XG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgKG1ldGhvZCkgPT4ge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0cztcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcblxuLy8gUmF3QXhpb3NIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xuY29uc3QgaWdub3JlRHVwbGljYXRlT2YgPSB1dGlscy50b09iamVjdFNldChbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXSk7XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdIZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5leHBvcnQgZGVmYXVsdCByYXdIZWFkZXJzID0+IHtcbiAgY29uc3QgcGFyc2VkID0ge307XG4gIGxldCBrZXk7XG4gIGxldCB2YWw7XG4gIGxldCBpO1xuXG4gIHJhd0hlYWRlcnMgJiYgcmF3SGVhZGVycy5zcGxpdCgnXFxuJykuZm9yRWFjaChmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSBsaW5lLnN1YnN0cmluZygwLCBpKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSBsaW5lLnN1YnN0cmluZyhpICsgMSkudHJpbSgpO1xuXG4gICAgaWYgKCFrZXkgfHwgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mW2tleV0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0pIHtcbiAgICAgICAgcGFyc2VkW2tleV0ucHVzaCh2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBbdmFsXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBwYXJzZUhlYWRlcnMgZnJvbSAnLi4vaGVscGVycy9wYXJzZUhlYWRlcnMuanMnO1xuXG5jb25zdCAkaW50ZXJuYWxzID0gU3ltYm9sKCdpbnRlcm5hbHMnKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyICYmIFN0cmluZyhoZWFkZXIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdXRpbHMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAobm9ybWFsaXplVmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUb2tlbnMoc3RyKSB7XG4gIGNvbnN0IHRva2VucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHRva2Vuc1JFID0gLyhbXlxccyw7PV0rKVxccyooPzo9XFxzKihbXiw7XSspKT8vZztcbiAgbGV0IG1hdGNoO1xuXG4gIHdoaWxlICgobWF0Y2ggPSB0b2tlbnNSRS5leGVjKHN0cikpKSB7XG4gICAgdG9rZW5zW21hdGNoWzFdXSA9IG1hdGNoWzJdO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuY29uc3QgaXNWYWxpZEhlYWRlck5hbWUgPSAoc3RyKSA9PiAvXlstX2EtekEtWjAtOV5gfH4sISMkJSYnKisuXSskLy50ZXN0KHN0ci50cmltKCkpO1xuXG5mdW5jdGlvbiBtYXRjaEhlYWRlclZhbHVlKGNvbnRleHQsIHZhbHVlLCBoZWFkZXIsIGZpbHRlciwgaXNIZWFkZXJOYW1lRmlsdGVyKSB7XG4gIGlmICh1dGlscy5pc0Z1bmN0aW9uKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLmNhbGwodGhpcywgdmFsdWUsIGhlYWRlcik7XG4gIH1cblxuICBpZiAoaXNIZWFkZXJOYW1lRmlsdGVyKSB7XG4gICAgdmFsdWUgPSBoZWFkZXI7XG4gIH1cblxuICBpZiAoIXV0aWxzLmlzU3RyaW5nKHZhbHVlKSkgcmV0dXJuO1xuXG4gIGlmICh1dGlscy5pc1N0cmluZyhmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmluZGV4T2YoZmlsdGVyKSAhPT0gLTE7XG4gIH1cblxuICBpZiAodXRpbHMuaXNSZWdFeHAoZmlsdGVyKSkge1xuICAgIHJldHVybiBmaWx0ZXIudGVzdCh2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0SGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyLnRyaW0oKVxuICAgIC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyhbYS16XFxkXSkoXFx3KikvZywgKHcsIGNoYXIsIHN0cikgPT4ge1xuICAgICAgcmV0dXJuIGNoYXIudG9VcHBlckNhc2UoKSArIHN0cjtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRBY2Nlc3NvcnMob2JqLCBoZWFkZXIpIHtcbiAgY29uc3QgYWNjZXNzb3JOYW1lID0gdXRpbHMudG9DYW1lbENhc2UoJyAnICsgaGVhZGVyKTtcblxuICBbJ2dldCcsICdzZXQnLCAnaGFzJ10uZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBtZXRob2ROYW1lICsgYWNjZXNzb3JOYW1lLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24oYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIGhlYWRlciwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xufVxuXG5jbGFzcyBBeGlvc0hlYWRlcnMge1xuICBjb25zdHJ1Y3RvcihoZWFkZXJzKSB7XG4gICAgaGVhZGVycyAmJiB0aGlzLnNldChoZWFkZXJzKTtcbiAgfVxuXG4gIHNldChoZWFkZXIsIHZhbHVlT3JSZXdyaXRlLCByZXdyaXRlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBzZXRIZWFkZXIoX3ZhbHVlLCBfaGVhZGVyLCBfcmV3cml0ZSkge1xuICAgICAgY29uc3QgbEhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcblxuICAgICAgaWYgKCFsSGVhZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGVhZGVyIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleShzZWxmLCBsSGVhZGVyKTtcblxuICAgICAgaWYoIWtleSB8fCBzZWxmW2tleV0gPT09IHVuZGVmaW5lZCB8fCBfcmV3cml0ZSA9PT0gdHJ1ZSB8fCAoX3Jld3JpdGUgPT09IHVuZGVmaW5lZCAmJiBzZWxmW2tleV0gIT09IGZhbHNlKSkge1xuICAgICAgICBzZWxmW2tleSB8fCBfaGVhZGVyXSA9IG5vcm1hbGl6ZVZhbHVlKF92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2V0SGVhZGVycyA9IChoZWFkZXJzLCBfcmV3cml0ZSkgPT5cbiAgICAgIHV0aWxzLmZvckVhY2goaGVhZGVycywgKF92YWx1ZSwgX2hlYWRlcikgPT4gc2V0SGVhZGVyKF92YWx1ZSwgX2hlYWRlciwgX3Jld3JpdGUpKTtcblxuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KGhlYWRlcikgfHwgaGVhZGVyIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgc2V0SGVhZGVycyhoZWFkZXIsIHZhbHVlT3JSZXdyaXRlKVxuICAgIH0gZWxzZSBpZih1dGlscy5pc1N0cmluZyhoZWFkZXIpICYmIChoZWFkZXIgPSBoZWFkZXIudHJpbSgpKSAmJiAhaXNWYWxpZEhlYWRlck5hbWUoaGVhZGVyKSkge1xuICAgICAgc2V0SGVhZGVycyhwYXJzZUhlYWRlcnMoaGVhZGVyKSwgdmFsdWVPclJld3JpdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXIgIT0gbnVsbCAmJiBzZXRIZWFkZXIodmFsdWVPclJld3JpdGUsIGhlYWRlciwgcmV3cml0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQoaGVhZGVyLCBwYXJzZXIpIHtcbiAgICBoZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoaGVhZGVyKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNba2V5XTtcblxuICAgICAgICBpZiAoIXBhcnNlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZXIgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbnModmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ocGFyc2VyKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuY2FsbCh0aGlzLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1JlZ0V4cChwYXJzZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5leGVjKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcnNlciBtdXN0IGJlIGJvb2xlYW58cmVnZXhwfGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFzKGhlYWRlciwgbWF0Y2hlcikge1xuICAgIGhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpO1xuXG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleSh0aGlzLCBoZWFkZXIpO1xuXG4gICAgICByZXR1cm4gISEoa2V5ICYmIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkICYmICghbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHRoaXMsIHRoaXNba2V5XSwga2V5LCBtYXRjaGVyKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGRlbGV0ZShoZWFkZXIsIG1hdGNoZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZGVsZXRlSGVhZGVyKF9oZWFkZXIpIHtcbiAgICAgIF9oZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmIChfaGVhZGVyKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkoc2VsZiwgX2hlYWRlcik7XG5cbiAgICAgICAgaWYgKGtleSAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZShzZWxmLCBzZWxmW2tleV0sIGtleSwgbWF0Y2hlcikpKSB7XG4gICAgICAgICAgZGVsZXRlIHNlbGZba2V5XTtcblxuICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXkoaGVhZGVyKSkge1xuICAgICAgaGVhZGVyLmZvckVhY2goZGVsZXRlSGVhZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlSGVhZGVyKGhlYWRlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBjbGVhcihtYXRjaGVyKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZighbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHRoaXMsIHRoaXNba2V5XSwga2V5LCBtYXRjaGVyLCB0cnVlKSkge1xuICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZXRlZDtcbiAgfVxuXG4gIG5vcm1hbGl6ZShmb3JtYXQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG5cbiAgICB1dGlscy5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KGhlYWRlcnMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgc2VsZltrZXldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBmb3JtYXQgPyBmb3JtYXRIZWFkZXIoaGVhZGVyKSA6IFN0cmluZyhoZWFkZXIpLnRyaW0oKTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWQgIT09IGhlYWRlcikge1xuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xuICAgICAgfVxuXG4gICAgICBzZWxmW25vcm1hbGl6ZWRdID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuXG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWRdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uY2F0KC4uLnRhcmdldHMpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jb25jYXQodGhpcywgLi4udGFyZ2V0cyk7XG4gIH1cblxuICB0b0pTT04oYXNTdHJpbmdzKSB7XG4gICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHV0aWxzLmZvckVhY2godGhpcywgKHZhbHVlLCBoZWFkZXIpID0+IHtcbiAgICAgIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlICYmIChvYmpbaGVhZGVyXSA9IGFzU3RyaW5ncyAmJiB1dGlscy5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywgJykgOiB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMudG9KU09OKCkpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKS5tYXAoKFtoZWFkZXIsIHZhbHVlXSkgPT4gaGVhZGVyICsgJzogJyArIHZhbHVlKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0F4aW9zSGVhZGVycyc7XG4gIH1cblxuICBzdGF0aWMgZnJvbSh0aGluZykge1xuICAgIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIHRoaXMgPyB0aGluZyA6IG5ldyB0aGlzKHRoaW5nKTtcbiAgfVxuXG4gIHN0YXRpYyBjb25jYXQoZmlyc3QsIC4uLnRhcmdldHMpIHtcbiAgICBjb25zdCBjb21wdXRlZCA9IG5ldyB0aGlzKGZpcnN0KTtcblxuICAgIHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiBjb21wdXRlZC5zZXQodGFyZ2V0KSk7XG5cbiAgICByZXR1cm4gY29tcHV0ZWQ7XG4gIH1cblxuICBzdGF0aWMgYWNjZXNzb3IoaGVhZGVyKSB7XG4gICAgY29uc3QgaW50ZXJuYWxzID0gdGhpc1skaW50ZXJuYWxzXSA9ICh0aGlzWyRpbnRlcm5hbHNdID0ge1xuICAgICAgYWNjZXNzb3JzOiB7fVxuICAgIH0pO1xuXG4gICAgY29uc3QgYWNjZXNzb3JzID0gaW50ZXJuYWxzLmFjY2Vzc29ycztcbiAgICBjb25zdCBwcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGRlZmluZUFjY2Vzc29yKF9oZWFkZXIpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghYWNjZXNzb3JzW2xIZWFkZXJdKSB7XG4gICAgICAgIGJ1aWxkQWNjZXNzb3JzKHByb3RvdHlwZSwgX2hlYWRlcik7XG4gICAgICAgIGFjY2Vzc29yc1tsSGVhZGVyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHMuaXNBcnJheShoZWFkZXIpID8gaGVhZGVyLmZvckVhY2goZGVmaW5lQWNjZXNzb3IpIDogZGVmaW5lQWNjZXNzb3IoaGVhZGVyKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbkF4aW9zSGVhZGVycy5hY2Nlc3NvcihbJ0NvbnRlbnQtVHlwZScsICdDb250ZW50LUxlbmd0aCcsICdBY2NlcHQnLCAnQWNjZXB0LUVuY29kaW5nJywgJ1VzZXItQWdlbnQnLCAnQXV0aG9yaXphdGlvbiddKTtcblxuLy8gcmVzZXJ2ZWQgbmFtZXMgaG90Zml4XG51dGlscy5yZWR1Y2VEZXNjcmlwdG9ycyhBeGlvc0hlYWRlcnMucHJvdG90eXBlLCAoe3ZhbHVlfSwga2V5KSA9PiB7XG4gIGxldCBtYXBwZWQgPSBrZXlbMF0udG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTsgLy8gbWFwIGBzZXRgID0+IGBTZXRgXG4gIHJldHVybiB7XG4gICAgZ2V0OiAoKSA9PiB2YWx1ZSxcbiAgICBzZXQoaGVhZGVyVmFsdWUpIHtcbiAgICAgIHRoaXNbbWFwcGVkXSA9IGhlYWRlclZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5cbnV0aWxzLmZyZWV6ZU1ldGhvZHMoQXhpb3NIZWFkZXJzKTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3NIZWFkZXJzO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcGFyYW0gez9PYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZm5zLCByZXNwb25zZSkge1xuICBjb25zdCBjb25maWcgPSB0aGlzIHx8IGRlZmF1bHRzO1xuICBjb25zdCBjb250ZXh0ID0gcmVzcG9uc2UgfHwgY29uZmlnO1xuICBjb25zdCBoZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oY29udGV4dC5oZWFkZXJzKTtcbiAgbGV0IGRhdGEgPSBjb250ZXh0LmRhdGE7XG5cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbmZpZywgZGF0YSwgaGVhZGVycy5ub3JtYWxpemUoKSwgcmVzcG9uc2UgPyByZXNwb25zZS5zdGF0dXMgOiB1bmRlZmluZWQpO1xuICB9KTtcblxuICBoZWFkZXJzLm5vcm1hbGl6ZSgpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogQSBgQ2FuY2VsZWRFcnJvcmAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdD19IHJlcXVlc3QgVGhlIHJlcXVlc3QuXG4gKlxuICogQHJldHVybnMge0NhbmNlbGVkRXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBDYW5jZWxlZEVycm9yKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgQXhpb3NFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UgPT0gbnVsbCA/ICdjYW5jZWxlZCcgOiBtZXNzYWdlLCBBeGlvc0Vycm9yLkVSUl9DQU5DRUxFRCwgY29uZmlnLCByZXF1ZXN0KTtcbiAgdGhpcy5uYW1lID0gJ0NhbmNlbGVkRXJyb3InO1xufVxuXG51dGlscy5pbmhlcml0cyhDYW5jZWxlZEVycm9yLCBBeGlvc0Vycm9yLCB7XG4gIF9fQ0FOQ0VMX186IHRydWVcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBDYW5jZWxlZEVycm9yO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi9BeGlvc0Vycm9yLmpzJztcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgcmVzcG9uc2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIGNvbnN0IHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICBbQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRV1bTWF0aC5mbG9vcihyZXNwb25zZS5zdGF0dXMgLyAxMDApIC0gNF0sXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufVxuIiwgImltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudiA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gIHtcbiAgICB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgIGNvbnN0IGNvb2tpZSA9IFtuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKV07XG5cbiAgICAgIHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpICYmIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcblxuICAgICAgdXRpbHMuaXNTdHJpbmcocGF0aCkgJiYgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuXG4gICAgICB1dGlscy5pc1N0cmluZyhkb21haW4pICYmIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG5cbiAgICAgIHNlY3VyZSA9PT0gdHJ1ZSAmJiBjb29raWUucHVzaCgnc2VjdXJlJyk7XG5cbiAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgIH0sXG5cbiAgICByZWFkKG5hbWUpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgfSxcblxuICAgIHJlbW92ZShuYW1lKSB7XG4gICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgIH1cbiAgfVxuXG4gIDpcblxuICAvLyBOb24tc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIHtcbiAgICB3cml0ZSgpIHt9LFxuICAgIHJlYWQoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHJlbW92ZSgpIHt9XG4gIH07XG5cbiIsICIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkK1xcLS5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGlzQWJzb2x1dGVVUkwgZnJvbSAnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMLmpzJztcbmltcG9ydCBjb21iaW5lVVJMcyBmcm9tICcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIGJhc2VVUkwgd2l0aCB0aGUgcmVxdWVzdGVkVVJMLFxuICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxuICogSWYgdGhlIHJlcXVlc3RVUkwgaXMgYWJzb2x1dGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVxdWVzdGVkVVJMIHVudG91Y2hlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0ZWRVUkwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIHRvIGNvbWJpbmVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52ID9cblxuLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4vLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICBjb25zdCBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICBjb25zdCB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBsZXQgb3JpZ2luVVJMO1xuXG4gICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdHMgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgbGV0IGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0pKCk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZVByb3RvY29sKHVybCkge1xuICBjb25zdCBtYXRjaCA9IC9eKFstK1xcd117MSwyNX0pKDo/XFwvXFwvfDopLy5leGVjKHVybCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRhdGEgbWF4UmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtzYW1wbGVzQ291bnQ9IDEwXVxuICogQHBhcmFtIHtOdW1iZXJ9IFttaW49IDEwMDBdXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHNwZWVkb21ldGVyKHNhbXBsZXNDb3VudCwgbWluKSB7XG4gIHNhbXBsZXNDb3VudCA9IHNhbXBsZXNDb3VudCB8fCAxMDtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgQXJyYXkoc2FtcGxlc0NvdW50KTtcbiAgY29uc3QgdGltZXN0YW1wcyA9IG5ldyBBcnJheShzYW1wbGVzQ291bnQpO1xuICBsZXQgaGVhZCA9IDA7XG4gIGxldCB0YWlsID0gMDtcbiAgbGV0IGZpcnN0U2FtcGxlVFM7XG5cbiAgbWluID0gbWluICE9PSB1bmRlZmluZWQgPyBtaW4gOiAxMDAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiBwdXNoKGNodW5rTGVuZ3RoKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGNvbnN0IHN0YXJ0ZWRBdCA9IHRpbWVzdGFtcHNbdGFpbF07XG5cbiAgICBpZiAoIWZpcnN0U2FtcGxlVFMpIHtcbiAgICAgIGZpcnN0U2FtcGxlVFMgPSBub3c7XG4gICAgfVxuXG4gICAgYnl0ZXNbaGVhZF0gPSBjaHVua0xlbmd0aDtcbiAgICB0aW1lc3RhbXBzW2hlYWRdID0gbm93O1xuXG4gICAgbGV0IGkgPSB0YWlsO1xuICAgIGxldCBieXRlc0NvdW50ID0gMDtcblxuICAgIHdoaWxlIChpICE9PSBoZWFkKSB7XG4gICAgICBieXRlc0NvdW50ICs9IGJ5dGVzW2krK107XG4gICAgICBpID0gaSAlIHNhbXBsZXNDb3VudDtcbiAgICB9XG5cbiAgICBoZWFkID0gKGhlYWQgKyAxKSAlIHNhbXBsZXNDb3VudDtcblxuICAgIGlmIChoZWFkID09PSB0YWlsKSB7XG4gICAgICB0YWlsID0gKHRhaWwgKyAxKSAlIHNhbXBsZXNDb3VudDtcbiAgICB9XG5cbiAgICBpZiAobm93IC0gZmlyc3RTYW1wbGVUUyA8IG1pbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhc3NlZCA9IHN0YXJ0ZWRBdCAmJiBub3cgLSBzdGFydGVkQXQ7XG5cbiAgICByZXR1cm4gcGFzc2VkID8gTWF0aC5yb3VuZChieXRlc0NvdW50ICogMTAwMCAvIHBhc3NlZCkgOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNwZWVkb21ldGVyO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHNldHRsZSBmcm9tICcuLy4uL2NvcmUvc2V0dGxlLmpzJztcbmltcG9ydCBjb29raWVzIGZyb20gJy4vLi4vaGVscGVycy9jb29raWVzLmpzJztcbmltcG9ydCBidWlsZFVSTCBmcm9tICcuLy4uL2hlbHBlcnMvYnVpbGRVUkwuanMnO1xuaW1wb3J0IGJ1aWxkRnVsbFBhdGggZnJvbSAnLi4vY29yZS9idWlsZEZ1bGxQYXRoLmpzJztcbmltcG9ydCBpc1VSTFNhbWVPcmlnaW4gZnJvbSAnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyc7XG5pbXBvcnQgdHJhbnNpdGlvbmFsRGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvdHJhbnNpdGlvbmFsLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgcGFyc2VQcm90b2NvbCBmcm9tICcuLi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuaW1wb3J0IHNwZWVkb21ldGVyIGZyb20gJy4uL2hlbHBlcnMvc3BlZWRvbWV0ZXIuanMnO1xuXG5mdW5jdGlvbiBwcm9ncmVzc0V2ZW50UmVkdWNlcihsaXN0ZW5lciwgaXNEb3dubG9hZFN0cmVhbSkge1xuICBsZXQgYnl0ZXNOb3RpZmllZCA9IDA7XG4gIGNvbnN0IF9zcGVlZG9tZXRlciA9IHNwZWVkb21ldGVyKDUwLCAyNTApO1xuXG4gIHJldHVybiBlID0+IHtcbiAgICBjb25zdCBsb2FkZWQgPSBlLmxvYWRlZDtcbiAgICBjb25zdCB0b3RhbCA9IGUubGVuZ3RoQ29tcHV0YWJsZSA/IGUudG90YWwgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJvZ3Jlc3NCeXRlcyA9IGxvYWRlZCAtIGJ5dGVzTm90aWZpZWQ7XG4gICAgY29uc3QgcmF0ZSA9IF9zcGVlZG9tZXRlcihwcm9ncmVzc0J5dGVzKTtcbiAgICBjb25zdCBpblJhbmdlID0gbG9hZGVkIDw9IHRvdGFsO1xuXG4gICAgYnl0ZXNOb3RpZmllZCA9IGxvYWRlZDtcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBsb2FkZWQsXG4gICAgICB0b3RhbCxcbiAgICAgIHByb2dyZXNzOiB0b3RhbCA/IChsb2FkZWQgLyB0b3RhbCkgOiB1bmRlZmluZWQsXG4gICAgICBieXRlczogcHJvZ3Jlc3NCeXRlcyxcbiAgICAgIHJhdGU6IHJhdGUgPyByYXRlIDogdW5kZWZpbmVkLFxuICAgICAgZXN0aW1hdGVkOiByYXRlICYmIHRvdGFsICYmIGluUmFuZ2UgPyAodG90YWwgLSBsb2FkZWQpIC8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGV2ZW50OiBlXG4gICAgfTtcblxuICAgIGRhdGFbaXNEb3dubG9hZFN0cmVhbSA/ICdkb3dubG9hZCcgOiAndXBsb2FkJ10gPSB0cnVlO1xuXG4gICAgbGlzdGVuZXIoZGF0YSk7XG4gIH07XG59XG5cbmNvbnN0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBkZWZhdWx0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCAmJiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGV0IHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShjb25maWcuaGVhZGVycykubm9ybWFsaXplKCk7XG4gICAgbGV0IHtyZXNwb25zZVR5cGUsIHdpdGhYU1JGVG9rZW59ID0gY29uZmlnO1xuICAgIGxldCBvbkNhbmNlbGVkO1xuICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi51bnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgY29uZmlnLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBjb250ZW50VHlwZTtcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgaWYgKHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudiB8fCBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJXZWJXb3JrZXJFbnYpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnMuc2V0Q29udGVudFR5cGUoZmFsc2UpOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgICB9IGVsc2UgaWYgKChjb250ZW50VHlwZSA9IHJlcXVlc3RIZWFkZXJzLmdldENvbnRlbnRUeXBlKCkpICE9PSBmYWxzZSkge1xuICAgICAgICAvLyBmaXggc2VtaWNvbG9uIGR1cGxpY2F0aW9uIGlzc3VlIGZvciBSZWFjdE5hdGl2ZSBGb3JtRGF0YSBpbXBsZW1lbnRhdGlvblxuICAgICAgICBjb25zdCBbdHlwZSwgLi4udG9rZW5zXSA9IGNvbnRlbnRUeXBlID8gY29udGVudFR5cGUuc3BsaXQoJzsnKS5tYXAodG9rZW4gPT4gdG9rZW4udHJpbSgpKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnMuc2V0Q29udGVudFR5cGUoW3R5cGUgfHwgJ211bHRpcGFydC9mb3JtLWRhdGEnLCAuLi50b2tlbnNdLmpvaW4oJzsgJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICBjb25zdCB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCA/IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChjb25maWcuYXV0aC5wYXNzd29yZCkpIDogJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCkpO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG5cbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICBmdW5jdGlvbiBvbmxvYWRlbmQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKFxuICAgICAgICAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ICYmIHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICk7XG4gICAgICBjb25zdCByZXNwb25zZURhdGEgPSAhcmVzcG9uc2VUeXBlIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nID9cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKGZ1bmN0aW9uIF9yZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCBmdW5jdGlvbiBfcmVqZWN0KGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ29ubG9hZGVuZCcgaW4gcmVxdWVzdCkge1xuICAgICAgLy8gVXNlIG9ubG9hZGVuZCBpZiBhdmFpbGFibGVcbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gb25sb2FkZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlIHRvIGVtdWxhdGUgb25sb2FkZW5kXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZHlzdGF0ZSBoYW5kbGVyIGlzIGNhbGxpbmcgYmVmb3JlIG9uZXJyb3Igb3Igb250aW1lb3V0IGhhbmRsZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgY2FsbCBvbmxvYWRlbmQgb24gdGhlIG5leHQgJ3RpY2snXG4gICAgICAgIHNldFRpbWVvdXQob25sb2FkZW5kKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCwgY29uZmlnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdOZXR3b3JrIEVycm9yJywgQXhpb3NFcnJvci5FUlJfTkVUV09SSywgY29uZmlnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIGxldCB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXQgPyAndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnIDogJ3RpbWVvdXQgZXhjZWVkZWQnO1xuICAgICAgY29uc3QgdHJhbnNpdGlvbmFsID0gY29uZmlnLnRyYW5zaXRpb25hbCB8fCB0cmFuc2l0aW9uYWxEZWZhdWx0cztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UsXG4gICAgICAgIHRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gQXhpb3NFcnJvci5FVElNRURPVVQgOiBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmKHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudikge1xuICAgICAgd2l0aFhTUkZUb2tlbiAmJiB1dGlscy5pc0Z1bmN0aW9uKHdpdGhYU1JGVG9rZW4pICYmICh3aXRoWFNSRlRva2VuID0gd2l0aFhTUkZUb2tlbihjb25maWcpKTtcblxuICAgICAgaWYgKHdpdGhYU1JGVG9rZW4gfHwgKHdpdGhYU1JGVG9rZW4gIT09IGZhbHNlICYmIGlzVVJMU2FtZU9yaWdpbihmdWxsUGF0aCkpKSB7XG4gICAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgICBjb25zdCB4c3JmVmFsdWUgPSBjb25maWcueHNyZkhlYWRlck5hbWUgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lICYmIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpO1xuXG4gICAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgICByZXF1ZXN0SGVhZGVycy5zZXQoY29uZmlnLnhzcmZIZWFkZXJOYW1lLCB4c3JmVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgIHJlcXVlc3REYXRhID09PSB1bmRlZmluZWQgJiYgcmVxdWVzdEhlYWRlcnMuc2V0Q29udGVudFR5cGUobnVsbCk7XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycy50b0pTT04oKSwgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFjb25maWcud2l0aENyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAocmVzcG9uc2VUeXBlICYmIHJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHByb2dyZXNzRXZlbnRSZWR1Y2VyKGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MsIHRydWUpKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuIHx8IGNvbmZpZy5zaWduYWwpIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBvbkNhbmNlbGVkID0gY2FuY2VsID0+IHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlamVjdCghY2FuY2VsIHx8IGNhbmNlbC50eXBlID8gbmV3IENhbmNlbGVkRXJyb3IobnVsbCwgY29uZmlnLCByZXF1ZXN0KSA6IGNhbmNlbCk7XG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4gJiYgY29uZmlnLmNhbmNlbFRva2VuLnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIGlmIChjb25maWcuc2lnbmFsKSB7XG4gICAgICAgIGNvbmZpZy5zaWduYWwuYWJvcnRlZCA/IG9uQ2FuY2VsZWQoKSA6IGNvbmZpZy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwcm90b2NvbCA9IHBhcnNlUHJvdG9jb2woZnVsbFBhdGgpO1xuXG4gICAgaWYgKHByb3RvY29sICYmIHBsYXRmb3JtLnByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignVW5zdXBwb3J0ZWQgcHJvdG9jb2wgJyArIHByb3RvY29sICsgJzonLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgY29uZmlnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhIHx8IG51bGwpO1xuICB9KTtcbn1cbiIsICJpbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IGh0dHBBZGFwdGVyIGZyb20gJy4vaHR0cC5qcyc7XG5pbXBvcnQgeGhyQWRhcHRlciBmcm9tICcuL3hoci5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tIFwiLi4vY29yZS9BeGlvc0Vycm9yLmpzXCI7XG5cbmNvbnN0IGtub3duQWRhcHRlcnMgPSB7XG4gIGh0dHA6IGh0dHBBZGFwdGVyLFxuICB4aHI6IHhockFkYXB0ZXJcbn1cblxudXRpbHMuZm9yRWFjaChrbm93bkFkYXB0ZXJzLCAoZm4sIHZhbHVlKSA9PiB7XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICduYW1lJywge3ZhbHVlfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ2FkYXB0ZXJOYW1lJywge3ZhbHVlfSk7XG4gIH1cbn0pO1xuXG5jb25zdCByZW5kZXJSZWFzb24gPSAocmVhc29uKSA9PiBgLSAke3JlYXNvbn1gO1xuXG5jb25zdCBpc1Jlc29sdmVkSGFuZGxlID0gKGFkYXB0ZXIpID0+IHV0aWxzLmlzRnVuY3Rpb24oYWRhcHRlcikgfHwgYWRhcHRlciA9PT0gbnVsbCB8fCBhZGFwdGVyID09PSBmYWxzZTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZXRBZGFwdGVyOiAoYWRhcHRlcnMpID0+IHtcbiAgICBhZGFwdGVycyA9IHV0aWxzLmlzQXJyYXkoYWRhcHRlcnMpID8gYWRhcHRlcnMgOiBbYWRhcHRlcnNdO1xuXG4gICAgY29uc3Qge2xlbmd0aH0gPSBhZGFwdGVycztcbiAgICBsZXQgbmFtZU9yQWRhcHRlcjtcbiAgICBsZXQgYWRhcHRlcjtcblxuICAgIGNvbnN0IHJlamVjdGVkUmVhc29ucyA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgbmFtZU9yQWRhcHRlciA9IGFkYXB0ZXJzW2ldO1xuICAgICAgbGV0IGlkO1xuXG4gICAgICBhZGFwdGVyID0gbmFtZU9yQWRhcHRlcjtcblxuICAgICAgaWYgKCFpc1Jlc29sdmVkSGFuZGxlKG5hbWVPckFkYXB0ZXIpKSB7XG4gICAgICAgIGFkYXB0ZXIgPSBrbm93bkFkYXB0ZXJzWyhpZCA9IFN0cmluZyhuYW1lT3JBZGFwdGVyKSkudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGFkYXB0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKGBVbmtub3duIGFkYXB0ZXIgJyR7aWR9J2ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGFwdGVyKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZWplY3RlZFJlYXNvbnNbaWQgfHwgJyMnICsgaV0gPSBhZGFwdGVyO1xuICAgIH1cblxuICAgIGlmICghYWRhcHRlcikge1xuXG4gICAgICBjb25zdCByZWFzb25zID0gT2JqZWN0LmVudHJpZXMocmVqZWN0ZWRSZWFzb25zKVxuICAgICAgICAubWFwKChbaWQsIHN0YXRlXSkgPT4gYGFkYXB0ZXIgJHtpZH0gYCArXG4gICAgICAgICAgKHN0YXRlID09PSBmYWxzZSA/ICdpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudCcgOiAnaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnVpbGQnKVxuICAgICAgICApO1xuXG4gICAgICBsZXQgcyA9IGxlbmd0aCA/XG4gICAgICAgIChyZWFzb25zLmxlbmd0aCA+IDEgPyAnc2luY2UgOlxcbicgKyByZWFzb25zLm1hcChyZW5kZXJSZWFzb24pLmpvaW4oJ1xcbicpIDogJyAnICsgcmVuZGVyUmVhc29uKHJlYXNvbnNbMF0pKSA6XG4gICAgICAgICdhcyBubyBhZGFwdGVyIHNwZWNpZmllZCc7XG5cbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICBgVGhlcmUgaXMgbm8gc3VpdGFibGUgYWRhcHRlciB0byBkaXNwYXRjaCB0aGUgcmVxdWVzdCBgICsgcyxcbiAgICAgICAgJ0VSUl9OT1RfU1VQUE9SVCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkYXB0ZXI7XG4gIH0sXG4gIGFkYXB0ZXJzOiBrbm93bkFkYXB0ZXJzXG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdHJhbnNmb3JtRGF0YSBmcm9tICcuL3RyYW5zZm9ybURhdGEuanMnO1xuaW1wb3J0IGlzQ2FuY2VsIGZyb20gJy4uL2NhbmNlbC9pc0NhbmNlbC5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvaW5kZXguanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tICcuLi9jb3JlL0F4aW9zSGVhZGVycy5qcyc7XG5pbXBvcnQgYWRhcHRlcnMgZnJvbSBcIi4uL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzXCI7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cblxuICBpZiAoY29uZmlnLnNpZ25hbCAmJiBjb25maWcuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgQ2FuY2VsZWRFcnJvcihudWxsLCBjb25maWcpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShjb25maWcuaGVhZGVycyk7XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICBjb25maWcsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICBpZiAoWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLmluZGV4T2YoY29uZmlnLm1ldGhvZCkgIT09IC0xKSB7XG4gICAgY29uZmlnLmhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsIGZhbHNlKTtcbiAgfVxuXG4gIGNvbnN0IGFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyKGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXIpO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgY29uZmlnLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlLFxuICAgICAgcmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmVzcG9uc2UuaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKHJlc3BvbnNlLmhlYWRlcnMpO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZVxuICAgICAgICApO1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tIFwiLi9BeGlvc0hlYWRlcnMuanNcIjtcblxuY29uc3QgaGVhZGVyc1RvT2JqZWN0ID0gKHRoaW5nKSA9PiB0aGluZyBpbnN0YW5jZW9mIEF4aW9zSGVhZGVycyA/IHRoaW5nLnRvSlNPTigpIDogdGhpbmc7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIGNvbnN0IGNvbmZpZyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlLCBjYXNlbGVzcykge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UuY2FsbCh7Y2FzZWxlc3N9LCB0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMoYSwgYiwgY2FzZWxlc3MpIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoYSwgYiwgY2FzZWxlc3MpO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGEpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhLCBjYXNlbGVzcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIoYSwgYikge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYikpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKGEsIGIpIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBiKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChhKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGlyZWN0S2V5cyhhLCBiLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIpO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBtZXJnZU1hcCA9IHtcbiAgICB1cmw6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgbWV0aG9kOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIGRhdGE6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgYmFzZVVSTDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc2Zvcm1SZXF1ZXN0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zZm9ybVJlc3BvbnNlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHBhcmFtc1NlcmlhbGl6ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdGltZW91dDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0aW1lb3V0TWVzc2FnZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB3aXRoQ3JlZGVudGlhbHM6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgd2l0aFhTUkZUb2tlbjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBhZGFwdGVyOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHJlc3BvbnNlVHlwZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmQ29va2llTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmSGVhZGVyTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBvblVwbG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG9uRG93bmxvYWRQcm9ncmVzczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBkZWNvbXByZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG1heENvbnRlbnRMZW5ndGg6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgbWF4Qm9keUxlbmd0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBiZWZvcmVSZWRpcmVjdDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc3BvcnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgaHR0cEFnZW50OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGh0dHBzQWdlbnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgY2FuY2VsVG9rZW46IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgc29ja2V0UGF0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICByZXNwb25zZUVuY29kaW5nOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHZhbGlkYXRlU3RhdHVzOiBtZXJnZURpcmVjdEtleXMsXG4gICAgaGVhZGVyczogKGEsIGIpID0+IG1lcmdlRGVlcFByb3BlcnRpZXMoaGVhZGVyc1RvT2JqZWN0KGEpLCBoZWFkZXJzVG9PYmplY3QoYiksIHRydWUpXG4gIH07XG5cbiAgdXRpbHMuZm9yRWFjaChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCBjb25maWcxLCBjb25maWcyKSksIGZ1bmN0aW9uIGNvbXB1dGVDb25maWdWYWx1ZShwcm9wKSB7XG4gICAgY29uc3QgbWVyZ2UgPSBtZXJnZU1hcFtwcm9wXSB8fCBtZXJnZURlZXBQcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNvbmZpZ1ZhbHVlID0gbWVyZ2UoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSwgcHJvcCk7XG4gICAgKHV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZ1ZhbHVlKSAmJiBtZXJnZSAhPT0gbWVyZ2VEaXJlY3RLZXlzKSB8fCAoY29uZmlnW3Byb3BdID0gY29uZmlnVmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufVxuIiwgImV4cG9ydCBjb25zdCBWRVJTSU9OID0gXCIxLjYuMlwiOyIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7VkVSU0lPTn0gZnJvbSAnLi4vZW52L2RhdGEuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcblxuY29uc3QgdmFsaWRhdG9ycyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuWydvYmplY3QnLCAnYm9vbGVhbicsICdudW1iZXInLCAnZnVuY3Rpb24nLCAnc3RyaW5nJywgJ3N5bWJvbCddLmZvckVhY2goKHR5cGUsIGkpID0+IHtcbiAgdmFsaWRhdG9yc1t0eXBlXSA9IGZ1bmN0aW9uIHZhbGlkYXRvcih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IHR5cGUgfHwgJ2EnICsgKGkgPCAxID8gJ24gJyA6ICcgJykgKyB0eXBlO1xuICB9O1xufSk7XG5cbmNvbnN0IGRlcHJlY2F0ZWRXYXJuaW5ncyA9IHt9O1xuXG4vKipcbiAqIFRyYW5zaXRpb25hbCBvcHRpb24gdmFsaWRhdG9yXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbnxib29sZWFuP30gdmFsaWRhdG9yIC0gc2V0IHRvIGZhbHNlIGlmIHRoZSB0cmFuc2l0aW9uYWwgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWRcbiAqIEBwYXJhbSB7c3RyaW5nP30gdmVyc2lvbiAtIGRlcHJlY2F0ZWQgdmVyc2lvbiAvIHJlbW92ZWQgc2luY2UgdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmc/fSBtZXNzYWdlIC0gc29tZSBtZXNzYWdlIHdpdGggYWRkaXRpb25hbCBpbmZvXG4gKlxuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICovXG52YWxpZGF0b3JzLnRyYW5zaXRpb25hbCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25hbCh2YWxpZGF0b3IsIHZlcnNpb24sIG1lc3NhZ2UpIHtcbiAgZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShvcHQsIGRlc2MpIHtcbiAgICByZXR1cm4gJ1tBeGlvcyB2JyArIFZFUlNJT04gKyAnXSBUcmFuc2l0aW9uYWwgb3B0aW9uIFxcJycgKyBvcHQgKyAnXFwnJyArIGRlc2MgKyAobWVzc2FnZSA/ICcuICcgKyBtZXNzYWdlIDogJycpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuICh2YWx1ZSwgb3B0LCBvcHRzKSA9PiB7XG4gICAgaWYgKHZhbGlkYXRvciA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICBmb3JtYXRNZXNzYWdlKG9wdCwgJyBoYXMgYmVlbiByZW1vdmVkJyArICh2ZXJzaW9uID8gJyBpbiAnICsgdmVyc2lvbiA6ICcnKSksXG4gICAgICAgIEF4aW9zRXJyb3IuRVJSX0RFUFJFQ0FURURcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gJiYgIWRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdKSB7XG4gICAgICBkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSA9IHRydWU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBmb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIG9wdCxcbiAgICAgICAgICAnIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdicgKyB2ZXJzaW9uICsgJyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZWFyIGZ1dHVyZSdcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdG9yID8gdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdHMpIDogdHJ1ZTtcbiAgfTtcbn07XG5cbi8qKlxuICogQXNzZXJ0IG9iamVjdCdzIHByb3BlcnRpZXMgdHlwZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBhbGxvd1Vua25vd25cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbnMob3B0aW9ucywgc2NoZW1hLCBhbGxvd1Vua25vd24pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0JywgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTl9WQUxVRSk7XG4gIH1cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIGNvbnN0IG9wdCA9IGtleXNbaV07XG4gICAgY29uc3QgdmFsaWRhdG9yID0gc2NoZW1hW29wdF07XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW29wdF07XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRpb25zKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ29wdGlvbiAnICsgb3B0ICsgJyBtdXN0IGJlICcgKyByZXN1bHQsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhbGxvd1Vua25vd24gIT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdVbmtub3duIG9wdGlvbiAnICsgb3B0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBhc3NlcnRPcHRpb25zLFxuICB2YWxpZGF0b3JzXG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gJy4uL2hlbHBlcnMvYnVpbGRVUkwuanMnO1xuaW1wb3J0IEludGVyY2VwdG9yTWFuYWdlciBmcm9tICcuL0ludGVyY2VwdG9yTWFuYWdlci5qcyc7XG5pbXBvcnQgZGlzcGF0Y2hSZXF1ZXN0IGZyb20gJy4vZGlzcGF0Y2hSZXF1ZXN0LmpzJztcbmltcG9ydCBtZXJnZUNvbmZpZyBmcm9tICcuL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBidWlsZEZ1bGxQYXRoIGZyb20gJy4vYnVpbGRGdWxsUGF0aC5qcyc7XG5pbXBvcnQgdmFsaWRhdG9yIGZyb20gJy4uL2hlbHBlcnMvdmFsaWRhdG9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi9BeGlvc0hlYWRlcnMuanMnO1xuXG5jb25zdCB2YWxpZGF0b3JzID0gdmFsaWRhdG9yLnZhbGlkYXRvcnM7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmNsYXNzIEF4aW9zIHtcbiAgY29uc3RydWN0b3IoaW5zdGFuY2VDb25maWcpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWdPclVybCBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gICAqIEBwYXJhbSB7P09iamVjdH0gY29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAgICovXG4gIHJlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgICBpZiAodHlwZW9mIGNvbmZpZ09yVXJsID09PSAnc3RyaW5nJykge1xuICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgY29uZmlnLnVybCA9IGNvbmZpZ09yVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcgPSBjb25maWdPclVybCB8fCB7fTtcbiAgICB9XG5cbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgY29uc3Qge3RyYW5zaXRpb25hbCwgcGFyYW1zU2VyaWFsaXplciwgaGVhZGVyc30gPSBjb25maWc7XG5cbiAgICBpZiAodHJhbnNpdGlvbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgICAgZm9yY2VkSlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbilcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zU2VyaWFsaXplciAhPSBudWxsKSB7XG4gICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihwYXJhbXNTZXJpYWxpemVyKSkge1xuICAgICAgICBjb25maWcucGFyYW1zU2VyaWFsaXplciA9IHtcbiAgICAgICAgICBzZXJpYWxpemU6IHBhcmFtc1NlcmlhbGl6ZXJcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnMocGFyYW1zU2VyaWFsaXplciwge1xuICAgICAgICAgIGVuY29kZTogdmFsaWRhdG9ycy5mdW5jdGlvbixcbiAgICAgICAgICBzZXJpYWxpemU6IHZhbGlkYXRvcnMuZnVuY3Rpb25cbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgICBjb25maWcubWV0aG9kID0gKGNvbmZpZy5tZXRob2QgfHwgdGhpcy5kZWZhdWx0cy5tZXRob2QgfHwgJ2dldCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgICBsZXQgY29udGV4dEhlYWRlcnMgPSBoZWFkZXJzICYmIHV0aWxzLm1lcmdlKFxuICAgICAgaGVhZGVycy5jb21tb24sXG4gICAgICBoZWFkZXJzW2NvbmZpZy5tZXRob2RdXG4gICAgKTtcblxuICAgIGhlYWRlcnMgJiYgdXRpbHMuZm9yRWFjaChcbiAgICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgICAgKG1ldGhvZCkgPT4ge1xuICAgICAgICBkZWxldGUgaGVhZGVyc1ttZXRob2RdO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBjb25maWcuaGVhZGVycyA9IEF4aW9zSGVhZGVycy5jb25jYXQoY29udGV4dEhlYWRlcnMsIGhlYWRlcnMpO1xuXG4gICAgLy8gZmlsdGVyIG91dCBza2lwcGVkIGludGVyY2VwdG9yc1xuICAgIGNvbnN0IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluID0gW107XG4gICAgbGV0IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHRydWU7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yLnJ1bldoZW4gPT09ICdmdW5jdGlvbicgJiYgaW50ZXJjZXB0b3IucnVuV2hlbihjb25maWcpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyAmJiBpbnRlcmNlcHRvci5zeW5jaHJvbm91cztcblxuICAgICAgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgICByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgICB9KTtcblxuICAgIGxldCBwcm9taXNlO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgbGVuO1xuXG4gICAgaWYgKCFzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMpIHtcbiAgICAgIGNvbnN0IGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdC5iaW5kKHRoaXMpLCB1bmRlZmluZWRdO1xuICAgICAgY2hhaW4udW5zaGlmdC5hcHBseShjaGFpbiwgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4pO1xuICAgICAgY2hhaW4ucHVzaC5hcHBseShjaGFpbiwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcbiAgICAgIGxlbiA9IGNoYWluLmxlbmd0aDtcblxuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluW2krK10sIGNoYWluW2krK10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cbiAgICBsZW4gPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5sZW5ndGg7XG5cbiAgICBsZXQgbmV3Q29uZmlnID0gY29uZmlnO1xuXG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgY29uc3Qgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xuICAgICAgY29uc3Qgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluW2krK107XG4gICAgICB0cnkge1xuICAgICAgICBuZXdDb25maWcgPSBvbkZ1bGZpbGxlZChuZXdDb25maWcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgb25SZWplY3RlZC5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QuY2FsbCh0aGlzLCBuZXdDb25maWcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGxlbiA9IHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW5baSsrXSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluW2krK10pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZ2V0VXJpKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gICAgY29uc3QgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICByZXR1cm4gYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKTtcbiAgfVxufVxuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUhUVFBNZXRob2QoaXNGb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBNZXRob2QodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaXNGb3JtID8ge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgfSA6IHt9LFxuICAgICAgICB1cmwsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBnZW5lcmF0ZUhUVFBNZXRob2QoKTtcblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kICsgJ0Zvcm0nXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCh0cnVlKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvcztcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4vQ2FuY2VsZWRFcnJvci5qcyc7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybnMge0NhbmNlbFRva2VufVxuICovXG5jbGFzcyBDYW5jZWxUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKGV4ZWN1dG9yKSB7XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlUHJvbWlzZTtcblxuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0b2tlbiA9IHRoaXM7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIHRoaXMucHJvbWlzZS50aGVuKGNhbmNlbCA9PiB7XG4gICAgICBpZiAoIXRva2VuLl9saXN0ZW5lcnMpIHJldHVybjtcblxuICAgICAgbGV0IGkgPSB0b2tlbi5fbGlzdGVuZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgdG9rZW4uX2xpc3RlbmVyc1tpXShjYW5jZWwpO1xuICAgICAgfVxuICAgICAgdG9rZW4uX2xpc3RlbmVycyA9IG51bGw7XG4gICAgfSk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIHRoaXMucHJvbWlzZS50aGVuID0gb25mdWxmaWxsZWQgPT4ge1xuICAgICAgbGV0IF9yZXNvbHZlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdG9rZW4uc3Vic2NyaWJlKHJlc29sdmUpO1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KS50aGVuKG9uZnVsZmlsbGVkKTtcblxuICAgICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiByZWplY3QoKSB7XG4gICAgICAgIHRva2VuLnVuc3Vic2NyaWJlKF9yZXNvbHZlKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KSB7XG4gICAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWxlZEVycm9yKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCk7XG4gICAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRocm93cyBhIGBDYW5jZWxlZEVycm9yYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICAgKi9cbiAgdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIHRocm93IHRoaXMucmVhc29uO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIGNhbmNlbCBzaWduYWxcbiAgICovXG5cbiAgc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICBsaXN0ZW5lcih0aGlzLnJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbbGlzdGVuZXJdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIHRoZSBjYW5jZWwgc2lnbmFsXG4gICAqL1xuXG4gIHVuc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAgICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAgICovXG4gIHN0YXRpYyBzb3VyY2UoKSB7XG4gICAgbGV0IGNhbmNlbDtcbiAgICBjb25zdCB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgICBjYW5jZWwgPSBjO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbixcbiAgICAgIGNhbmNlbFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FuY2VsVG9rZW47XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNBeGlvc0Vycm9yKHBheWxvYWQpIHtcbiAgcmV0dXJuIHV0aWxzLmlzT2JqZWN0KHBheWxvYWQpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG59XG4iLCAiY29uc3QgSHR0cFN0YXR1c0NvZGUgPSB7XG4gIENvbnRpbnVlOiAxMDAsXG4gIFN3aXRjaGluZ1Byb3RvY29sczogMTAxLFxuICBQcm9jZXNzaW5nOiAxMDIsXG4gIEVhcmx5SGludHM6IDEwMyxcbiAgT2s6IDIwMCxcbiAgQ3JlYXRlZDogMjAxLFxuICBBY2NlcHRlZDogMjAyLFxuICBOb25BdXRob3JpdGF0aXZlSW5mb3JtYXRpb246IDIwMyxcbiAgTm9Db250ZW50OiAyMDQsXG4gIFJlc2V0Q29udGVudDogMjA1LFxuICBQYXJ0aWFsQ29udGVudDogMjA2LFxuICBNdWx0aVN0YXR1czogMjA3LFxuICBBbHJlYWR5UmVwb3J0ZWQ6IDIwOCxcbiAgSW1Vc2VkOiAyMjYsXG4gIE11bHRpcGxlQ2hvaWNlczogMzAwLFxuICBNb3ZlZFBlcm1hbmVudGx5OiAzMDEsXG4gIEZvdW5kOiAzMDIsXG4gIFNlZU90aGVyOiAzMDMsXG4gIE5vdE1vZGlmaWVkOiAzMDQsXG4gIFVzZVByb3h5OiAzMDUsXG4gIFVudXNlZDogMzA2LFxuICBUZW1wb3JhcnlSZWRpcmVjdDogMzA3LFxuICBQZXJtYW5lbnRSZWRpcmVjdDogMzA4LFxuICBCYWRSZXF1ZXN0OiA0MDAsXG4gIFVuYXV0aG9yaXplZDogNDAxLFxuICBQYXltZW50UmVxdWlyZWQ6IDQwMixcbiAgRm9yYmlkZGVuOiA0MDMsXG4gIE5vdEZvdW5kOiA0MDQsXG4gIE1ldGhvZE5vdEFsbG93ZWQ6IDQwNSxcbiAgTm90QWNjZXB0YWJsZTogNDA2LFxuICBQcm94eUF1dGhlbnRpY2F0aW9uUmVxdWlyZWQ6IDQwNyxcbiAgUmVxdWVzdFRpbWVvdXQ6IDQwOCxcbiAgQ29uZmxpY3Q6IDQwOSxcbiAgR29uZTogNDEwLFxuICBMZW5ndGhSZXF1aXJlZDogNDExLFxuICBQcmVjb25kaXRpb25GYWlsZWQ6IDQxMixcbiAgUGF5bG9hZFRvb0xhcmdlOiA0MTMsXG4gIFVyaVRvb0xvbmc6IDQxNCxcbiAgVW5zdXBwb3J0ZWRNZWRpYVR5cGU6IDQxNSxcbiAgUmFuZ2VOb3RTYXRpc2ZpYWJsZTogNDE2LFxuICBFeHBlY3RhdGlvbkZhaWxlZDogNDE3LFxuICBJbUFUZWFwb3Q6IDQxOCxcbiAgTWlzZGlyZWN0ZWRSZXF1ZXN0OiA0MjEsXG4gIFVucHJvY2Vzc2FibGVFbnRpdHk6IDQyMixcbiAgTG9ja2VkOiA0MjMsXG4gIEZhaWxlZERlcGVuZGVuY3k6IDQyNCxcbiAgVG9vRWFybHk6IDQyNSxcbiAgVXBncmFkZVJlcXVpcmVkOiA0MjYsXG4gIFByZWNvbmRpdGlvblJlcXVpcmVkOiA0MjgsXG4gIFRvb01hbnlSZXF1ZXN0czogNDI5LFxuICBSZXF1ZXN0SGVhZGVyRmllbGRzVG9vTGFyZ2U6IDQzMSxcbiAgVW5hdmFpbGFibGVGb3JMZWdhbFJlYXNvbnM6IDQ1MSxcbiAgSW50ZXJuYWxTZXJ2ZXJFcnJvcjogNTAwLFxuICBOb3RJbXBsZW1lbnRlZDogNTAxLFxuICBCYWRHYXRld2F5OiA1MDIsXG4gIFNlcnZpY2VVbmF2YWlsYWJsZTogNTAzLFxuICBHYXRld2F5VGltZW91dDogNTA0LFxuICBIdHRwVmVyc2lvbk5vdFN1cHBvcnRlZDogNTA1LFxuICBWYXJpYW50QWxzb05lZ290aWF0ZXM6IDUwNixcbiAgSW5zdWZmaWNpZW50U3RvcmFnZTogNTA3LFxuICBMb29wRGV0ZWN0ZWQ6IDUwOCxcbiAgTm90RXh0ZW5kZWQ6IDUxMCxcbiAgTmV0d29ya0F1dGhlbnRpY2F0aW9uUmVxdWlyZWQ6IDUxMSxcbn07XG5cbk9iamVjdC5lbnRyaWVzKEh0dHBTdGF0dXNDb2RlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgSHR0cFN0YXR1c0NvZGVbdmFsdWVdID0ga2V5O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEh0dHBTdGF0dXNDb2RlO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IGJpbmQgZnJvbSAnLi9oZWxwZXJzL2JpbmQuanMnO1xuaW1wb3J0IEF4aW9zIGZyb20gJy4vY29yZS9BeGlvcy5qcyc7XG5pbXBvcnQgbWVyZ2VDb25maWcgZnJvbSAnLi9jb3JlL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBmb3JtRGF0YVRvSlNPTiBmcm9tICcuL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsVG9rZW4gZnJvbSAnLi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMnO1xuaW1wb3J0IGlzQ2FuY2VsIGZyb20gJy4vY2FuY2VsL2lzQ2FuY2VsLmpzJztcbmltcG9ydCB7VkVSU0lPTn0gZnJvbSAnLi9lbnYvZGF0YS5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL2hlbHBlcnMvdG9Gb3JtRGF0YS5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgc3ByZWFkIGZyb20gJy4vaGVscGVycy9zcHJlYWQuanMnO1xuaW1wb3J0IGlzQXhpb3NFcnJvciBmcm9tICcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vY29yZS9BeGlvc0hlYWRlcnMuanNcIjtcbmltcG9ydCBhZGFwdGVycyBmcm9tICcuL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzJztcbmltcG9ydCBIdHRwU3RhdHVzQ29kZSBmcm9tICcuL2hlbHBlcnMvSHR0cFN0YXR1c0NvZGUuanMnO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybnMge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIGNvbnN0IGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQsIHthbGxPd25LZXlzOiB0cnVlfSk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCwgbnVsbCwge2FsbE93bktleXM6IHRydWV9KTtcblxuICAvLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG4gIGluc3RhbmNlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCBpbnN0YW5jZUNvbmZpZykpO1xuICB9O1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG5jb25zdCBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbGVkRXJyb3IgPSBDYW5jZWxlZEVycm9yO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbmF4aW9zLmlzQ2FuY2VsID0gaXNDYW5jZWw7XG5heGlvcy5WRVJTSU9OID0gVkVSU0lPTjtcbmF4aW9zLnRvRm9ybURhdGEgPSB0b0Zvcm1EYXRhO1xuXG4vLyBFeHBvc2UgQXhpb3NFcnJvciBjbGFzc1xuYXhpb3MuQXhpb3NFcnJvciA9IEF4aW9zRXJyb3I7XG5cbi8vIGFsaWFzIGZvciBDYW5jZWxlZEVycm9yIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5heGlvcy5DYW5jZWwgPSBheGlvcy5DYW5jZWxlZEVycm9yO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuXG5heGlvcy5zcHJlYWQgPSBzcHJlYWQ7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IGlzQXhpb3NFcnJvcjtcblxuLy8gRXhwb3NlIG1lcmdlQ29uZmlnXG5heGlvcy5tZXJnZUNvbmZpZyA9IG1lcmdlQ29uZmlnO1xuXG5heGlvcy5BeGlvc0hlYWRlcnMgPSBBeGlvc0hlYWRlcnM7XG5cbmF4aW9zLmZvcm1Ub0pTT04gPSB0aGluZyA9PiBmb3JtRGF0YVRvSlNPTih1dGlscy5pc0hUTUxGb3JtKHRoaW5nKSA/IG5ldyBGb3JtRGF0YSh0aGluZykgOiB0aGluZyk7XG5cbmF4aW9zLmdldEFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyO1xuXG5heGlvcy5IdHRwU3RhdHVzQ29kZSA9IEh0dHBTdGF0dXNDb2RlO1xuXG5heGlvcy5kZWZhdWx0ID0gYXhpb3M7XG5cbi8vIHRoaXMgbW9kdWxlIHNob3VsZCBvbmx5IGhhdmUgYSBkZWZhdWx0IGV4cG9ydFxuZXhwb3J0IGRlZmF1bHQgYXhpb3NcbiIsICJpbXBvcnQgYXhpb3MgZnJvbSAnLi9saWIvYXhpb3MuanMnO1xuXG4vLyBUaGlzIG1vZHVsZSBpcyBpbnRlbmRlZCB0byB1bndyYXAgQXhpb3MgZGVmYXVsdCBleHBvcnQgYXMgbmFtZWQuXG4vLyBLZWVwIHRvcC1sZXZlbCBleHBvcnQgc2FtZSB3aXRoIHN0YXRpYyBwcm9wZXJ0aWVzXG4vLyBzbyB0aGF0IGl0IGNhbiBrZWVwIHNhbWUgd2l0aCBlcyBtb2R1bGUgb3IgY2pzXG5jb25zdCB7XG4gIEF4aW9zLFxuICBBeGlvc0Vycm9yLFxuICBDYW5jZWxlZEVycm9yLFxuICBpc0NhbmNlbCxcbiAgQ2FuY2VsVG9rZW4sXG4gIFZFUlNJT04sXG4gIGFsbCxcbiAgQ2FuY2VsLFxuICBpc0F4aW9zRXJyb3IsXG4gIHNwcmVhZCxcbiAgdG9Gb3JtRGF0YSxcbiAgQXhpb3NIZWFkZXJzLFxuICBIdHRwU3RhdHVzQ29kZSxcbiAgZm9ybVRvSlNPTixcbiAgZ2V0QWRhcHRlcixcbiAgbWVyZ2VDb25maWdcbn0gPSBheGlvcztcblxuZXhwb3J0IHtcbiAgYXhpb3MgYXMgZGVmYXVsdCxcbiAgQXhpb3MsXG4gIEF4aW9zRXJyb3IsXG4gIENhbmNlbGVkRXJyb3IsXG4gIGlzQ2FuY2VsLFxuICBDYW5jZWxUb2tlbixcbiAgVkVSU0lPTixcbiAgYWxsLFxuICBDYW5jZWwsXG4gIGlzQXhpb3NFcnJvcixcbiAgc3ByZWFkLFxuICB0b0Zvcm1EYXRhLFxuICBBeGlvc0hlYWRlcnMsXG4gIEh0dHBTdGF0dXNDb2RlLFxuICBmb3JtVG9KU09OLFxuICBnZXRBZGFwdGVyLFxuICBtZXJnZUNvbmZpZ1xufVxuIiwgImltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIlxyXG5pbXBvcnQgeyBQTFVHSU5fTkFNRSB9IGZyb20gXCIuL3N0YXRpY1wiXHJcbmltcG9ydCB7IEhpc3RvcnlGaWxlVmlld0FjdGlvbiwgIFBvY2tldFNldHRpbmdzIH0gZnJvbSBcImRcIlxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBQb2NrZXQge1xyXG4gIHByZWZpeDogc3RyaW5nID0gJ3Nub3dmbGFrZV9vYnNpZGlhbidcclxuICBjb25zdHJ1Y3RvcihzZXR0aW5ncz86IFBvY2tldFNldHRpbmdzKSB7XHJcbiAgICB0aGlzLnByZWZpeCA9IHNldHRpbmdzPy5wcmVmaXggfHwgdGhpcy5wcmVmaXhcclxuICB9XHJcbiAgZ2V0KGtleTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5wcmVmaXggKyBrZXkpXHJcbiAgfVxyXG4gIHNldChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IG51bWJlciB8IG51bGwpIHtcclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMucHJlZml4ICsga2V5LCBgJHt2YWx1ZX1gKVxyXG4gIH1cclxuICBjbGVhcihrZXk6IHN0cmluZykge1xyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5wcmVmaXggKyBrZXkpXHJcbiAgfVxyXG4gIGNsZWFyX2FsbCgpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSlcclxuICAgICAgaWYgKGtleT8uc3RhcnRzV2l0aCh0aGlzLnByZWZpeCkpXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEZpbGVNZXRhRGF0YSB7XHJcbiAgcGF0aDogc3RyaW5nID0gJydcclxuICBjb25maWdfZGlyOiBzdHJpbmcgPSAnLm9ic2lkaWFuJ1xyXG4gIGV4dF9wYXRoOiAoKSA9PiBzdHJpbmcgPSAoKSA9PiBgJHt0aGlzLmNvbmZpZ19kaXJ9L3BsdWdpbnMvJHtQTFVHSU5fTkFNRX1gXHJcbiAgZmlsZW5hbWU6IHN0cmluZ1xyXG4gIGxpbmVzX2xpbWl0OiBudW1iZXIgPSA1MDBcclxuICBjdXJyZW50X2xpbmVzX3BvaW50ZXI6IG51bWJlciA9IDBcclxuICBjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkXHJcbiAgY29uc3RydWN0b3IoZmlsZW5hbWU6IHN0cmluZywgY29uZmlnX2Rpcjogc3RyaW5nID0gJy5vYnNpZGlhbicpIHtcclxuICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZVxyXG4gICAgdGhpcy5jb25maWdfZGlyID0gY29uZmlnX2RpclxyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JylcclxuICAgICAgdGhpcy5wYXRoID0gcGF0aC5qb2luKHRoaXMuZXh0X3BhdGgoKSwgdGhpcy5maWxlbmFtZSlcclxuICAgIGVsc2VcclxuICAgICAgdGhpcy5wYXRoID0gW3RoaXMuZXh0X3BhdGgoKSwgdGhpcy5maWxlbmFtZV0uam9pbignLycpXHJcbiAgfVxyXG4gIHNldF9tYWluX3BhdGgoKSB7XHJcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnKVxyXG4gICAgICB0aGlzLnBhdGggPSBwYXRoLmpvaW4odGhpcy5leHRfcGF0aCgpLCB0aGlzLmZpbGVuYW1lKVxyXG4gICAgZWxzZVxyXG4gICAgICB0aGlzLnBhdGggPSBbdGhpcy5leHRfcGF0aCgpLCB0aGlzLmZpbGVuYW1lXS5qb2luKCcvJylcclxuICB9XHJcbiAgc2V0X2xpbWl0KGxpbWl0OiBudW1iZXIpIHtcclxuICAgIHRoaXMubGluZXNfbGltaXQgPSBsaW1pdFxyXG4gIH1cclxuICBzZXRfY2FsbGJhY2soY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCkge1xyXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXHJcbiAgfVxyXG4gIHNldF9jb25maWdfZGlyKGNvbmZpZ19kaXI6IHN0cmluZykge1xyXG4gICAgdGhpcy5jb25maWdfZGlyID0gY29uZmlnX2RpclxyXG4gIH1cclxuICBjcmVhdGUoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBhcHAudmF1bHQuYWRhcHRlci53cml0ZSh0aGlzLnBhdGgsICcnKVxyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdFcnJvcjogV3JpdGUgRmlsZScpXHJcbiAgICB9XHJcbiAgfVxyXG4gIGFzeW5jIHNldCh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBhcHAudmF1bHQuYWRhcHRlci53cml0ZSh0aGlzLnBhdGgsIHZhbHVlKVxyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdFcnJvcjogV3JpdGUgRmlsZSBTeW5jJylcclxuICAgIH1cclxuICB9XHJcbiAgYXN5bmMgYWRkKHZhbHVlOiBzdHJpbmcpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGFwcC52YXVsdC5hZGFwdGVyLmFwcGVuZCh0aGlzLnBhdGgsIHZhbHVlKVxyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdFcnJvcjogQXBwZW5kIEZpbGUgU3luYycpXHJcbiAgICB9XHJcbiAgfVxyXG4gIGFzeW5jIGdldCgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBhd2FpdCBhcHAudmF1bHQuYWRhcHRlci5yZWFkKHRoaXMucGF0aClcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmxvZygnRXJyb3I6IFJlYWQgRmlsZSBTeW5jIC0gJyArIGVyci5tZXNzYWdlKVxyXG4gICAgICByZXR1cm4gJydcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogIHJldHVybnMgYGNvdW50YCBvZiBsaW5lcyBmcm9tIGBzdGFydGAgdmFsdWUuXHJcbiAgICogYHN0YXJ0YCBjb3VsZCBiZSBhbHNvIGxlc3MgdGhlbiBgMGAsIHRoZW4gYGNvdW50YCB3aWxsIGJlIGdldCBieSB0aGUgZW5kIG9mIHRoZSBmaWxlXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHN0YXJ0IFxyXG4gICAqIEBwYXJhbSBjb3VudCBcclxuICAgKiBAcmV0dXJucyBcclxuKi9cclxuICBhc3luYyBnZXRfbGluZXNfYnlfaW5kZXgoc3RhcnQ6IG51bWJlciwgY291bnQ/OiBudW1iZXIpIHtcclxuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLmdldCgpXHJcbiAgICBjb25zdCBsaW5lcyA9IGZpbGUudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylcclxuICAgIGNvbnN0IGxlbiA9IGxpbmVzLmxlbmd0aFxyXG4gICAgaWYgKHN0YXJ0ID4gbGVuKSByZXR1cm4gW11cclxuICAgIGlmICghY291bnQpIGNvdW50ID0gbGVuXHJcbiAgICBpZiAoc3RhcnQgPCAwKVxyXG4gICAgICBzdGFydCA9IGxlbiArIHN0YXJ0XHJcbiAgICBpZiAoc3RhcnQgPCAwKVxyXG4gICAgICBzdGFydCA9IDBcclxuICAgIGlmIChzdGFydCArIGNvdW50ID49IGxlbilcclxuICAgICAgY291bnQgPSBsZW5cclxuICAgIGVsc2VcclxuICAgICAgY291bnQgPSBzdGFydCArIGNvdW50XHJcbiAgICB0aGlzLmN1cnJlbnRfbGluZXNfcG9pbnRlciA9IGxlblxyXG5cclxuICAgIHJldHVybiBsaW5lcy5zbGljZShzdGFydCwgY291bnQpLmZpbHRlcihpdGVtID0+ICEhaXRlbSlcclxuICB9XHJcbiAgYXN5bmMgZ2V0X2xpbmVzX2Zyb21fdG9fcGhyYXNlKHBocmFzZTogc3RyaW5nLCBjb3VudDogbnVtYmVyID0gMSwgY29udGFpbl9waHJhc2UgPSBmYWxzZSwgcmV2ZXJzZTogYm9vbGVhbiA9IHRydWUpIHtcclxuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLmdldCgpXHJcbiAgICBjb25zdCBsaW5lcyA9IGZpbGUudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykucmV2ZXJzZSgpXHJcbiAgICBjb25zdCBsZW4gPSBsaW5lcy5sZW5ndGhcclxuICAgIGNvbnN0IGxpbmVzX3RvX3JldHVybiA9IFtdXHJcbiAgICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICAgIGlmIChsaW5lLmNvbnRhaW5zKHBocmFzZSkpIHtcclxuICAgICAgICBpZiAoY29udGFpbl9waHJhc2UpXHJcbiAgICAgICAgICBsaW5lc190b19yZXR1cm4ucHVzaChsaW5lKVxyXG4gICAgICAgIGNvdW50LS1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsaW5lc190b19yZXR1cm4ucHVzaChsaW5lKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY291bnQgPT0gMClcclxuICAgICAgICBicmVha1xyXG4gICAgfVxyXG4gICAgdGhpcy5jdXJyZW50X2xpbmVzX3BvaW50ZXIgPSBsZW5cclxuXHJcbiAgICByZXR1cm4gbGluZXNfdG9fcmV0dXJuLmZpbHRlcihpdGVtID0+ICEhaXRlbSlcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMb2dnZXIgZXh0ZW5kcyBGaWxlTWV0YURhdGEge1xyXG4gIGNvbnN0cnVjdG9yKGZpbGVuYW1lOiBzdHJpbmcsIGNvbmZpZ19kaXI6IHN0cmluZyA9ICcub2JzaWRpYW4nKSB7XHJcbiAgICBzdXBlcihmaWxlbmFtZSwgY29uZmlnX2RpcilcclxuICB9XHJcbiAgYXN5bmMgY2hlY2tfbGltaXQoKSB7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50X2xpbmVzX3BvaW50ZXIgPiAwLjkgKiB0aGlzLmxpbmVzX2xpbWl0KSB7XHJcbiAgICAgIGNvbnN0IHN0YXJ0ID0gMC4xICogdGhpcy5saW5lc19saW1pdFxyXG4gICAgICBhd2FpdCB0aGlzLnNldCgoYXdhaXQgdGhpcy5nZXRfbGluZXNfYnlfaW5kZXgoLXN0YXJ0KSkuam9pbignXFxuJykpXHJcbiAgICAgIHRoaXMuY3VycmVudF9saW5lc19wb2ludGVyID0gc3RhcnRcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGxvZyhtZXNzYWdlOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpXHJcbiAgICBjb25zdCBmdWxsbWVzc2FnZSA9IGBcXG5bJHtkYXRlLnRvTG9jYWxlU3RyaW5nKCkucmVwbGFjZSgnLCAnLCAnfCcpfV0+XFx0JHttZXNzYWdlfWBcclxuICAgIGF3YWl0IHRoaXMuYWRkKGZ1bGxtZXNzYWdlKVxyXG4gICAgaWYgKHRoaXMuY2FsbGJhY2spXHJcbiAgICAgIHRoaXMuY2FsbGJhY2soZnVsbG1lc3NhZ2UpXHJcbiAgICB0aGlzLmN1cnJlbnRfbGluZXNfcG9pbnRlcisrXHJcbiAgICBhd2FpdCB0aGlzLmNoZWNrX2xpbWl0KClcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBIaXN0b3J5IGV4dGVuZHMgRmlsZU1ldGFEYXRhIHtcclxuICBsaW5lc19saW1pdDogbnVtYmVyID0gMjAwMFxyXG4gIGN1cnJlbnRfbGluZXNfcG9pbnRlcjogbnVtYmVyID0gMFxyXG4gIGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IHZvaWRcclxuICBjb25zdHJ1Y3RvcihmaWxlbmFtZTogc3RyaW5nLCBjb25maWdfZGlyOiBzdHJpbmcgPSAnLm9ic2lkaWFuJykge1xyXG4gICAgc3VwZXIoZmlsZW5hbWUsIGNvbmZpZ19kaXIpXHJcbiAgfVxyXG4gIGFzeW5jIGNoZWNrX2xpbWl0KCkge1xyXG4gICAgaWYgKHRoaXMuY3VycmVudF9saW5lc19wb2ludGVyID4gMC45ICogdGhpcy5saW5lc19saW1pdCkge1xyXG4gICAgICBjb25zdCBzdGFydCA9IDAuMyAqIHRoaXMubGluZXNfbGltaXRcclxuICAgICAgYXdhaXQgdGhpcy5zZXQoKGF3YWl0IHRoaXMuZ2V0X2xpbmVzX2J5X2luZGV4KC1zdGFydCkpLmpvaW4oJ1xcbicpKVxyXG4gICAgICB0aGlzLmN1cnJlbnRfbGluZXNfcG9pbnRlciA9IHN0YXJ0XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwYXJzZXIobGluZTogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBbdGltZSwgYWN0aW9uLCBwYXRoLCBvbGRfcGF0aF0gPSBsaW5lLnNwbGl0KCdcXHQnKVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGltZSwgYWN0aW9uLCBwYXRoLCBvbGRfcGF0aFxyXG4gICAgfVxyXG4gIH1cclxuICBhc3luYyBjbGVhcigpIHtcclxuICAgIGF3YWl0IHRoaXMuc2V0KCcnKVxyXG4gICAgdGhpcy5jdXJyZW50X2xpbmVzX3BvaW50ZXIgPSAwXHJcbiAgfVxyXG4gIGFzeW5jIGNoZWNrX3JlcGVhdHMoX2FjdGlvbjogc3RyaW5nLCBfcGF0aDogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBsYXN0X2NoYW5nZXMgPSBhd2FpdCB0aGlzLmdldF9saW5lc19ieV9pbmRleCgtMjAwKVxyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGxhc3RfY2hhbmdlcykge1xyXG4gICAgICBjb25zdCB7IGFjdGlvbiwgcGF0aCB9ID0gdGhpcy5wYXJzZXIoaXRlbSlcclxuICAgICAgaWYgKGFjdGlvbiA9PSAnTU9ESUZZJyAmJiBfYWN0aW9uID09IGFjdGlvbiAmJiBwYXRoID09IF9wYXRoKVxyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcbiAgYXN5bmMgYWRkX2FjdGlvbihhY3Rpb246IEhpc3RvcnlGaWxlVmlld0FjdGlvbiwgcGF0aDogc3RyaW5nLCBvbGRfcGF0aD86IHN0cmluZykge1xyXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKClcclxuICAgIGlmICghKGF3YWl0IHRoaXMuY2hlY2tfcmVwZWF0cyhhY3Rpb24sIHBhdGgpKSkgcmV0dXJuXHJcbiAgICBjb25zdCBmdWxsbWVzc2FnZSA9IGBcXG5bJHtkYXRlLnRvTG9jYWxlU3RyaW5nKCl9XVxcdCR7YWN0aW9ufVxcdCR7cGF0aH1cXHQke29sZF9wYXRoIHx8ICdudWxsJ31gXHJcbiAgICBhd2FpdCB0aGlzLmFkZChmdWxsbWVzc2FnZSlcclxuICAgIGlmICh0aGlzLmNhbGxiYWNrKVxyXG4gICAgICB0aGlzLmNhbGxiYWNrKGZ1bGxtZXNzYWdlKVxyXG4gICAgdGhpcy5jdXJyZW50X2xpbmVzX3BvaW50ZXIrK1xyXG4gICAgYXdhaXQgdGhpcy5jaGVja19saW1pdCgpXHJcbiAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBTZXR0aW5nc1ZpZXdwb2ludCB9IGZyb20gXCJkXCI7XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogU2V0dGluZ3NWaWV3cG9pbnQgPSB7XHJcblx0dG9rZW46ICcqKioqKicsXHJcblx0dXNlcm5hbWU6ICcnLFxyXG5cdHJlcG9fbmFtZTogJycsXHJcblx0cHJvamVjdF9uYW1lOiAnJyxcclxuXHRlbWFpbDogJycsXHJcblx0YXV0bzogZmFsc2UsXHJcblx0ZmV0Y2g6IGZhbHNlLFxyXG5cdGJyYW5jaDogJ21hc3RlcicsXHJcblx0bm90aWY6IHRydWUsXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBMT0dHRVJfRklMRSA9ICdsb2dnZXIubG9nJ1xyXG5leHBvcnQgY29uc3QgSElTVE9SWV9GSUxFID0gJ2hpc3RvcnkubG9nJ1xyXG5leHBvcnQgY29uc3QgUE9DS0VUX1RPS0VOX0tFWSA9ICdnaXRsYWJ0b2tlbidcclxuZXhwb3J0IGNvbnN0IEhJU1RPUllfVklFVyA9ICdoaXN0b3J5J1xyXG5cclxuZXhwb3J0IGNvbnN0IEdJVExBQl9BUElfVVJMID0gJ2h0dHBzOi8vZ2l0bGFiLmNvbS9hcGkvdjQnXHJcblxyXG5leHBvcnQgY29uc3QgUExVR0lOX05BTUUgPSAnb2JzaWRpYW4tc25vd2ZsYWtlJyIsICJleHBvcnQgY2xhc3MgUXVldWUge1xyXG5cdGFjdGlvbnM6ICgoKSA9PiBQcm9taXNlPGFueT4pW10gPSBbXVxyXG5cdGNvbnN0cnVjdG9yKCkgeyB9XHJcblx0YXBwZW5kKGFjdGlvbjogKCkgPT4gUHJvbWlzZTxhbnk+KSB7XHJcblx0XHR0aGlzLmFjdGlvbnMucHVzaChhY3Rpb24pXHJcblx0XHRpZiAodGhpcy5hY3Rpb25zLmxlbmd0aCA9PSAxKVxyXG5cdFx0XHR0aGlzLmFjdGlvbl9oYW5kbGUoKVxyXG5cdH1cclxuXHRhc3luYyBhY3Rpb25faGFuZGxlKCkge1xyXG5cdFx0aWYgKHRoaXMuYWN0aW9ucy5sZW5ndGggIT0gMCkge1xyXG5cdFx0XHRjb25zdCBhY3Rpb24gPSB0aGlzLmFjdGlvbnNbMF1cclxuXHRcdFx0aWYgKGFjdGlvbilcclxuXHRcdFx0XHRhd2FpdCBhY3Rpb24oKVxyXG5cdFx0XHR0aGlzLmFjdGlvbnMuc2hpZnQoKVxyXG5cdFx0XHR0aGlzLmFjdGlvbl9oYW5kbGUoKVxyXG5cdFx0fVxyXG5cdH1cclxufSIsICJpbXBvcnQgU3luY1Nub3dmbGFrZSwgeyBwb2NrZXQgfSBmcm9tIFwibWFpblwiXHJcbmltcG9ydCB7IEFwcCwgTm90aWNlLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCJcclxuXHJcbmV4cG9ydCBjbGFzcyBTbm93Zmxha2VTZXR0aW5ncyBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG5cdHBsdWdpbjogU3luY1Nub3dmbGFrZVxyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBTeW5jU25vd2ZsYWtlKSB7XHJcblx0XHRzdXBlcihhcHAsIHBsdWdpbilcclxuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luXHJcblx0fVxyXG5cclxuXHRkaXNwbGF5KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpc1xyXG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKVxyXG5cdFx0Y29uc3Qgc2V0ID0gKCkgPT4gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRzZXQoKS5zZXROYW1lKCdUb2tlbicpIFxyXG5cdFx0XHQuc2V0RGVzYygnSGVyZSBpcyBnaXRsYWIgdG9rZW4nKVxyXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHlvdXIgc2VjcmV0JylcclxuXHRcdFx0XHQuc2V0VmFsdWUoJyonLnJlcGVhdChwb2NrZXQuZ2V0KCdnaXRsYWJ0b2tlbicpPy5sZW5ndGggfHwgMCkpXHJcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0cG9ja2V0LnNldCgnZ2l0bGFidG9rZW4nLCB2YWx1ZSlcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXHJcblx0XHRcdFx0fSkpXHJcblx0XHRzZXQoKS5zZXROYW1lKCdFbWFpbCcpXHJcblx0XHRcdC5zZXREZXNjKCdIZXJlIGlzIGVtYWlsIC0gZ2l0IGNvbW1pdCcpXHJcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRW50ZXIgeW91ciBlbWFpbCcpXHJcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmVtYWlsKVxyXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmVtYWlsID0gdmFsdWVcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXHJcblx0XHRcdFx0fSkpXHJcblx0XHRzZXQoKS5zZXROYW1lKCdVc2VybmFtZScpXHJcblx0XHRcdC5zZXREZXNjKCdIZXJlIGlzIGdpdGxhYiB1c2VybmFtZSAtIGdpdCBjb21taXQnKVxyXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHlvdXIgdXNlcm5hbWUnKVxyXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VybmFtZSlcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VybmFtZSA9IHZhbHVlXHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKVxyXG5cdFx0XHRcdH0pKVxyXG5cdFx0c2V0KCkuc2V0TmFtZSgnUHJvamVjdCcpXHJcblx0XHRcdC5zZXREZXNjKCdIZXJlIGlzIGdpdGxhYiBwcm9qZWN0IG5hbWUnKVxyXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHByb2plY3QgbmFtZScpXHJcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2plY3RfbmFtZSlcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9qZWN0X25hbWUgPSB2YWx1ZVxyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKClcclxuXHRcdFx0XHR9KSlcclxuXHRcdHNldCgpLnNldE5hbWUoJ05hbWUnKVxyXG5cdFx0XHQuc2V0RGVzYygnSGVyZSBpcyBnaXRsYWIgcmVwb3NpdG9yeSBuYW1lJylcclxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdFbnRlciByZXBvc2l0b3J5IG5hbWUnKVxyXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvX25hbWUpXHJcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucmVwb19uYW1lID0gdmFsdWVcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXHJcblx0XHRcdFx0fSkpXHJcblx0XHRzZXQoKS5zZXROYW1lKCdNYWluIGJyYW5jaCcpXHJcblx0XHRcdC5zZXREZXNjKCdIZXJlIGlzIGdpdGxhYiBtYWluIGJyYW5jaCBuYW1lJylcclxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdFbnRlciB5b3VyIGJyYW5jaCBuYW1lJylcclxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoKVxyXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmJyYW5jaCA9IHZhbHVlXHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKVxyXG5cdFx0XHRcdH0pKVxyXG5cdFx0c2V0KCkuc2V0TmFtZSgnU3luYyBBdXRvJylcclxuXHRcdFx0LnNldERlc2MoJ1NldCBvbiBpZiB5b3Ugd2FudCB0byBzeW5jIHJlcG9zaXRvcnkgYXV0b21hdGljYWxseScpXHJcblx0XHRcdC5hZGRUb2dnbGUoY2IgPT4gY2Iuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXV0bylcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvID0gdmFsdWVcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXHJcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBBdXRvIE1vZGU6ICR7dmFsdWUgPyAnb24nIDogJ29mZid9YClcclxuXHRcdFx0XHR9KSlcclxuXHRcdHNldCgpLnNldE5hbWUoJ0ZldGNoIG9uIHN0YXJ0JylcclxuXHRcdFx0LnNldERlc2MoJ1NldCBvbiBpZiB5b3Ugd2FudCB0byBzeW5jIHJlcG9zaXRvcnkgb24gc3RhcnQnKVxyXG5cdFx0XHQuYWRkVG9nZ2xlKGNiID0+IGNiLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmZldGNoKVxyXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmZldGNoID0gdmFsdWVcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpXHJcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBBdXRvIEZldGNoOiAke3ZhbHVlID8gJ29uJyA6ICdvZmYnfWApXHJcblx0XHRcdFx0fSkpXHJcblx0XHRzZXQoKS5zZXROYW1lKCdOb3RpZmljYXRpb25zJylcclxuXHRcdFx0LnNldERlc2MoJ1NldCBvbiBpZiB5b3Ugd2FudCBub3RpZmljYXRpb25zJylcclxuXHRcdFx0LmFkZFRvZ2dsZShjYiA9PiBjYi5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3RpZilcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3RpZiA9IHZhbHVlXHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKVxyXG5cdFx0XHRcdFx0bmV3IE5vdGljZShgTm90aWZpY2F0aW9uczogJHt2YWx1ZSA/ICdvbicgOiAnb2ZmJ31gKVxyXG5cdFx0XHRcdH0pKVxyXG5cdFx0c2V0KCkuc2V0TmFtZSgnUmVsb2FkIFNldHRpbmdzJylcclxuXHRcdFx0LnNldERlc2MoJ0NsaWNrIHRvIHJlbG9hZCBjdXJyZW50IHNldHRpbmdzJylcclxuXHRcdFx0LmFkZEJ1dHRvbihjYiA9PiBjYi5zZXRCdXR0b25UZXh0KCdSZWxvYWQnKS5zZXRJY29uKCdyZWZyZXNoLWN3Jykub25DbGljaygoKSA9PiB7XHJcblx0XHRcdFx0dGhpcy5wbHVnaW4ubG9hZFNldHRpbmdzKClcclxuXHRcdFx0XHRuZXcgTm90aWNlKCdTZXR0aW5ncyB1cGRhdGVkJylcclxuXHRcdFx0fSkpXHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQgeyBsb2NhbF9jaGFuZ2VzX2xvZ3MsIHN5bmNfbG9ncyB9IGZyb20gXCJtYWluXCI7XHJcbmltcG9ydCB7IEl0ZW1WaWV3LCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IEZpbGVNZXRhRGF0YSwgfSBmcm9tIFwic3JjL3N0b3JhZ2VcIjtcclxuaW1wb3J0IHsgSElTVE9SWV9WSUVXIH0gZnJvbSBcInNyYy9zdGF0aWNcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgSGlzdG9yeUxlYWYgZXh0ZW5kcyBJdGVtVmlldyB7XHJcbiAgc3luY19sb2dzOiBIVE1MRWxlbWVudFxyXG4gIGxvY2FsX2xvZ3M6IEhUTUxFbGVtZW50XHJcbiAgY29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZikge1xyXG4gICAgc3VwZXIobGVhZilcclxuICB9XHJcbiAgaWNvbjogc3RyaW5nID0gJ3Njcm9sbCdcclxuICBnZXRWaWV3VHlwZSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIEhJU1RPUllfVklFV1xyXG4gIH1cclxuICBnZXREaXNwbGF5VGV4dCgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuICdTbm93Zmxha2UgSGlzdG9yeSdcclxuICB9XHJcbiAgYXN5bmMgcmVsb2FkX2xvZ3MoZWxlbWVudDogSFRNTEVsZW1lbnQsIHR5cGU6IEZpbGVNZXRhRGF0YSkge1xyXG4gICAgY29uc3QgbG9ncyA9IGF3YWl0IHR5cGUuZ2V0X2xpbmVzX2J5X2luZGV4KC0zMDApXHJcbiAgICBlbGVtZW50LmVtcHR5KClcclxuICAgIGxvZ3MucmV2ZXJzZSgpLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgZWxlbWVudC5jcmVhdGVFbCgnY29kZScsIHtcclxuICAgICAgICAgIHRleHQ6IGl0ZW0ucmVwbGFjZSgvXFx0L2dtLCAnIHwgJyksXHJcbiAgICAgIH0pXHJcbiAgICB9KVxyXG4gIH1cclxuICBjcmVhdGVfYnV0dG9uKHBhcmVudDogRWxlbWVudCwgbmFtZTogc3RyaW5nLCBjYWxsYmFjazogKCkgPT4gdm9pZCkge1xyXG4gICAgY29uc3QgYnV0dG9uID0gcGFyZW50LmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcbiAgICAgIHRleHQ6IG5hbWVcclxuICAgIH0pXHJcbiAgICBidXR0b24uc3R5bGUubWFyZ2luID0gJzEwcHgnXHJcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgIGNhbGxiYWNrKClcclxuICAgIH0pXHJcblxyXG4gIH1cclxuICBhc3luYyByZW5kZXIoKSB7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lckVsLmNoaWxkcmVuWzFdO1xyXG4gICAgY29udGFpbmVyLmVtcHR5KCk7XHJcbiAgICBjb250YWluZXIuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiU25vd2ZsYWtlIEhpc3RvcnlcIiB9KTtcclxuICAgIGNvbnRhaW5lci5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJTbm93Zmxha2UgTG9jYWwgQ2hhbmdlc1wiIH0pO1xyXG5cclxuICAgIHRoaXMubG9jYWxfbG9ncyA9IGNvbnRhaW5lci5jcmVhdGVFbCgnZGl2JylcclxuICAgIGNvbnRhaW5lci5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJTbm93Zmxha2UgU3luYyBMb2dzXCIgfSk7XHJcblxyXG4gICAgdGhpcy5zeW5jX2xvZ3MgPSBjb250YWluZXIuY3JlYXRlRWwoJ2RpdicpO1xyXG4gICAgW3RoaXMubG9jYWxfbG9ncywgdGhpcy5zeW5jX2xvZ3NdLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgIGl0ZW0uc3R5bGUuZm9udFNpemUgPSAnMTBweCdcclxuICAgICAgaXRlbS5zdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCdcclxuICAgICAgaXRlbS5zdHlsZS5tYXhIZWlnaHQgPSAnNTAwcHgnXHJcbiAgICAgIGl0ZW0uc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nXHJcbiAgICAgIGl0ZW0uc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xyXG4gICAgICBpdGVtLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAnY29sdW1uLXJldmVyc2UnXHJcbiAgICB9KVxyXG4gIH1cclxuICBhc3luYyB1cGRhdGUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCB0aGlzLnJlbG9hZF9sb2dzKHRoaXMubG9jYWxfbG9ncywgbG9jYWxfY2hhbmdlc19sb2dzKVxyXG4gICAgYXdhaXQgdGhpcy5yZWxvYWRfbG9ncyh0aGlzLnN5bmNfbG9ncywgc3luY19sb2dzKVxyXG4gIH1cclxuICBhc3luYyBvbk9wZW4oKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCB0aGlzLnJlbmRlcigpXHJcbiAgICBhd2FpdCB0aGlzLnJlbG9hZF9sb2dzKHRoaXMubG9jYWxfbG9ncywgbG9jYWxfY2hhbmdlc19sb2dzKVxyXG4gICAgYXdhaXQgdGhpcy5yZWxvYWRfbG9ncyh0aGlzLnN5bmNfbG9ncywgc3luY19sb2dzKVxyXG4gIH1cclxufSIsICJpbXBvcnQgeyBBcHAsIFdvcmtzcGFjZUxlYWYgfSBmcm9tIFwib2JzaWRpYW5cIlxyXG5pbXBvcnQgeyBsb2NhbF9jaGFuZ2VzX2xvZ3MsIHN5bmNfbG9ncyB9IGZyb20gXCJtYWluXCJcclxuaW1wb3J0IHsgSElTVE9SWV9WSUVXIH0gZnJvbSBcInNyYy9zdGF0aWNcIlxyXG5pbXBvcnQgeyBIaXN0b3J5TGVhZiB9IGZyb20gXCIuL2hpc3Rvcnlfdmlld1wiXHJcblxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCAgYWN0aXZhdGVfaGlzdG9yeV92aWV3ID0gYXN5bmMoKSA9PiAge1xyXG4gIGNvbnN0IHsgd29ya3NwYWNlIH0gPSBhcHBcclxuXHJcbiAgbGV0IGxlYWY6IFdvcmtzcGFjZUxlYWYgfCBudWxsID0gbnVsbFxyXG4gIGNvbnN0IGxlYXZlcyA9IHdvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoSElTVE9SWV9WSUVXKVxyXG4gIGlmIChsZWF2ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgbGVhZiA9IGxlYXZlc1swXVxyXG4gIH0gZWxzZSB7XHJcbiAgICBsZWFmID0gd29ya3NwYWNlLmdldFJpZ2h0TGVhZihmYWxzZSlcclxuICAgIGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHsgdHlwZTogSElTVE9SWV9WSUVXLCBhY3RpdmU6IGZhbHNlIH0pXHJcbiAgfVxyXG4gIHN5bmNfbG9ncy5zZXRfY2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKGxlYWYpXHJcbiAgICAgIChsZWFmLnZpZXcgYXMgSGlzdG9yeUxlYWYpLnVwZGF0ZSgpXHJcbiAgfSlcclxuICBsb2NhbF9jaGFuZ2VzX2xvZ3Muc2V0X2NhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmIChsZWFmKVxyXG4gICAgICAobGVhZi52aWV3IGFzIEhpc3RvcnlMZWFmKS51cGRhdGUoKVxyXG4gIH0pXHJcbn0iLCAiaW1wb3J0IHsgYWN0aXZhdGVfaGlzdG9yeV92aWV3IH0gZnJvbSBcInZpZXdzL3ZpZXdzXCJcclxuXHJcbmV4cG9ydCBjb25zdCBsb2dzX3BhbmVsID0ge1xyXG4gIGlkOiAnb3Blbl9sb2dzX3BhbmVsJyxcclxuICBuYW1lOiAnT3BlbiBTbm93Zmxha2UgTG9ncycsXHJcbiAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcclxuICAgIGFjdGl2YXRlX2hpc3RvcnlfdmlldygpXHJcbiAgfVxyXG59IiwgImltcG9ydCB7IE9wdGlvbmFsR2VuZXJhbE1vZGFsQ29uZmlnIH0gZnJvbSBcImRcIlxyXG5pbXBvcnQgeyBTdWdnZXN0TW9kYWwgfSBmcm9tIFwib2JzaWRpYW5cIlxyXG5cclxuZXhwb3J0IGNsYXNzIENvbW1hbmRTZWxlY3Rpb24gZXh0ZW5kcyBTdWdnZXN0TW9kYWw8c3RyaW5nPntcclxuXHRyZXNvbHZlOiAoXHJcblx0XHR2YWx1ZTogc3RyaW5nIHwgdW5kZWZpbmVkIHwgUHJvbWlzZUxpa2U8c3RyaW5nIHwgdW5kZWZpbmVkPlxyXG5cdCkgPT4gdm9pZFxyXG5cdGNvbmZpZzogT3B0aW9uYWxHZW5lcmFsTW9kYWxDb25maWdcclxuXHJcblx0Y29uc3RydWN0b3IoY29uZmlnOiBPcHRpb25hbEdlbmVyYWxNb2RhbENvbmZpZykge1xyXG5cdFx0c3VwZXIoYXBwKVxyXG5cdFx0dGhpcy5jb25maWcgPSB7IC4uLmNvbmZpZyB9XHJcblx0XHR0aGlzLnNldFBsYWNlaG9sZGVyKHRoaXMuY29uZmlnLnBsYWNlaG9sZGVyIHx8ICcnKVxyXG5cdH1cclxuXHJcblx0b3BlbigpOiBQcm9taXNlPHN0cmluZz4ge1xyXG5cdFx0c3VwZXIub3BlbigpXHJcblxyXG5cdFx0aWYgKHRoaXMuY29uZmlnLmluaXRpYWxWYWx1ZSAhPSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5pbnB1dEVsLnZhbHVlID0gdGhpcy5jb25maWcuaW5pdGlhbFZhbHVlXHJcblx0XHRcdHRoaXMuaW5wdXRFbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIpKVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG5cdFx0XHR0aGlzLnJlc29sdmUgPSByZXNvbHZlXHJcblx0XHR9KVxyXG5cdH1cclxuXHRzZWxlY3RTdWdnZXN0aW9uKHZhbHVlOiBzdHJpbmcsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLnJlc29sdmUpIHtcclxuXHRcdFx0bGV0IHJlc1xyXG5cdFx0XHRpZiAodGhpcy5jb25maWcuYWxsb3dFbXB0eSAmJiB2YWx1ZSA9PT0gXCIgXCIpIHJlcyA9IFwiXCJcclxuXHRcdFx0ZWxzZSBpZiAodmFsdWUgPT09IFwiLi4uXCIpIHJlcyA9IHVuZGVmaW5lZFxyXG5cdFx0XHRlbHNlIHJlcyA9IHZhbHVlXHJcblx0XHRcdHRoaXMucmVzb2x2ZShyZXMpXHJcblx0XHR9XHJcblx0XHRzdXBlci5zZWxlY3RTdWdnZXN0aW9uKHZhbHVlLCBldnQpXHJcblx0fVxyXG5cdG9uQ2xvc2UoKSB7XHJcblx0XHRpZiAodGhpcy5yZXNvbHZlKSB0aGlzLnJlc29sdmUodW5kZWZpbmVkKVxyXG5cdH1cclxuXHRnZXRTdWdnZXN0aW9ucyhxdWVyeTogc3RyaW5nKTogc3RyaW5nW10ge1xyXG5cdFx0aWYgKHRoaXMuY29uZmlnLm9ubHlTZWxlY3Rpb24pIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuY29uZmlnLm9wdGlvbnMgfHwgW11cclxuXHRcdH0gZWxzZSBpZiAodGhpcy5jb25maWcuYWxsb3dFbXB0eSkge1xyXG5cdFx0XHRyZXR1cm4gW3F1ZXJ5Lmxlbmd0aCA+IDAgPyBxdWVyeSA6IFwiIFwiLCAuLi50aGlzLmNvbmZpZy5vcHRpb25zIHx8IFtdXVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIFtxdWVyeS5sZW5ndGggPiAwID8gcXVlcnkgOiBcIi4uLlwiLCAuLi50aGlzLmNvbmZpZy5vcHRpb25zIHx8IFtdXVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZW5kZXJTdWdnZXN0aW9uKHZhbHVlOiBzdHJpbmcsIGVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG5cdFx0ZWwuc2V0VGV4dCh2YWx1ZSlcclxuXHR9XHJcblx0b25DaG9vc2VTdWdnZXN0aW9uKGl0ZW06IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkgeyB9XHJcbn1cclxuIiwgImltcG9ydCB7IGdpdGxhYiwgbG9jYWxfY2hhbmdlc19sb2dzLCBwb2NrZXQsIHJlcV9xdWV1ZSwgc3luY19sb2dzIH0gZnJvbSAnbWFpbidcclxuaW1wb3J0IHsgQ29tbWFuZFNlbGVjdGlvbiB9IGZyb20gJy4uL21vZGFsL3NlbGVjdGlvbidcclxuaW1wb3J0IHsgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nXHJcbmltcG9ydCB7IGJhc2U2NFRvQXJyYXlCdWZmZXIgfSBmcm9tICdzcmMvdXRpbHMnXHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgY29uc3QgY29tbWFuZF9fc2VuZF9hbGwgPSBhc3luYyAoKSA9PiB7XHJcbiAgY29uc3QgbmMgPSBuZXcgTm90aWNlKCdTZW5kaW5nLi4uJywgMClcclxuICBjb25zdCBzdGF0dXMgPSBbMCwgMF1cclxuICBjb25zdCByZWFkX2ZvbGRlciA9IGFzeW5jIChkaXI6IHN0cmluZykgPT4ge1xyXG4gICAgaWYgKGRpci5jb250YWlucygnLmdpdCcpIHx8IGRpci5jb250YWlucygnbm9kZV9tb2R1bGVzJykpXHJcbiAgICAgIHJldHVyblxyXG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IGFwcC52YXVsdC5hZGFwdGVyLmxpc3QoZGlyKVxyXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIGNvbnRlbnQuZmlsZXMpIHtcclxuICAgICAgbmMuc2V0TWVzc2FnZShwYXRoKVxyXG4gICAgICBzdGF0dXNbMF0gKz0gMVxyXG4gICAgICBhd2FpdCBnaXRsYWIuY3JlYXRlKHBhdGgsIHt9LCBmYWxzZSlcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBjb250ZW50LmZvbGRlcnMpIHtcclxuICAgICAgbmMuc2V0TWVzc2FnZShwYXRoKVxyXG4gICAgICBzdGF0dXNbMV0gKz0gMVxyXG4gICAgICBhd2FpdCByZWFkX2ZvbGRlcihwYXRoKVxyXG4gICAgfVxyXG4gIH1cclxuICBhd2FpdCByZWFkX2ZvbGRlcignLycpXHJcbiAgYXdhaXQgZ2l0bGFiLnNhdmVfbGFzdF9jb21taXQoKVxyXG4gIG5jLnNldE1lc3NhZ2UoYERvbmUgZm9yICR7c3RhdHVzWzBdfSBmaWxlcyBpbiAke3N0YXR1c1sxXX0gZm9sZGVyc2ApXHJcbiAgc2V0VGltZW91dCgoKSA9PiBuYy5oaWRlKCksIDEwMDAgKiA1KVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY29tbWFuZF9fc2VuZF9jaGFuZ2VzID0gYXN5bmMgKCkgPT4ge1xyXG4gIGNvbnN0IGxvZ2dlZF9sb2NhbF9jaGFuZ2VzX2Zyb21fZmlsZSA9IGF3YWl0IGxvY2FsX2NoYW5nZXNfbG9ncy5nZXRfbGluZXNfZnJvbV90b19waHJhc2UoJ0xPQ0FMIENIQU5HRVMnKVxyXG4gIGNvbnN0IGZpbGVzX3N0YXRlczogTWFwPHN0cmluZywgeyB0aW1lOiBzdHJpbmcsIGFjdGlvbjogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIG9sZF9wYXRoPzogc3RyaW5nIH0+ID0gbmV3IE1hcCgpXHJcbiAgbGV0IGxvZ2dlZF9sb2NhbF9jaGFuZ2VzX3BhcnNlZDogW3N0cmluZywgeyB0aW1lOiBzdHJpbmcsIGFjdGlvbjogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIG9sZF9wYXRoPzogc3RyaW5nIH1dW10gPSBbXVxyXG4gIGxvZ2dlZF9sb2NhbF9jaGFuZ2VzX2Zyb21fZmlsZS5yZXZlcnNlKCkuZm9yRWFjaChpdGVtID0+IHtcclxuICAgIGNvbnN0IHBhcnNlZF9vYmplY3QgPSBsb2NhbF9jaGFuZ2VzX2xvZ3MucGFyc2VyKGl0ZW0pXHJcbiAgICBpZiAoISFwYXJzZWRfb2JqZWN0Lm9sZF9wYXRoKVxyXG4gICAgICBmaWxlc19zdGF0ZXMuZGVsZXRlKHBhcnNlZF9vYmplY3Qub2xkX3BhdGgpXHJcblxyXG4gICAgaWYgKGZpbGVzX3N0YXRlcy5oYXMocGFyc2VkX29iamVjdC5wYXRoKSAmJiBwYXJzZWRfb2JqZWN0LmFjdGlvbiA9PSAnREVMRVRFJylcclxuICAgICAgZmlsZXNfc3RhdGVzLmRlbGV0ZShwYXJzZWRfb2JqZWN0LnBhdGgpXHJcblxyXG4gICAgaWYgKGZpbGVzX3N0YXRlcy5oYXMocGFyc2VkX29iamVjdC5wYXRoKSAmJiBwYXJzZWRfb2JqZWN0LmFjdGlvbiA9PSAnTU9ESUZZJykge1xyXG4gICAgICBmaWxlc19zdGF0ZXMuc2V0KHBhcnNlZF9vYmplY3QucGF0aCwgeyAuLi5wYXJzZWRfb2JqZWN0LCBhY3Rpb246ICdDUkVBVEUnIH0pXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGZpbGVzX3N0YXRlcy5zZXQocGFyc2VkX29iamVjdC5wYXRoLCBwYXJzZWRfb2JqZWN0KVxyXG4gICAgbG9nZ2VkX2xvY2FsX2NoYW5nZXNfcGFyc2VkID0gQXJyYXkuZnJvbShmaWxlc19zdGF0ZXMuZW50cmllcygpKVxyXG4gIH1cclxuICApXHJcblxyXG4gIGxvZ2dlZF9sb2NhbF9jaGFuZ2VzX3BhcnNlZC5mb3JFYWNoKChpdGVtOiBhbnkpID0+IHtcclxuICAgIGNvbnN0IHBhcnNlZCA9IGl0ZW1bMV1cclxuICAgIGlmIChwYXJzZWQuYWN0aW9uID09ICdDUkVBVEUnKVxyXG4gICAgICByZXFfcXVldWUuYXBwZW5kKGFzeW5jICgpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgYXdhaXQgZ2l0bGFiLmNyZWF0ZShwYXJzZWQucGF0aCxcclxuICAgICAgICAgICAgeyBjb21taXRfbWVzc2FnZTogYGNyZWF0aW5nIGZpbGUgXCIke3BhcnNlZC5wYXRofVwiIC0gJHtwYXJzZWQudGltZX1gIH1cclxuICAgICAgICAgICAgLCBmYWxzZSlcclxuICAgICAgICAgIHN5bmNfbG9ncy5sb2coYGNyZWF0aW5nIGZpbGUgXCIke3BhcnNlZC5wYXRofVwiYClcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2gge1xyXG4gICAgICAgICAgc3luY19sb2dzLmxvZyhgRkFJTDogY3JlYXRpbmcgZmlsZSBcIiR7cGFyc2VkLnBhdGh9XCJgKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIGlmIChwYXJzZWQuYWN0aW9uID09ICdNT0RJRlknKVxyXG4gICAgICByZXFfcXVldWUuYXBwZW5kKGFzeW5jICgpID0+IHtcclxuICAgICAgICB0cnkge1xyXG5cclxuICAgICAgICAgIGF3YWl0IGdpdGxhYi5tb2RpZnkocGFyc2VkLnBhdGgsXHJcbiAgICAgICAgICAgIHsgY29tbWl0X21lc3NhZ2U6IGBtb2RpZnlpbmcgZmlsZSBcIiR7cGFyc2VkLnBhdGh9XCIgLSAke3BhcnNlZC50aW1lfWAgfSwgZmFsc2UpXHJcbiAgICAgICAgICBzeW5jX2xvZ3MubG9nKGBtb2RpZnlpbmcgZmlsZSBcIiR7cGFyc2VkLnBhdGh9XCJgKVxyXG5cclxuICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgIHN5bmNfbG9ncy5sb2coYEZBSUw6IG1vZGlmeWluZyBmaWxlIFwiJHtwYXJzZWQucGF0aH1cImApXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgaWYgKHBhcnNlZC5hY3Rpb24gPT0gJ0RFTEVURScpXHJcbiAgICAgIHJlcV9xdWV1ZS5hcHBlbmQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCBnaXRsYWIuZGVsZXRlKHBhcnNlZC5wYXRoLFxyXG4gICAgICAgICAgICB7IGNvbW1pdF9tZXNzYWdlOiBgZGVsZXRpbmcgZmlsZSBcIiR7cGFyc2VkLnBhdGh9XCIgLSAke3BhcnNlZC50aW1lfWAgfSwgZmFsc2UpXHJcbiAgICAgICAgICBzeW5jX2xvZ3MubG9nKGBkZWxldGluZyBmaWxlIFwiJHtwYXJzZWQucGF0aH1cImApXHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICBzeW5jX2xvZ3MubG9nKGBGQUlMOiBkZWxldGluZyBmaWxlIFwiJHtwYXJzZWQucGF0aH1cImApXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgaWYgKHBhcnNlZC5hY3Rpb24gPT0gJ1JFTkFNRScpXHJcbiAgICAgIHJlcV9xdWV1ZS5hcHBlbmQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCBnaXRsYWIuY3JlYXRlKHBhcnNlZC5wYXRoLFxyXG4gICAgICAgICAgICB7IGNvbW1pdF9tZXNzYWdlOiBgcmVuYW1pbmdbY10gZmlsZSBcIiR7cGFyc2VkLm9sZF9wYXRofVwiIC0+IFwiJHtwYXJzZWQucGF0aH1cIiAtICR7cGFyc2VkLnRpbWV9YCB9LCBmYWxzZSlcclxuICAgICAgICAgIGF3YWl0IGdpdGxhYi5kZWxldGUocGFyc2VkLm9sZF9wYXRoLFxyXG4gICAgICAgICAgICB7IGNvbW1pdF9tZXNzYWdlOiBgcmVuYW1pbmdbZF0gZmlsZSBcIiR7cGFyc2VkLm9sZF9wYXRofVwiIC0+IFwiJHtwYXJzZWQucGF0aH1cIiAtICR7cGFyc2VkLnRpbWV9YCB9LCBmYWxzZSlcclxuICAgICAgICAgIHN5bmNfbG9ncy5sb2coYHJlbmFtaW5nIGZpbGUgXCIke3BhcnNlZC5vbGRfcGF0aH1cIiAtPiBcIiR7cGFyc2VkLnBhdGh9XCJgKVxyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgc3luY19sb2dzLmxvZyhgRkFJTDogcmVuYW1pbmcgZmlsZSBcIiR7cGFyc2VkLm9sZF9wYXRofVwiIC0+IFwiJHtwYXJzZWQucGF0aH1cImApXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gIH0pXHJcbiAgYXdhaXQgZ2l0bGFiLnNhdmVfbGFzdF9jb21taXQoKVxyXG4gIGxvY2FsX2NoYW5nZXNfbG9ncy5hZGRfYWN0aW9uKCdMT0NBTCBDSEFOR0VTIFBVU0hFRCcsIGAke2xvZ2dlZF9sb2NhbF9jaGFuZ2VzX3BhcnNlZC5sZW5ndGh9IGNoYW5nZXNgKVxyXG4gIGxvY2FsX2NoYW5nZXNfbG9ncy5jYWxsYmFjaygpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjb21tYW5kX19nZXRfYWxsX3JlcG8gPSBhc3luYyAoKSA9PiB7XHJcbiAgY29uc3QgaW5jbHVkZV9jb25maWcgPSBhd2FpdCBuZXcgQ29tbWFuZFNlbGVjdGlvbih7XHJcbiAgICBwbGFjZWhvbGRlcjogJ0luY2x1ZGVzIC5vYnNpZGlhbj8nLFxyXG4gICAgb3B0aW9uczogWydZRVMnLCAnTk8nXVxyXG4gIH0pLm9wZW4oKVxyXG5cclxuICBjb25zdCBjaG9vc2VfcGF0aHRyZWUgPSBhc3luYyAoc3RhcnRfcGF0aDogc3RyaW5nID0gJycpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gICAgY29uc3QgdHJlZSA9IGF3YWl0IGdpdGxhYi5yZWFkX3JlcG9fdHJlZShzdGFydF9wYXRoLCAwLCAwLCBmYWxzZSlcclxuICAgIGNvbnN0IGZvbGRlcnMgPSB0cmVlLmZpbHRlcihpdGVtID0+IGl0ZW1bMl0pLm1hcChpdGVtID0+IGl0ZW1bMV0pXHJcbiAgICBpZiAoZm9sZGVycy5sZW5ndGggPT0gMClcclxuICAgICAgcmV0dXJuIHN0YXJ0X3BhdGhcclxuICAgIGNvbnN0IHJlcG9fcGF0aCA9IGF3YWl0IG5ldyBDb21tYW5kU2VsZWN0aW9uKHtcclxuICAgICAgcGxhY2Vob2xkZXI6ICdSZXBvIGRpciBwYXRoIC0gbGVhdmUgZW1wdHkgZm9yIHdob2xlIHJlcG8gb3IgLi4gdG8gYmFjaycsXHJcbiAgICAgIG9wdGlvbnM6IGZvbGRlcnNcclxuICAgIH0pLm9wZW4oKVxyXG5cclxuICAgIGlmICghcmVwb19wYXRoKVxyXG4gICAgICByZXR1cm4gc3RhcnRfcGF0aFxyXG4gICAgaWYgKHJlcG9fcGF0aCA9PSAnLi4nKVxyXG4gICAgICByZXR1cm4gY2hvb3NlX3BhdGh0cmVlKCcnKVxyXG4gICAgcmV0dXJuIGNob29zZV9wYXRodHJlZShyZXBvX3BhdGgpXHJcbiAgfVxyXG5cclxuICBjb25zdCBwYXRoID0gYXdhaXQgY2hvb3NlX3BhdGh0cmVlKCcnKVxyXG4gIGNvbnN0IHRyZWUgPSBhd2FpdCBnaXRsYWIucmVhZF9yZXBvX3RyZWUocGF0aClcclxuICB0cmVlLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICBpZiAoaXRlbVsyXSlcclxuICAgICAgYXBwLnZhdWx0LmFkYXB0ZXIubWtkaXIoaXRlbVsxXSlcclxuICB9KVxyXG4gIGNvbnN0IGZpbGVfc3RhdHVzID0gbmV3IE5vdGljZSgnRmlsZTogJywgMClcclxuICBmb3IgKGNvbnN0IGZpbGUgb2YgdHJlZSkge1xyXG4gICAgaWYgKGluY2x1ZGVfY29uZmlnID09ICdZRVMnICYmIGZpbGVbMV0uc3RhcnRzV2l0aCgnLm9ic2lkaWFuJykpIGNvbnRpbnVlXHJcbiAgICBpZiAoZmlsZVsyXSkgY29udGludWVcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGdpdGxhYi5yZWFkKGZpbGVbMV0pXHJcbiAgICBpZiAocmVzID09IG51bGwpIGNvbnRpbnVlXHJcbiAgICBmaWxlX3N0YXR1cy5zZXRNZXNzYWdlKCdGaWxlOiAnICsgZmlsZVsxXSlcclxuICAgIGFwcC52YXVsdC5hZGFwdGVyLndyaXRlQmluYXJ5KGZpbGVbMV0sIGJhc2U2NFRvQXJyYXlCdWZmZXIocmVzLmRhdGEuY29udGVudCkpXHJcbiAgfVxyXG4gIGF3YWl0IGdpdGxhYi5zYXZlX2xhc3RfY29tbWl0KClcclxuXHJcbiAgZmlsZV9zdGF0dXMuaGlkZSgpXHJcbiAgbmV3IE5vdGljZSgnRG9uZScpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjb21tYW5kX19mZXRjaF9jaGFuZ2VzID0gYXN5bmMgKCkgPT4ge1xyXG4gIGNvbnN0IG5jID0gbmV3IE5vdGljZSgnRmV0Y2hpbmcuLi4nLCAwKVxyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGdpdGxhYi5nZXRfY29tbWl0cygpXHJcbiAgY29uc3QgbGFzdF9jb21taXQgPSByZXNbcmVzLmxlbmd0aCAtIDFdXHJcbiAgaWYgKCFsYXN0X2NvbW1pdClcclxuICAgIHJldHVybiBhd2FpdCBnaXRsYWIuc2F2ZV9sYXN0X2NvbW1pdCgpXHJcblxyXG4gIGlmIChsYXN0X2NvbW1pdC5pZCA9PSBwb2NrZXQuZ2V0KCdsYXN0X2NvbW1pdF9pZCcpKVxyXG4gICAgcmV0dXJuIG5jLnNldE1lc3NhZ2UoJ0V2ZXJ5dGhpbmcgaXMgdXAgdG8gZGF0ZScpXHJcbiAgbGV0IGNvbnRlbnRfcmVtb3RlX2NoYW5nZXMgPSAwXHJcbiAgcmVzLmZvckVhY2goKGNvbW1pdDogYW55KSA9PiB7XHJcbiAgICByZXFfcXVldWUuYXBwZW5kKGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZ2l0bGFiLmdldF9kaWZmcyhjb21taXQuaWQpXHJcbiAgICAgIHJlcz8uZGF0YS5mb3JFYWNoKGFzeW5jIChpdGVtOiBhbnkpID0+IHtcclxuICAgICAgICBjb250ZW50X3JlbW90ZV9jaGFuZ2VzKytcclxuICAgICAgICByZXFfcXVldWUuYXBwZW5kKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtLm5ld19maWxlIHx8ICghaXRlbS5yZW5hbWVkX2ZpbGUgJiYgIWl0ZW0ubmV3X2ZpbGUgJiYgIWl0ZW0uZGVsZXRlZF9maWxlKSlcclxuICAgICAgICAgICAgICBhd2FpdCBnaXRsYWIuc2F2ZV9sb2NhbF9maWxlKGl0ZW0ubmV3X3BhdGgpXHJcbiAgICAgICAgICAgIGlmIChpdGVtLnJlbmFtZWRfZmlsZSlcclxuICAgICAgICAgICAgICBhd2FpdCBhcHAudmF1bHQuYWRhcHRlci5yZW5hbWUoaXRlbS5vbGRfcGF0aCwgaXRlbS5uZXdfcGF0aClcclxuICAgICAgICAgICAgaWYgKGl0ZW0uZGVsZXRlZF9maWxlKVxyXG4gICAgICAgICAgICAgIGF3YWl0IGFwcC52YXVsdC5hZGFwdGVyLnJlbW92ZShpdGVtLm5ld19wYXRoKVxyXG4gICAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmZXRjaGluZyBlcnJvcnMnKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcbiAgICB9KVxyXG4gIH0pXHJcbiAgYXdhaXQgZ2l0bGFiLnNhdmVfbGFzdF9jb21taXQoKVxyXG4gIHJlcV9xdWV1ZS5hcHBlbmQoKCkgPT4gbG9jYWxfY2hhbmdlc19sb2dzLmFkZF9hY3Rpb24oJ0xPQ0FMIENIQU5HRVMgUFVMTEVEJywgYCR7Y29udGVudF9yZW1vdGVfY2hhbmdlc30gY2hhbmdlc2ApKVxyXG5cclxuICBuYy5zZXRNZXNzYWdlKCdFdmVyeXRoaW5nIGlzIHVwIHRvIGRhdGVcXG5MYXN0IGNvbW1pdDogJyArIHBvY2tldC5nZXQoJ2xhc3RfY29tbWl0X2lkJykpXHJcbn1cclxuXHJcblxyXG5leHBvcnQgY29uc3QgZ2V0X2FsbF9yZXBvc2l0b3J5ID0ge1xyXG4gIGlkOiAnZ2V0X2FsbF9yZXBvc2l0b3J5JyxcclxuICBuYW1lOiAnRG93bmxvYWQgYWxsIHJlcG9zaXRvcnknLFxyXG4gIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XHJcbiAgICBjb21tYW5kX19nZXRfYWxsX3JlcG8oKVxyXG4gIH1cclxufVxyXG5leHBvcnQgY29uc3QgZmV0Y2hfY2hhbmdlcyA9IHtcclxuICBpZDogJ2ZldGNoX2NoYW5nZXMnLFxyXG4gIG5hbWU6ICdGZXRjaCByZW1vdGUgY2hhbmdlcycsXHJcbiAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcclxuICAgIGNvbW1hbmRfX2ZldGNoX2NoYW5nZXMoKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHNlbmRfYWxsX2dpdGxhYiA9IHtcclxuICBpZDogJ3NlbmRfYWxsX2dpdGxhYicsXHJcbiAgbmFtZTogJ1NlbmQgYWxsIGxvY2FsIGZpbGVzJyxcclxuICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG4gICAgY29tbWFuZF9fc2VuZF9hbGwoKVxyXG4gIH0sXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBzZW5kX2NoYW5nZXNfZ2l0bGFiID0ge1xyXG4gIGlkOiAnc2VuZF9jaGFuZ2VzX2dpdGxhYicsXHJcbiAgbmFtZTogJ1NlbmQgbG9jYWwgY2hhbmdlcycsXHJcbiAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcclxuICAgIGNvbW1hbmRfX3NlbmRfY2hhbmdlcygpXHJcbiAgfVxyXG59XHJcblxyXG4iLCAiZXhwb3J0IGNvbnN0IGJhc2U2NFRvQXJyYXlCdWZmZXIgPSAoYmFzZTY0OiBzdHJpbmcpID0+IHtcclxuXHR2YXIgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjQpXHJcblx0dmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aClcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xyXG5cdFx0Ynl0ZXNbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKVxyXG5cdH1cclxuXHRyZXR1cm4gYnl0ZXMuYnVmZmVyXHJcbn0iLCAiaW1wb3J0IHtsb2dzX3BhbmVsfSBmcm9tIFwiLi9zaG93X3BhbmVsc1wiXHJcbmltcG9ydCB7ZmV0Y2hfY2hhbmdlcywgZ2V0X2FsbF9yZXBvc2l0b3J5LCBzZW5kX2FsbF9naXRsYWIsIHNlbmRfY2hhbmdlc19naXRsYWJ9IGZyb20gXCIuL3JlcG9zaXRvcnlfY29udHJvbGxlclwiXHJcblxyXG5jb25zdCBjb21tYW5kcyA9IFtcclxuICBsb2dzX3BhbmVsLFxyXG4gIGdldF9hbGxfcmVwb3NpdG9yeSxcclxuICBzZW5kX2FsbF9naXRsYWIsXHJcbiAgc2VuZF9jaGFuZ2VzX2dpdGxhYixcclxuICBmZXRjaF9jaGFuZ2VzXHJcbl1cclxuZXhwb3J0IGRlZmF1bHQgY29tbWFuZHMiLCAiaW1wb3J0IHsgZ2l0bGFiLCByZXFfcXVldWUgfSBmcm9tIFwibWFpblwiXHJcbmltcG9ydCB7IE1lbnUsIE5vdGljZSwgVEFic3RyYWN0RmlsZSwgVEZvbGRlciB9IGZyb20gXCJvYnNpZGlhblwiXHJcbmltcG9ydCB7IGJhc2U2NFRvQXJyYXlCdWZmZXIgfSBmcm9tIFwic3JjL3V0aWxzXCJcclxuXHJcbmV4cG9ydCBjb25zdCBmaWxlX21lbnVfc2VuZF9maWxlID0gKG1lbnU6IE1lbnUsIGZpbGU6IFRBYnN0cmFjdEZpbGUpID0+IHtcclxuICBtZW51LmFkZEl0ZW0oKGl0ZW0pID0+IHtcclxuICAgIGl0ZW1cclxuICAgICAgLnNldFRpdGxlKFwiR2l0bGFiOiBTZW5kIEZpbGVcIilcclxuICAgICAgLnNldEljb24oXCJzZW5kXCIpXHJcbiAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBuYyA9IG5ldyBOb3RpY2UoJ1NlbmRpbmcuLi4nLCAwKVxyXG4gICAgICAgIHJlcV9xdWV1ZS5hcHBlbmQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKChmaWxlIGFzIFRGb2xkZXIpLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWRfZm9sZGVyID0gYXN5bmMgKGRpcjogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IGFwcC52YXVsdC5hZGFwdGVyLmxpc3QoZGlyKVxyXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBjb250ZW50LmZpbGVzKSB7XHJcbiAgICAgICAgICAgICAgICBuYy5zZXRNZXNzYWdlKHBhdGgpXHJcbiAgICAgICAgICAgICAgICBhd2FpdCBnaXRsYWIuY3JlYXRlKHBhdGgpXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBjb250ZW50LmZvbGRlcnMpIHtcclxuICAgICAgICAgICAgICAgIG5jLnNldE1lc3NhZ2UocGF0aClcclxuICAgICAgICAgICAgICAgIGF3YWl0IHJlYWRfZm9sZGVyKHBhdGgpXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF3YWl0IHJlYWRfZm9sZGVyKGZpbGUucGF0aClcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGdpdGxhYi5jcmVhdGUoZmlsZS5wYXRoKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbmMuc2V0TWVzc2FnZSgnRG9uZScpXHJcbiAgICAgICAgfSlcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG5jLmhpZGUoKSwgMTAwMCAqIDUpXHJcbiAgICAgIH0pXHJcbiAgfSlcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGZpbGVfbWVudV9sb2FkX2ZpbGUgPSAobWVudTogTWVudSwgZmlsZTogVEFic3RyYWN0RmlsZSkgPT4ge1xyXG4gIG1lbnUuYWRkSXRlbSgoaXRlbSkgPT4ge1xyXG4gICAgaXRlbVxyXG4gICAgICAuc2V0VGl0bGUoXCJHaXRsYWI6IExvYWQgRmlsZVwiKVxyXG4gICAgICAuc2V0SWNvbihcImZpbGUtZG93blwiKVxyXG4gICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbmMgPSBuZXcgTm90aWNlKCdMb2FkaW5nLi4uJywgMClcclxuICAgICAgICByZXFfcXVldWUuYXBwZW5kKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgIGlmICgoZmlsZSBhcyBURm9sZGVyKS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBjb25zdCB0cmVlID0gYXdhaXQgZ2l0bGFiLnJlYWRfcmVwb190cmVlKGZpbGUucGF0aClcclxuICAgICAgICAgICAgdHJlZS5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChpdGVtWzJdKVxyXG4gICAgICAgICAgICAgICAgYXBwLnZhdWx0LmFkYXB0ZXIubWtkaXIoaXRlbVsxXSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIHRyZWUpIHtcclxuICAgICAgICAgICAgICBpZiAoZmlsZVsyXSkgY29udGludWVcclxuICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBnaXRsYWIucmVhZChmaWxlWzFdKVxyXG4gICAgICAgICAgICAgIGlmIChyZXMgPT0gbnVsbCkgY29udGludWVcclxuICAgICAgICAgICAgICBhcHAudmF1bHQuYWRhcHRlci53cml0ZUJpbmFyeShmaWxlWzFdLCBiYXNlNjRUb0FycmF5QnVmZmVyKHJlcy5kYXRhLmNvbnRlbnQpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBnaXRsYWIucmVhZChmaWxlLnBhdGgpXHJcbiAgICAgICAgICAgIGlmIChyZXMgPT0gbnVsbCkgcmV0dXJuXHJcbiAgICAgICAgICAgIGFwcC52YXVsdC5hZGFwdGVyLndyaXRlQmluYXJ5KGZpbGUucGF0aCwgYmFzZTY0VG9BcnJheUJ1ZmZlcihyZXMuZGF0YS5jb250ZW50KSlcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5jLnNldE1lc3NhZ2UoJ0RvbmUnKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBuYy5oaWRlKCksIDEwMDAgKiA3KVxyXG5cclxuICAgICAgfSlcclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZmlsZV9tZW51X2RlbGV0ZV9maWxlID0gKG1lbnU6IE1lbnUsIGZpbGU6IFRBYnN0cmFjdEZpbGUpID0+IHtcclxuICBtZW51LmFkZEl0ZW0oKGl0ZW0pID0+IHtcclxuICAgIGl0ZW1cclxuICAgICAgLnNldFRpdGxlKFwiR2l0bGFiOiBEZWxldGUgRmlsZVwiKVxyXG4gICAgICAuc2V0SWNvbihcInRyYXNoLTJcIilcclxuICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5jID0gbmV3IE5vdGljZSgnRGVsZXRpbmcuLi4nLCAwKVxyXG4gICAgICAgIHJlcV9xdWV1ZS5hcHBlbmQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKChmaWxlIGFzIGFueSkuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgcmVhZF9mb2xkZXIgPSBhc3luYyAoZGlyOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgYXBwLnZhdWx0LmFkYXB0ZXIubGlzdChkaXIpXHJcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIGNvbnRlbnQuZmlsZXMpIHtcclxuICAgICAgICAgICAgICAgIG5jLnNldE1lc3NhZ2UocGF0aClcclxuICAgICAgICAgICAgICAgIGF3YWl0IGdpdGxhYi5kZWxldGUocGF0aClcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIGNvbnRlbnQuZm9sZGVycykge1xyXG4gICAgICAgICAgICAgICAgbmMuc2V0TWVzc2FnZShwYXRoKVxyXG4gICAgICAgICAgICAgICAgYXdhaXQgcmVhZF9mb2xkZXIocGF0aClcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXdhaXQgcmVhZF9mb2xkZXIoZmlsZS5wYXRoKVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXdhaXQgZ2l0bGFiLmRlbGV0ZShmaWxlLnBhdGgpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBuYy5zZXRNZXNzYWdlKCdEb25lJylcclxuICAgICAgICB9KVxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbmMuaGlkZSgpLCAxMDAwICogNSlcclxuICAgICAgfSlcclxuICB9KVxyXG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQSxpQkFBQUE7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsbUJBQStCOzs7QUNBL0Isc0JBQXdEOzs7QUNFekMsU0FBUixLQUFzQixJQUFJLFNBQVM7QUFDeEMsU0FBTyxTQUFTLE9BQU87QUFDckIsV0FBTyxHQUFHLE1BQU0sU0FBUyxTQUFTO0FBQUEsRUFDcEM7QUFD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QUFXO0FBQ25ELGNBQUksS0FBSyxTQUFTO0FBQ2pCLHNCQUFVLE9BQU8sWUFBWTtBQUM1QixvQkFBTSxPQUFPLE9BQU8sS0FBSyxJQUFJO0FBQzdCLG9CQUFNLE9BQU8sT0FBTyxRQUFRO0FBQUEsWUFDN0IsQ0FBQztBQUFBLFFBQ0gsQ0FBQztBQUFBLE1BQ0Y7QUFBQSxJQUNELEdBQUcsTUFBTyxDQUFDO0FBQ1gsZUFBVyxNQUFNO0FBQ2hCLDRCQUFzQjtBQUFBLElBQ3ZCLEdBQUcsR0FBSTtBQUNQLFNBQUssY0FBYyxJQUFJLGtCQUFrQixLQUFLLEtBQUssSUFBSSxDQUFDO0FBQUEsRUFDekQ7QUFBQSxFQUNBLE1BQU0sZUFBZTtBQUNwQixTQUFLLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsTUFBTSxLQUFLLFNBQVMsQ0FBQztBQUN6RSxXQUFPLFNBQVMsc0JBQXNCLEtBQUssU0FBUyxlQUFhLEtBQUssU0FBUztBQUMvRSxVQUFNLGtCQUFrQixLQUFLLGdCQUFnQjtBQUM3QyxXQUFPLFdBQVcsZUFBZTtBQUFBLEVBQ2xDO0FBQUEsRUFDQSxNQUFNLGVBQWU7QUFDcEIsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQ2pDLFdBQU8sU0FBUyxzQkFBc0IsS0FBSyxTQUFTLGVBQWEsS0FBSyxTQUFTO0FBQy9FLFVBQU0sa0JBQWtCLEtBQUssZ0JBQWdCO0FBQzdDLFdBQU8sV0FBVyxlQUFlO0FBQUEsRUFDbEM7QUFDRDsiLAogICJuYW1lcyI6IFsiU3luY1Nub3dmbGFrZSIsICJpbXBvcnRfb2JzaWRpYW4iLCAicHJvdG90eXBlIiwgImRlc2NyaXB0b3JzIiwgImZpbHRlciIsICJoYXNPd25Qcm9wZXJ0eSIsICJmaWx0ZXIiLCAicGF0aCIsICJwcm90b3R5cGUiLCAidG9TdHJpbmciLCAiZW5jb2RlIiwgInBhdGgiLCAicGF0aCIsICJpc0Zvcm1EYXRhIiwgImlzRmlsZUxpc3QiLCAidHJhbnNpdGlvbmFsIiwgImZpbHRlciIsICJzZWxmIiwgInByb3RvdHlwZSIsICJ2YWxpZGF0ZVN0YXR1cyIsICJwYXRoIiwgInRyYW5zaXRpb25hbCIsICJtZXJnZSIsICJ2YWxpZGF0b3JzIiwgInRyYW5zaXRpb25hbCIsICJBeGlvcyIsICJBeGlvc0Vycm9yIiwgIkNhbmNlbGVkRXJyb3IiLCAiaXNDYW5jZWwiLCAiQ2FuY2VsVG9rZW4iLCAiVkVSU0lPTiIsICJhbGwiLCAiaXNBeGlvc0Vycm9yIiwgInNwcmVhZCIsICJ0b0Zvcm1EYXRhIiwgIkF4aW9zSGVhZGVycyIsICJIdHRwU3RhdHVzQ29kZSIsICJtZXJnZUNvbmZpZyIsICJwYXRoIiwgImUiLCAiZ2l0bGFiIiwgInBhdGgiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJiYXNlNjRUb0FycmF5QnVmZmVyIiwgInBhdGgiLCAidHJlZSIsICJiYXNlNjRUb0FycmF5QnVmZmVyIiwgInJlcyIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGF0aCIsICJpdGVtIiwgImZpbGUiLCAiYmFzZTY0VG9BcnJheUJ1ZmZlciIsICJTeW5jU25vd2ZsYWtlIl0KfQo=
